* Start

** Init

#+begin_src emacs-lisp :tangle yes
;;; Commentary:

;; Goals:
;; 1. Frictionless
;; 2. Robust
;; 3. Fast
;; 4. Flexible

;;; Code:

;;
;; -- PACKAGE SETUP ---
;;

;; For Nix
(require 'package)

;; optional. makes impure packages archives unavailable
(setq package-archives nil)

(setq package-enable-at-startup nil)
(package-initialize)

(require 'use-package)
(setq use-package-always-ensure t)

;; For non Nix Setups
;; (require 'package)

;; (setq package-archives '(("melpa" . "https://melpa.org/packages/")
;; 			    ("elpa" . "https://elpa.gnu.org/packages/")))

;; (package-initialize)
;; (unless package-archive-contents
;;   (package-refresh-contents))

;; (unless (package-installed-p 'use-package)
;;   (package-install 'use-package))

;; (require 'use-package)
;; (setq use-package-always-ensure t)

;;
;; --- MISC ---
;;

(setq visible-bell nil
      auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))

(setq-default left-margin-width 1
	      sentence-end-double-space nil
	      lisp-backquote-indentation nil
	      blink-cursor-blinks 10
	      fast-but-imprecise-scrolling t
	      auto-save-interval 60
	      kill-do-not-save-duplicates t
	      bidi-paragraph-direction 'left-to-right
	      bidi-inhibit-bpa t)

;; (global-so-long-mode 1)
(save-place-mode 1)

;; don't back up files
;; (setq make-backup-files nil)

;; Write backup files to tmp dir
;; (setq backup-directory-alist `((".*" . ,temporary-file-directory)) )

;; Write backup files to backup directory instead of editing directory
(setq backup-directory-alist
      `(("." . ,(expand-file-name
                 (concat user-emacs-directory "backups")))))

;; Make backups of files, even when they're in version control
(setq vc-make-backup-files t)

;; Automatically purge backup files not accessed in a week:
(message "Deleting old backup files...")
(let ((week (* 60 60 24 7))
      (current (float-time (current-time))))
  (dolist (file (directory-files temporary-file-directory t))
    (when (and (backup-file-name-p file)
             (> (- current (float-time (fifth (file-attributes file))))
                week))
      (message "%s" file)
      (delete-file file))))

;; Use hex mode for binary files
(add-to-list 'auto-mode-alist '("\\.bin\\'" . hexl-mode))
(add-to-list 'auto-mode-alist '("\\.dat\\'" . hexl-mode))
(add-to-list 'auto-mode-alist '("\\.exe\\'" . hexl-mode))
(add-to-list 'auto-mode-alist '("\\.o\\'" . hexl-mode))

;; Use UTF-8 Encoding
(prefer-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)

;; Always confirm closing Emacs
(setq confirm-kill-emacs #'yes-or-no-p)

;; Replace "yes or no" prompts with "y or n" prompts
(defalias 'yes-or-no-p #'y-or-n-p
  "Use `y-or-n-p' instead of a yes/no prompt.")

;; Add newlines when C-n at the end of file
(setq next-line-add-newlines t)

;; Eww
(setq eww-search-prefix "http://frogfind.com/?q=")

;; Emacs run launcher
(defun emacs-run-launcher ()
  "A frame to launch desktop applications."
  (interactive)
  (with-selected-frame
      (make-frame '((name . "emacs-run-launcher")
		    (minibuffer . only)
		    (width . 100)
		    (height . 11)))
    (unwind-protect
	(app-launcher-run-app)
      (delete-frame))))

;; Transparency
;; (set-frame-parameter (selected-frame) 'alpha '(70 . 70))
;; (add-to-list 'default-frame-alist '(alpha . (70 . 70)))

(defun toggle-transparency ()
  "Toggles emacs transparency."
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter
     nil 'alpha
     (if (eql (cond ((numberp alpha) alpha)
                   ((numberp (cdr alpha)) (cdr alpha))
                   ;; Also handle undocumented (<active> <inactive>) form.
                   ((numberp (cadr alpha)) (cadr alpha)))
             100)
         '(70 . 70) '(100 . 100)))))

;; Set the fringe to an big enough width
(custom-set-variables '(fringe-mode 20))
#+end_src

** performance

#+begin_src emacs-lisp :tangle yes
;;
;; --- GARBAGE COLLECTION ---
;;

;; Taken from https://gitlab.com/rycee/nur-expressions/blob/master/hm-modules/emacs-init.nix
(defun hm/reduce-gc ()
  "Reduce the frequency of garbage collection."
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6))

(defun hm/restore-gc ()
  "Restore the frequency of garbage collection."
  (setq gc-cons-threshold 16777216
        gc-cons-percentage 0.1))

;; Make GC more rare during init, while minibuffer is active, and
;; when shutting down. In the latter two cases we try doing the
;; reduction early in the hook.
(hm/reduce-gc)
(add-hook 'minibuffer-setup-hook #'hm/reduce-gc -50)
(add-hook 'kill-emacs-hook #'hm/reduce-gc -50)

;; But make it more regular after startup and after closing minibuffer.
(add-hook 'emacs-startup-hook #'hm/restore-gc)
(add-hook 'minibuffer-exit-hook #'hm/restore-gc)

;; Avoid unnecessary regexp matching while loading .el files.
(defvar hm/file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(defun hm/restore-file-name-handler-alist ()
  "Restore the \'file-name-handler-alist\' variable."
  (setq file-name-handler-alist hm/file-name-handler-alist)
  (makunbound 'hm/file-name-handler-alist))
(add-hook 'emacs-startup-hook #'hm/restore-file-name-handler-alist)

;;
;; --- ASYNC ---
;;

;; Emacs look SIGNIFICANTLY less often which is a good thing.
;; asynchronous bytecode compilation and various other actions makes
(use-package async
  :ensure t
  :defer t
  :init
  (dired-async-mode 1)
  (async-bytecomp-package-mode 1)
  :custom (async-bytecomp-allowed-packages '(all)))

;;
;; --- NATIVE COMP ---
;;

;; Silence compiler warnings as they can be pretty disruptive
;; (setq comp-async-report-warnings-errors nil)

;; Silence compiler warnings as they can be pretty disruptive
(if (boundp 'comp-deferred-compilation)
    (setq comp-deferred-compilation nil)
  (setq inhibit-automatic-native-compilation nil))

;; In noninteractive sessions, prioritize non-byte-compiled source files to
;; prevent the use of stale byte-code. Otherwise, it saves us a little IO time
;; to skip the mtime checks on every *.elc file.
(setq load-prefer-newer noninteractive)
#+end_src

** visuals

#+begin_src emacs-lisp :tangle yes
;;
;; --- MISC ---
;;

(scroll-bar-mode -1) ; Disables the visible scrollbar
(tool-bar-mode -1)   ; Disables the toolbar
(menu-bar-mode -1)   ; Disables the menubar
(tooltip-mode -1)    ; Disables tooltips

;; Make the cursor a bar
;; (setq-default cursor-type 'bar)
(setq-default cursor-type 'hollow)

;; Beacon
(use-package beacon
  :config
  (beacon-mode 1))

;; Visual feedback on yank/kill
(use-package goggles
  :hook ((prog-mode text-mode) . goggles-mode)
  :config
  (setq-default goggles-pulse nil))

;; Display Line numbers
;; (column-number-mode)
;; (global-display-line-numbers-mode t)

;; Disable line numbers for some modes
;; (dolist (mode '(org-mode-hook
;; 		term-mode-hook
;; 		shell-mode-hook
;; 		eshell-mode-hook
;; 		vterm-mode-hook
;; 		cider-repl-mode-hook
;; 		racket-repl-mode-hook
;; 		geiser-repl-mode-hook))
;;   (add-hook mode (lambda () (display-line-numbers-mode 0))))

;; Window dividers
(setq window-divider-default-right-width 3)
(let ((color (face-background 'mode-line)))
  (dolist (face '(window-divider-first-pixel
		  window-divider-last-pixel
		  window-divider))
    (set-face-foreground face color)))
(window-divider-mode 1)

;; Add padding to the sides
;; (require 'frame)
;; (setq-default default-frame-alist
;; 	      (append (list
;; 		       '(internal-border-width . 20)
;; 		       ;; '(left-fringe . 0)
;; 		       ;; '(right-fringe . 0)
;; 		       '(tool-bar-lines . 0)
;; 		       '(menu-bar-lines . 0)
;; 		       '(line-spacing . 0.075)
;; 		       '(vertical-scroll-bars . nil))))
;; (setq-default window-resize-pixelwise t)
;; (setq-default frame-resize-pixelwise t)
;; (add-hook 'before-make-frame-hook 'window-divider-mode)

;; (use-package visual-fill-column
;;   ;; :hook
;;   ;; (text-mode   . visual-fill-column-mode)
;;   ;; (prog-mode   . visual-fill-column-mode)
;;   ;; (conf-mode   . visual-fill-column-mode)
;;   ;; (fundamental-mode . visual-fill-column-mode)
;;   ;; (term-mode   . visual-fill-column-mode)
;;   ;; (eshell-mode . visual-fill-column-mode)
;;   :custom
;;   (global-visual-fill-column-mode t)
;;   (visual-fill-column-width 100)
;;   (visual-fill-column-center-text t)
;;   :config
;;   (add-hook 'pdf-view-mode-hook (lambda () (visual-fill-column-mode 0))))

;; Center text in the frame
(use-package olivetti
  :hook ((text-mode         . olivetti-mode)
         (prog-mode         . olivetti-mode)
         (Info-mode         . olivetti-mode)
	 (woman-mode        . olivetti-mode)
         (org-mode          . olivetti-mode)
         (mu4e-view-mode    . olivetti-mode)
         (elfeed-show-mode  . olivetti-mode)
         (mu4e-compose-mode . olivetti-mode)
	 (eshell-mode . (lambda ()
			  (setq-local olivetti-body-width 150)
			  (olivetti-mode))))
  :custom
  (olivetti-body-width 100))

;; Super smooth scrolling
;; (setq scroll-step            1
;;       scroll-conservatively  10000)
;; (setq next-screen-context-lines 5)

;; Smooth scrolling
;; (setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
;; (setq mouse-wheel-progressive-speed nil)

;; Smooth pixel scrolling
;; (pixel-scroll-mode 1)

;; (pixel-scroll-precision-mode)

;; (setq-local scroll-margin 1
;; 	    scroll-conservatively 101
;; 	    scroll-up-aggressively 0.01
;; 	    scroll-down-aggressively 0.01
;; 	    scroll-preserve-screen-position t
;; 	    auto-window-vscroll nil)

;; Minimap
;; (use-package minimap
;;   :custom
;;   (minimap-window-location ')
;;   :config
;;   (minimap-mode))

;;
;; --- FONT ---
;;

;; Setting the font
(set-face-attribute 'default nil :family "Victor Mono")
;; Set fixed pitch face
;; (set-face-attribute 'fixed-pitch nil :font "Victor Mono")
;; Set variable pitch face
;; (set-face-attribute 'variable-pitch nil :font "Oxygen-Sans")

;; Don't unload fonts when not in use
(setq inhibit-compacting-font-caches t)

;; Icons
(use-package all-the-icons
  :custom
  (all-the-icons-scale-factor 1.0)
  (all-the-icons-default-adjust 0.0)
  :config
  (when (and (not (if (find-font (font-spec :name "all-the-icons")) t nil))
           (window-system))
    (all-the-icons-install-fonts t)))

;; Ligatures and Indicators
;; (use-package pretty-mode
;;   :config
;;   (add-hook 'prog-mode-hook 'pretty-mode))
(add-hook 'prog-mode-hook 'prettify-symbols-mode)

;; APL-like characters for scheme
(add-hook
 'scheme-mode-hook
 (lambda ()
   (setq prettify-symbols-alist '(("lambda" . #x3BB)
				  ("->"    . #x2192)
				  ("<=="   . #x21D0)
				  ("==>"   . #x21D2)
				  ("<="       . "≤")
				  (">="       . "≥")
				  ("define"   . "≝")
				  ("set!"     . "≐")
				  ("set-car!" . "≔")
				  ("set-cdr!" . "≕")
				  ("#t"       . "✓")
				  ("#f"       . "✗")
				  ("'()"      . "∅")
				  ("null"     . "∅")
				  ("if"       . "⁇")
				  ("or"       . "∨")
				  ("and"      . "∧")
				  ("not"      . "¬")))
   (prettify-symbols-mode 1)))

;; APL-like characters for elisp
(add-hook
 'emacs-lisp-mode-hook
 (lambda ()
   (setq prettify-symbols-alist '(("lambda" . #x3BB)
				  ("->"    . #x2192)
				  ("<=="   . #x21D0)
				  ("==>"   . #x21D2)
				  ("<="       . "≤")
				  (">="       . "≥")
				  ("t"        . "✓")
				  ("'()"      . "∅")
				  ("nil"      . "∅")
				  ("if"       . "⁇")
				  ("or"       . "∨")
				  ("and"      . "∧")
				  ("not"      . "¬")))
   (prettify-symbols-mode 1)))

(defconst pragmatapro-prettify-symbols-alist
  (mapcar (lambda (s)
            `(,(car s)
              .
              ,(vconcat
                (apply 'vconcat
                       (make-list
                        (- (length (car s)) 1)
                        (vector (decode-char 'ucs #X0020) '(Br . Bl))))
                (vector (decode-char 'ucs (cadr s))))))
          '(("[ERROR]"    #XE2C0)
            ("[DEBUG]"    #XE2C1)
            ("[INFO]"     #XE2C2)
            ("[WARN]"     #XE2C3)
            ("[WARNING]"  #XE2C4)
            ("[ERR]"      #XE2C5)
            ("[FATAL]"    #XE2C6)
            ("[TRACE]"    #XE2C7)
            ("[FIXME]"    #XE2C8)
            ("[TODO]"     #XE2C9)
            ("[BUG]"      #XE2CA)
            ("[NOTE]"     #XE2CB)
            ("[HACK]"     #XE2CC)
            ("[MARK]"     #XE2CD)
            ("# ERROR"    #XE2F0)
            ("# DEBUG"    #XE2F1)
            ("# INFO"     #XE2F2)
            ("# WARN"     #XE2F3)
            ("# WARNING"  #XE2F4)
            ("# ERR"      #XE2F5)
            ("# FATAL"    #XE2F6)
            ("# TRACE"    #XE2F7)
            ("# FIXME"    #XE2F8)
            ("# TODO"     #XE2F9)
            ("# BUG"      #XE2FA)
            ("# NOTE"     #XE2FB)
            ("# HACK"     #XE2FC)
            ("# MARK"     #XE2FD)
            ("// ERROR"   #XE2E0)
            ("// DEBUG"   #XE2E1)
            ("// INFO"    #XE2E2)
            ("// WARN"    #XE2E3)
            ("// WARNING" #XE2E4)
            ("// ERR"     #XE2E5)
            ("// FATAL"   #XE2E6)
            ("// TRACE"   #XE2E7)
            ("// FIXME"   #XE2E8)
            ("// TODO"    #XE2E9)
            ("// BUG"     #XE2EA)
            ("// NOTE"    #XE2EB)
            ("// HACK"    #XE2EC)
            ("// MARK"    #XE2ED)
            ("!!"         #XE900)
            ("!="         #XE901)
            ("!=="        #XE902)
            ("!!!"        #XE903)
            ("!≡"         #XE904)
            ("!≡≡"        #XE905)
            ("!>"         #XE906)
            ("!=<"        #XE907)
            ("#("         #XE920)
            ("#_"         #XE921)
            ("#{"         #XE922)
            ("#?"         #XE923)
            ("#>"         #XE924)
            ("##"         #XE925)
            ("#_("        #XE926)
            ("%="         #XE930)
            ("%>"         #XE931)
            ("%>%"        #XE932)
            ("%<%"        #XE933)
            ("&%"         #XE940)
            ("&&"         #XE941)
            ("&*"         #XE942)
            ("&+"         #XE943)
            ("&-"         #XE944)
            ("&/"         #XE945)
            ("&="         #XE946)
            ("&&&"        #XE947)
            ("&>"         #XE948)
            ("$>"         #XE955)
            ("***"        #XE960)
            ("*="         #XE961)
            ("*/"         #XE962)
            ("*>"         #XE963)
            ("++"         #XE970)
            ("+++"        #XE971)
            ("+="         #XE972)
            ("+>"         #XE973)
            ("++="        #XE974)
            ("--"         #XE980)
            ("-<"         #XE981)
            ("-<<"        #XE982)
            ("-="         #XE983)
            ("->"         #XE984)
            ("->>"        #XE985)
            ("---"        #XE986)
            ("-->"        #XE987)
            ("-+-"        #XE988)
            ("-\\/"       #XE989)
            ("-|>"        #XE98A)
            ("-<|"        #XE98B)
            (".."         #XE990)
            ("..."        #XE991)
            ("..<"        #XE992)
            (".>"         #XE993)
            (".~"         #XE994)
            (".="         #XE995)
            ("/*"         #XE9A0)
            ("//"         #XE9A1)
            ("/>"         #XE9A2)
            ("/="         #XE9A3)
            ("/=="        #XE9A4)
            ("///"        #XE9A5)
            ("/**"        #XE9A6)
            (":::"        #XE9AF)
            ("::"         #XE9B0)
            (":="         #XE9B1)
            (":≡"         #XE9B2)
            (":>"         #XE9B3)
            (":=>"        #XE9B4)
            (":("         #XE9B5)
            (":-("        #XE9B6)
            (":)"         #XE9B7)
            (":-)"        #XE9B8)
            (":/"         #XE9B9)
            (":\\"        #XE9BA)
            (":3"         #XE9BB)
            (":D"         #XE9BC)
            (":P"         #XE9BD)
            (":>:"        #XE9BE)
            (":<:"        #XE9BF)
            ("<$>"        #XE9C0)
            ("<*"         #XE9C1)
            ("<*>"        #XE9C2)
            ("<+>"        #XE9C3)
            ("<-"         #XE9C4)
            ("<<"         #XE9C5)
            ("<<<"        #XE9C6)
            ("<<="        #XE9C7)
            ("<="         #XE9C8)
            ("<=>"        #XE9C9)
            ("<>"         #XE9CA)
            ("<|>"        #XE9CB)
            ("<<-"        #XE9CC)
            ("<|"         #XE9CD)
            ("<=<"        #XE9CE)
            ("<~"         #XE9CF)
            ("<~~"        #XE9D0)
            ("<<~"        #XE9D1)
            ("<$"         #XE9D2)
            ("<+"         #XE9D3)
            ("<!>"        #XE9D4)
            ("<@>"        #XE9D5)
            ("<#>"        #XE9D6)
            ("<%>"        #XE9D7)
            ("<^>"        #XE9D8)
            ("<&>"        #XE9D9)
            ("<?>"        #XE9DA)
            ("<.>"        #XE9DB)
            ("</>"        #XE9DC)
            ("<\\>"       #XE9DD)
            ("<\">"       #XE9DE)
            ("<:>"        #XE9DF)
            ("<~>"        #XE9E0)
            ("<**>"       #XE9E1)
            ("<<^"        #XE9E2)
            ("<!"         #XE9E3)
            ("<@"         #XE9E4)
            ("<#"         #XE9E5)
            ("<%"         #XE9E6)
            ("<^"         #XE9E7)
            ("<&"         #XE9E8)
            ("<?"         #XE9E9)
            ("<."         #XE9EA)
            ("</"         #XE9EB)
            ("<\\"        #XE9EC)
            ("<\""        #XE9ED)
            ("<:"         #XE9EE)
            ("<->"        #XE9EF)
            ("<!--"       #XE9F0)
            ("<--"        #XE9F1)
            ("<~<"        #XE9F2)
            ("<==>"       #XE9F3)
            ("<|-"        #XE9F4)
            ("<<|"        #XE9F5)
            ("<-<"        #XE9F7)
            ("<-->"       #XE9F8)
            ("<<=="       #XE9F9)
            ("<=="        #XE9FA)
            ("=<<"        #XEA00)
            ("=="         #XEA01)
            ("==="        #XEA02)
            ("==>"        #XEA03)
            ("=>"         #XEA04)
            ("=~"         #XEA05)
            ("=>>"        #XEA06)
            ("=/="        #XEA07)
            ("=~="        #XEA08)
            ("==>>"       #XEA09)
            ("≡≡"         #XEA10)
            ("≡≡≡"        #XEA11)
            ("≡:≡"        #XEA12)
            (">-"         #XEA20)
            (">="         #XEA21)
            (">>"         #XEA22)
            (">>-"        #XEA23)
            (">>="        #XEA24)
            (">>>"        #XEA25)
            (">=>"        #XEA26)
            (">>^"        #XEA27)
            (">>|"        #XEA28)
            (">!="        #XEA29)
            (">->"        #XEA2A)
            ("??"         #XEA40)
            ("?~"         #XEA41)
            ("?="         #XEA42)
            ("?>"         #XEA43)
            ("???"        #XEA44)
            ("?."         #XEA45)
            ("^="         #XEA48)
            ("^."         #XEA49)
            ("^?"         #XEA4A)
            ("^.."        #XEA4B)
            ("^<<"        #XEA4C)
            ("^>>"        #XEA4D)
            ("^>"         #XEA4E)
            ("\\\\"       #XEA50)
            ("\\>"        #XEA51)
            ("\\/-"       #XEA52)
            ("@>"         #XEA57)
            ("|="         #XEA60)
            ("||"         #XEA61)
            ("|>"         #XEA62)
            ("|||"        #XEA63)
            ("|+|"        #XEA64)
            ("|->"        #XEA65)
            ("|-->"       #XEA66)
            ("|=>"        #XEA67)
            ("|==>"       #XEA68)
            ("|>-"        #XEA69)
            ("|<<"        #XEA6A)
            ("||>"        #XEA6B)
            ("|>>"        #XEA6C)
            ("|-"         #XEA6D)
            ("||-"        #XEA6E)
            ("~="         #XEA70)
            ("~>"         #XEA71)
            ("~~>"        #XEA72)
            ("~>>"        #XEA73)
            ("[["         #XEA80)
            ("]]"         #XEA81)
            ("\">"        #XEA90)
            ("_|_"        #XEA97)
            )))

(defun add-pragmatapro-prettify-symbols-alist ()
  (setq prettify-symbols-alist pragmatapro-prettify-symbols-alist))

;; enable prettified symbols on comments
(defun setup-compose-predicate ()
  (setq prettify-symbols-compose-predicate
        (defun my-prettify-symbols-default-compose-p (start end _match)
          "Same as `prettify-symbols-default-compose-p', except compose symbols in comments as well."
          (let* ((syntaxes-beg (if (memq (char-syntax (char-after start)) '(?w ?_))
                                   '(?w ?_) '(?. ?\\)))
                 (syntaxes-end (if (memq (char-syntax (char-before end)) '(?w ?_))
                                   '(?w ?_) '(?. ?\\))))
            (not (or (memq (char-syntax (or (char-before start) ?\s)) syntaxes-beg)
                     (memq (char-syntax (or (char-after end) ?\s)) syntaxes-end)
                     (nth 3 (syntax-ppss))))))))

;; main hook fn, just add to text-mode/prog-mode
(defun prettify-hook ()
  (add-pragmatapro-prettify-symbols-alist)
  (setup-compose-predicate))

;;
;; --- THEME ---
;;

(setq custom-safe-themes t) ; Treat all themes as safe
(add-to-list 'custom-theme-load-path (expand-file-name "~/.emacs.d/themes/"))
;; (add-hook 'emacs-startup-hook (lambda () (load-theme 'plain-dark t)))
(add-hook 'emacs-startup-hook (lambda () (load-theme 'plain-light t)))

;;
;; --- MODE-LINE ---
;;

;; (use-package smart-mode-line
;;   :config
;;   (setq sml/theme 'cory)
;;   (sml/setup))

;; (use-package rich-minority
;;   :config
;;   (rich-minority-mode 1)
;;   (setf rm-blacklist ""))

;; Buffer state in modeline
(defface modeline-narrow-face
  '((t (:foreground "#141404" :background "#ed8f23")))
  "Todo/fixme highlighting."
  :group 'faces)

(defface modeline-read-only-face
  '((t (:foreground "#141404" :background "#9feaae")))
  "Read-only buffer highlighting."
  :group 'faces)

(defface modeline-modified-face
  '((t (:foreground "#d8d8d8" :background "#e60909")))
  "Modified buffer highlighting."
  :group 'faces)

;; Git diff in modeline
;; https://cocktailmake.github.io/posts/emacs-modeline-enhancement-for-git-diff/
;; (defadvice vc-git-mode-line-string (after plus-minus (file) compile activate)
;;   "Show the information of git diff in status-line"
;;   (setq ad-return-value
;;         (concat ad-return-value
;;                 (let ((plus-minus (vc-git--run-command-string
;;                                    file "diff" "--numstat" "--")))
;;                   (if (and plus-minus
;;                            (string-match "^\\([0-9]+\\)\t\\([0-9]+\\)\t" plus-minus))
;;                       (concat
;;                        " "
;;                        (format "+%s" (match-string 1 plus-minus))
;;                        (format "-%s" (match-string 2 plus-minus)))
;;                     "")))))

;; Git Parse Repo Status
;; See https://kitchingroup.cheme.cmu.edu/blog/2014/09/19/A-git-status-Emacs-modeline/
(defun cory/mode-line-git-parse-status ()
  "Display the status of the repo."
  (interactive)
  (let ((U 0)   ; untracked files
        (M 0)   ; modified files
        (O 0)   ; other files
        (U-files "")
        (M-files "")
        (O-files ""))
    (dolist (line (split-string
                   (shell-command-to-string "git status --porcelain")
                   "\n"))
      (cond

       ;; ignore empty line at end
       ((string= "" line) nil)

       ((string-match "^\\?\\?" line)
        (setq U (+ 1 U))
        (setq U-files (concat U-files "\n" line)))

       ((string-match "^ M" line)
        (setq M (+ 1 M))
        (setq M-files (concat M-files "\n" line)))))

    ;; construct propertized string
    (concat
     "Git["
     (propertize
      (format "M:%d" M)
      'face (if (> M 0)
                'error
              'success)
      'help-echo M-files)
     " "
     (propertize
      (format "?:%d" U)
      'face (if (> U 0)
                'warning
              'success)
      'help-echo U-files)
     "]")))

(setq-default
 mode-line-format
 '("  "
   (:eval (let ((icon (all-the-icons-icon-for-mode major-mode)))
	    (propertize
	     icon
	     'face
	     (plist-put
	      (get-text-property 0 'face icon)
	      :height 1.0)
	     'font-lock-face
	     (plist-put
	      (get-text-property 0 'font-lock-face icon)
	      :height 1.0)
	     'display
	     '(raise 0))))
   "  "
   (:eval (let ((str (if buffer-read-only
                         (if (buffer-modified-p) "%%*" "%%%%")
                       (if (buffer-modified-p) "**" "--"))))
            (if buffer-read-only
                (propertize str 'face 'modeline-read-only-face)
              (if (buffer-modified-p)
                  (propertize str 'face 'modeline-modified-face)
                str))))
   (list 'line-number-mode "  ")
   (:eval (when line-number-mode
            (let ((str "L%l"))
              (if (/= (buffer-size) (- (point-max) (point-min)))
                  (propertize str 'face 'modeline-narrow-face)
                str))))
   "  %p"
   (list 'column-number-mode "  C%c")
   "  " mode-line-buffer-identification
   "  " mode-line-modes
   (:eval (when (bound-and-true-p flymake-mode) flymake-mode-line-format))
   "  "
   (:eval (cory/mode-line-git-parse-status))))

(use-package moody
  :custom
  ;; (moody-mode-line-height (* (aref (font-info (face-font 'mode-line)) 2) 1.5))
  ;; (moody-mode-line-height 40)
  (moody-mode-line-height 30)
  :config
  (setq x-underline-at-descent-line t)
  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode)
  (moody-replace-eldoc-minibuffer-message-function))

(use-package minions
  :config (minions-mode))

;; (defvar +smart-file-name-cache nil)

;; (defun +shorten-long-path (path)
;;   (let ((paths (split-string path "/")))
;;     (if (< (length paths) 3)
;;         path
;;       (string-join (reverse (let ((rpaths (reverse paths)))
;;                               (-concat
;;                                (-take 2 rpaths)
;;                                (->> (-drop 2 rpaths)
;;                                   (--map (if (> (length it) 1)
;;                                              (substring it 0 1)
;;                                            it))))))
;;                    "/"))))

;; (defun +smart-file-name ()
;;   "Get current file name, if we are in project, the return relative path to the project root, otherwise return absolute file path.
;; This function is slow, so we have to use cache."
;;   (let ((vc-dir (vc-root-dir))
;;         (bfn (buffer-file-name (current-buffer))))
;;     (cond
;;      ((and bfn vc-dir)
;;       (+shorten-long-path (file-relative-name bfn vc-dir)))
;;      (bfn bfn)
;;      (t (buffer-name)))))

;; (defun +smart-file-name-cached ()
;;   (if (eq (buffer-name) (car +smart-file-name-cache))
;;       (cdr +smart-file-name-cache)
;;     (let ((file-name (+smart-file-name)))
;;       (setq +smart-file-name-cache
;;             (cons (buffer-name) file-name))
;;       file-name)))

;; (defun +format-mode-line ()
;;   (let* ((lhs '((:eval (when (bound-and-true-p meow-mode) (meow-indicator)))
;; 		(:eval " L%l C%C")
;; 		(:eval (when (bound-and-true-p flymake-mode) flymake-mode-line-format))))
;;          (rhs '((:eval (+smart-file-name-cached))
;;                 " "
;;                 (:eval mode-name)))
;;          (ww (window-width))
;;          (lhs-str (format-mode-line lhs))
;;          (rhs-str (format-mode-line rhs))
;;          (rhs-w (string-width rhs-str)))
;;     (format "%s%s%s"
;;             lhs-str
;;             (propertize " " 'display `((space :align-to (- (+ right right-fringe right-margin) (+ 1 ,rhs-w)))))
;;             rhs-str)))

;; (setq-default mode-line-format '((:eval (+format-mode-line))))
;; (setq-default header-line-format nil)
#+end_src

** functions

#+begin_src emacs-lisp :tangle yes

#+end_src

* Completion

** completion

#+begin_src emacs-lisp :tangle yes
;;
;; --- DEFAULT COMPLETION ---
;;

(use-package vertico
  :config
  (recentf-mode t)
  (vertico-mode t))

(use-package vertico-posframe
  :after vertico
  :config (vertico-posframe-mode 1))

;; Configure directory extension.
(use-package vertico-directory
  :after vertico
  :ensure nil
  ;; More convenient directory navigation commands
  :bind (:map vertico-map
         ("RET" . vertico-directory-enter)
         ("DEL" . vertico-directory-delete-char)
         ("M-DEL" . vertico-directory-delete-word))
  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

;; Icons in minibuffer
(use-package all-the-icons-completion
  :disabled t
  :config
  (all-the-icons-completion-mode)
  (add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))

;; Completion matching
(use-package orderless
  :ensure t
  :custom
  ;; (completion-styles '(orderless basic))
  (completion-styles '(orderless flex))
  (completion-category-overrides '((file (styles basic partial-completion))))
  (orderless-component-separator "[ \\]"))

;; Minibuffer visual menu
(use-package consult
  :init
  (setq consult-preview-key nil)
  :bind
  (("C-c f"       . consult-recent-file)
   ("C-x p s"     . consult-ripgrep) ; for use with project.el
   ;; ;; ("C-s"         . consult-line)
   ;; ("C-s"         . consult-line-multi)
   ;; ("C-S-s"       . consult-focus-lines)
   ;; ("C-c i"       . consult-imenu)
   ;; ("C-c t"       . gtags-find-tag)
   ("C-x b"       . consult-buffer)
   ;; ("C-c x"       . consult-complex-command)
   ;; ("C-c e"       . consult-flymake)

   ("C-x C-k C-k" . consult-kmacro)
   ("M-y"         . consult-yank-pop)
   ("M-g g"       . consult-goto-line)
   ("M-g M-g"     . consult-goto-line)
   ("M-g f"       . consult-flymake)
   ("M-g i"       . consult-imenu)
   ("M-s o"       . consult-line)
   ;; ("M-s L"       . consult-line-multi)
   ("M-s u"       . consult-focus-lines)
   ("M-s g"       . consult-grep)
   ("M-s M-g"     . consult-grep)
   ("C-x C-SPC"   . consult-global-mark)
   ("C-x M-:"     . consult-complex-command)
   ;; ("C-c n"       . consult-org-agenda)
   :map comint-mode-map
   ("C-c h" . consult-history)
   :map dired-mode-map
   ("O" . consult-file-externally)
   :map help-map
   ("a" . consult-apropos)
   :map minibuffer-local-map
   ("M-r" . consult-history))
  :custom
  (completion-in-region-function #'consult-completion-in-region))

(use-package consult-eglot
  :after consult eglot
  ;; :bind (:map eglot-mode-map
  ;; 	 ("C-M-." . consult-eglot-symbols))
  ;; FIXME bind isn't binding
  :config
  (define-key eglot-mode-map [remap xref-find-apropos] 'consult-eglot-symbols))

(use-package marginalia
  :after vertico
  :ensure t
  :config
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  (marginalia-mode))

;;
;; --- EXPANSION ---
;;

(use-package hippie-exp
  :ensure nil
  :bind
  ([remap dabbrev-expand] . hippie-expand)
  :commands (hippie-expand)
  :config
  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol
          try-complete-file-name-partially
          try-complete-file-name
          try-expand-all-abbrevs
          try-expand-list
          try-expand-line)))

;;
;; --- CODE COMPLETION ---
;;

(use-package corfu
  :ensure t
  :custom
  (corfu-cycle t)                  ; Allows cycling through candidates
  (corfu-auto t)                   ; Enable auto completion
  (corfu-auto-prefix 1)            ; Enable auto completion
  (corfu-auto-delay 0.0)           ; Enable auto completion
  (corfu-quit-at-boundary t)
  (corfu-echo-documentation t)     ; Enable auto documentation in the minibuffer
  ;; (corfu-preview-current 'insert)  ; Insert preview of candidate when selected
  ;; (corfu-preselect-first nil)
  (corfu-preview-current nil)
  (corfu-preselect-first t)
  (corfu-popupinfo-max-width 60)
  (corfu-popupinfo-max-height 30)
  (corfu-popupinfo-delay nil)

  :init
  ;; Need to recreate the map in order to preserve movement keys
  ;; Don't touch my movement keys!!
  ;; TAB cycles through completion options
  (setq corfu-map
	(let ((map (make-sparse-keymap)))
	  (define-key map [remap completion-at-point] #'corfu-complete)
	  (define-key map [remap keyboard-escape-quit] #'corfu-quit)
	  (define-key map (kbd "C-g") #'corfu-quit)
	  (define-key map [down] #'corfu-next)
	  (define-key map [up] #'corfu-previous)
	  (define-key map [tab] #'corfu-next)
	  (define-key map [backtab] #'corfu-previous)
	  (define-key map (kbd "TAB") #'corfu-next)
	  (define-key map (kbd "S-TAB") #'corfu-previous)
	  ;; (define-key map [(shift return)] #'corfu-insert)
	  ;; (define-key map (kbd "S-<return>") #'corfu-insert)
	  (define-key map [return] #'corfu-insert)
	  (define-key map (kbd "<return>") #'corfu-insert)
	  (define-key map (kbd "M-l") #'corfu-info-location)
	  (define-key map (kbd "M-SPC") #'corfu-insert-separator)
	  ;; (define-key map [space] #'cory/corfu-insert-with-space)
	  ;; (define-key map (kbd "SPC") #'cory/corfu-insert-with-space)
	  map))

  (global-corfu-mode)
  (corfu-history-mode)
  (corfu-popupinfo-mode)

  :config
  ;; FIXME fix popupinfo font size
  ;; (set-face-attribute 'corfu-popupinfo nil
  ;; 		      :inherit 'corfu-default)
  ;; (copy-face 'corfu-default 'corfu-popupinfo)

  ;; (defun cory/corfu-insert-with-space ()
  ;;   (interactive)
  ;;   (if (>= corfu--index 0)
  ;; 	(corfu--insert 'finished)
  ;;     (corfu-quit))
  ;;   (insert ? ))
  )

;; Completion at point extensions
(use-package cape
  :ensure t
  :custom
  (cape-dict-file "~/.local/share/dict/words")
  ;; :bind
  ;; (("C-c p i" . cape-ispell)
  ;;  ("C-c p w" . cape-dict)
  ;;  ("C-c p d" . cape-dabbrev)
  ;;  ("C-c p l" . cape-line))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)

  :config
  ;; (setq-local completion-at-point-functions
  ;;             (list (cape-super-capf #'cape-dabbrev #'cape-dict #'cape-keyword #'cape-symbol)))

  ;; Add dictionary just to text modes
  (add-hook 'text-mode-hook (lambda ()
			      (setq-local completion-at-point-functions
			                  (cons #'cape-dict
						completion-at-point-functions))))

  ;; Silence then pcomplete capf, no errors or messages!
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

  ;; Ensure that pcomplete does not write to the buffer
  ;; and behaves as a pure `completion-at-point-function'.
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))

;; Icons for corfu
;; (use-package kind-icon
;;   :ensure t
;;   :after corfu
;;   :custom
;;   (kind-icon-use-icons t) ; Use icons labels
;;   (kind-icon-default-face 'corfu-default)
;;   :config
;;   (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

(defvar kind-all-the-icons--cache nil
  "The cache of styled and padded label (text or icon).
An alist.")

(defun kind-all-the-icons-reset-cache ()
  "Remove all cached icons from `kind-all-the-icons-mapping'."
  (interactive)
  (setq kind-all-the-icons--cache nil))

(defun kind-all-the-icons--set-default-clear-cache (&rest args)
  (kind-all-the-icons-reset-cache)
  (apply #'set-default args))

(defvar kind-all-the-icons--icons
  `((unknown . ,(all-the-icons-material "find_in_page" :height 0.8 :v-adjust -0.15))
    (text . ,(all-the-icons-faicon "text-width" :height 0.8 :v-adjust -0.02))
    (method . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
    (function . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
    (fun . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
    (constructor . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
    (ctor . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
    (field . ,(all-the-icons-octicon "tag" :height 0.85 :v-adjust 0 :face 'all-the-icons-lblue))
    (variable . ,(all-the-icons-octicon "tag" :height 0.85 :v-adjust 0 :face 'all-the-icons-lblue))
    (var . ,(all-the-icons-octicon "tag" :height 0.85 :v-adjust 0 :face 'all-the-icons-lblue))
    (class . ,(all-the-icons-material "settings_input_component" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-orange))
    (interface . ,(all-the-icons-material "share" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
    (i/f . ,(all-the-icons-material "share" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
    (module . ,(all-the-icons-material "view_module" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
    (mod . ,(all-the-icons-material "view_module" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
    (property . ,(all-the-icons-faicon "wrench" :height 0.8 :v-adjust -0.02))
    (prop . ,(all-the-icons-faicon "wrench" :height 0.8 :v-adjust -0.02))
    (unit . ,(all-the-icons-material "settings_system_daydream" :height 0.8 :v-adjust -0.15))
    (value . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
    (enum . ,(all-the-icons-material "storage" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-orange))
    (keyword . ,(all-the-icons-material "filter_center_focus" :height 0.8 :v-adjust -0.15))
    (k/w . ,(all-the-icons-material "filter_center_focus" :height 0.8 :v-adjust -0.15))
    (snippet . ,(all-the-icons-material "format_align_center" :height 0.8 :v-adjust -0.15))
    (sn . ,(all-the-icons-material "format_align_center" :height 0.8 :v-adjust -0.15))
    (color . ,(all-the-icons-material "palette" :height 0.8 :v-adjust -0.15))
    (file . ,(all-the-icons-faicon "file-o" :height 0.8 :v-adjust -0.02))
    (reference . ,(all-the-icons-material "collections_bookmark" :height 0.8 :v-adjust -0.15))
    (ref . ,(all-the-icons-material "collections_bookmark" :height 0.8 :v-adjust -0.15))
    (folder . ,(all-the-icons-faicon "folder-open" :height 0.8 :v-adjust -0.02))
    (dir . ,(all-the-icons-faicon "folder-open" :height 0.8 :v-adjust -0.02))
    (enum-member . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15))
    (enummember . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15))
    (member . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15))
    (constant . ,(all-the-icons-faicon "square-o" :height 0.8 :v-adjust -0.1))
    (const . ,(all-the-icons-faicon "square-o" :height 0.8 :v-adjust -0.1))
    (struct . ,(all-the-icons-material "settings_input_component" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-orange))
    (event . ,(all-the-icons-octicon "zap" :height 0.8 :v-adjust 0 :face 'all-the-icons-orange))
    (operator . ,(all-the-icons-material "control_point" :height 0.8 :v-adjust -0.15))
    (op . ,(all-the-icons-material "control_point" :height 0.8 :v-adjust -0.15))
    (type-parameter . ,(all-the-icons-faicon "arrows" :height 0.8 :v-adjust -0.02))
    (param . ,(all-the-icons-faicon "arrows" :height 0.8 :v-adjust -0.02))
    (template . ,(all-the-icons-material "format_align_left" :height 0.8 :v-adjust -0.15))
    (t . ,(all-the-icons-material "find_in_page" :height 0.8 :v-adjust -0.15))))


(defsubst kind-all-the-icons--metadata-get (metadata type-name)
  (or
   (plist-get completion-extra-properties (intern (format ":%s" type-name)))
   (cdr (assq (intern type-name) metadata))))

(defun kind-all-the-icons-formatted (kind)
  "Format icon kind with all-the-icons"
  (or (alist-get kind kind-all-the-icons--cache)
     (let ((map (assq kind kind-all-the-icons--icons)))
       (let*  ((icon (if map
                         (cdr map)
                       (cdr (assq t kind-all-the-icons--icons))))
               (half (/ (default-font-width) 2))
               (pad (propertize " " 'display `(space :width (,half))))
               (disp (concat pad icon pad)))
         (setf (alist-get kind kind-all-the-icons--cache) disp)
         disp))))

(defun kind-all-the-icons-margin-formatter (metadata)
  "Return a margin-formatter function which produces kind icons.
METADATA is the completion metadata supplied by the caller (see
info node `(elisp)Programmed Completion').  To use, add this
function to the relevant margin-formatters list."
  (if-let ((kind-func (kind-all-the-icons--metadata-get metadata "company-kind")))
      (lambda (cand)
	(if-let ((kind (funcall kind-func cand)))
	    (kind-all-the-icons-formatted kind)
	  (kind-all-the-icons-formatted t))))) ;; as a backup

(add-to-list 'corfu-margin-formatters
	     #'kind-all-the-icons-margin-formatter)
#+end_src

* IDE Stuff

** lsp

#+begin_src emacs-lisp :tangle yes
;; LSP
(use-package eglot
  :after flymake corfu
  :defer t
  :ensure t

  :hook
  ;; (nix-mode . eglot-ensure)
  (c-mode . eglot-ensure)
  (c++-mode . eglot-ensure)
  (racket-mode . eglot-ensure)
  (clojure-mode . eglot-ensure)
  (clojurescript-mode . eglot-ensure)
  (clojurec-mode . eglot-ensure)
  ;; (scheme-mode . eglot-ensure)
  (java-mode . eglot-ensure)
  (python-mode . eglot-ensure)
  (eglot-managed-mode . eglot-super-capf)

  :custom
  (eglot-autoshutdown t)
  (eglot-autoreconnect nil)
  (eglot-confirm-server-initiated-edits nil)
  (eldoc-idle-delay 1)
  (eldoc-echo-area-display-truncation-message nil)
  (eldoc-echo-area-use-multiline-p 2)

  :config
  (define-key eglot-mode-map [remap display-local-help] nil)
  ;; (add-to-list 'eglot-server-programs
  ;;              `(scheme-mode . ("chicken-lsp-server")))
  (add-to-list 'eglot-server-programs
	       `(clojure-mode . ("clojure-lsp")))
  ;; (add-to-list 'eglot-server-programs
  ;;              `(nix-mode . ("nil")))

  (defun eglot-super-capf ()
    (setq-local completion-at-point-functions
		(list (cape-super-capf
		       #'tempel-complete
		       #'eglot-completion-at-point)
		      #'cape-dabbrev
		      #'cape-file)))

  :bind (:map eglot-mode-map
	 ("C-c C-a" . eglot-code-actions)
	 ("C-c C-f" . eglot-format-buffer)
	 ("C-c x"   . eglot-rename)))

;; Tree-sitter
;; (use-package tree-sitter
;;   :hook
;;   (c-mode . tree-sitter-setup)
;;   (c++-mode . tree-sitter-setup)
;;   (java-mode . tree-sitter-setup)

;;   :config
;;   (defun tree-sitter-setup ()
;;     (require 'tree-sitter)
;;     (require 'tree-sitter-langs)
;;     (require 'tree-sitter-hl)
;;     (tree-sitter-hl-mode)))

;; (use-package tree-sitter-langs)
#+end_src

** checking

#+begin_src emacs-lisp :tangle yes
;; Syntax checking
(use-package flymake
  :ensure t
  :hook
  (prog-mode . flymake-mode)
  :bind
  (:map flymake-mode-map
   ("M-n"     . flymake-goto-next-error)
   ("M-p"     . flymake-goto-prev-error)
   ("M-g n"   . flymake-goto-next-error)
   ("M-g p"   . flymake-goto-prev-error)
   ("M-g M-n" . flymake-goto-next-error)
   ("M-g M-p" . flymake-goto-prev-error)
   ("M-g d"   . flymake-show-buffer-diagnostics)
   ("M-g M-d" . flymake-show-project-diagnostics))

  :init
  ;; Disable legacy diagnostic functions as some have bugs (mainly haskell)
  (setq flymake-proc-ignored-file-name-regexps '("\\.l?hs\\'"))
  (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake)

  :config
  (define-fringe-bitmap 'cory-info-mark
    (vector #b0000001111000000
	    #b0000111111110000
	    #b0001110000111000
	    #b0011000000001100
	    #b0110000000000110
	    #b0110000000000110
	    #b1100000000000011
	    #b1100000000000011
	    #b1100000000000011
	    #b1100000000000011
	    #b0110000000000110
	    #b0110000000000110
	    #b0011000000001100
	    #b0001100000011000
	    #b0000110000110000
	    #b0000110000110000
	    #b0000111111110000
	    #b0000011111100000
	    #b0000000000000000
	    #b0000000000000000
	    #b0000011111100000
	    #b0000011111100000
	    #b0000001111000000
	    #b0000001111000000)
    23
    16
    'center)

  (define-fringe-bitmap 'cory-warning-mark
    (vector #b0000000110000000
	    #b0000000110000000
	    #b0000001111000000
	    #b0000001111000000
	    #b0000011001100000
	    #b0000011001100000
	    #b0000110000110000
	    #b0000110110110000
	    #b0001100110011000
	    #b0001100110011000
	    #b0011000110001100
	    #b0011000000001100
	    #b0110000110000110
	    #b0110000110000110
	    #b1100000000000011
	    #b1111111111111111)
    16
    16
    'center)

  (define-fringe-bitmap 'cory-error-mark
    (vector #b0011000000001100
	    #b0111100000011110
	    #b1100110000110011
	    #b1100011001100011
	    #b0110001111000110
	    #b0011000110001100
	    #b0001100000011000
	    #b0000110000110000
	    #b0000110000110000
	    #b0001100000011000
	    #b0011000110001100
	    #b0110001111000110
	    #b1100011001100011
	    #b1100110000110011
	    #b0111100000011110
	    #b0011000000001100)
    16
    16
    'center)

  (setq ;; flymake-fringe-indicator-position 'right-fringe
   flymake-note-bitmap '(cory-info-mark compilation-info)
   flymake-warning-bitmap '(cory-warning-mark compilation-warning)
   flymake-error-bitmap '(cory-error-mark compilation-error)))

(use-package flymake-diagnostic-at-point
  :ensure t
  :after flymake
  :config
  (setq flymake-diagnostic-at-point-error-prefix nil)
  (add-hook 'flymake-mode-hook #'flymake-diagnostic-at-point-mode))

(use-package flymake-racket
  :ensure t
  :commands (flymake-racket-add-hook)
  :init
  (add-hook 'racket-mode-hook #'flymake-racket-add-hook))

(use-package flymake-kondor
  :ensure t
  :hook
  (clojure-mode . flymake-kondor-setup)
  (clojurescript-mode . flymake-kondor-setup)
  (clojurec-mode . flymake-kondor-setup))

;; (use-package flymake-joker
;;   :config
;;   (add-hook 'clojure-mode-hook #'flymake-joker-clj-enable)
;;   (add-hook 'clojurescript-mode-hook #'flymake-joker-cljs-enable)
;;   (add-hook 'clojure-mode-hook #'flymake-mode))

;; Display help messages automatically in echo area
(setq help-at-pt-timer-delay 0.1)
(setq help-at-pt-display-when-idle '(flymake-diagnostic))
#+end_src

** formatting

#+begin_src emacs-lisp :tangle yes
;; Automatically remove trailing whitespace if user put it there
(use-package ws-butler
  :hook ((text-mode prog-mode) . ws-butler-mode)
  :config (setq ws-butler-keep-whitespace-before-point nil))

;; Indenting
(use-package aggressive-indent
  :config
  (electric-indent-mode 0)
  (global-aggressive-indent-mode 1)
  (add-to-list 'aggressive-indent-excluded-modes 'html-mode))

;; Word wrapping
(global-visual-line-mode 1)
(setq-default fill-column 80)
;; (add-hook 'text-mode-hook #'turn-on-auto-fill)

;; Turn ^L into pretty lines
(use-package page-break-lines
  :ensure t
  :defer t
  :hook (after-init . global-page-break-lines-mode))

;; Rainbow delimiters
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

;; Show empty whitespace
(setq whitespace-style '(face trailing tabs lines empty))
(add-hook 'prog-mode-hook 'whitespace-mode)

;; Highlight and navigate TODO keywords
(use-package hl-todo
  :config (global-hl-todo-mode))
#+end_src

** editing

#+begin_src emacs-lisp :tangle yes
;; Undo
(use-package undo-tree
  :defer 1
  :diminish undo-tree-mode
  :bind
  (:map undo-tree-map
   ("C-x u"   . undo-tree-visualize)
   ("C-/"     . undo-tree-undo)
   ("C-x C-u" . undo-tree-visualize-redo)
   ("C-?"     . undo-tree-redo))
  :custom
  (undo-tree-visualizer-timestamps t)
  (undo-tree-visualizer-relative-timestamps t)
  (undo-tree-visualizer-diff t)
  (undo-tree-enable-undo-in-region t)
  (undo-tree-history-directory-alist
   `(("." . ,(expand-file-name
	      (concat user-emacs-directory "undo")))))
  :init
  (global-undo-tree-mode))

(use-package embark
  :ensure t
  :bind
  (("<C-i>" . embark-act) ; pick some comfortable binding
   ([remap describe-bindings] . embark-bindings)
   :map embark-file-map
   ("C-d" . dragon-drop))
  :custom
  (embark-indicators
   '(embark-highlight-indicator
     embark-isearch-highlight-indicator
     embark-minimal-indicator))
  (embark-quit-after-action nil)
  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)
  (setq embark-prompter 'embark-completing-read-prompter)
  :config
  (defun search-in-source-graph (text))
  (defun dragon-drop (file)
    (start-process-shell-command "dragon-drop" nil
				 (concat "dragon-drag-and-drop " file))))

(use-package embark-consult
  :ensure t
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))

(use-package crux
  :bind (([(control return)] . crux-smart-open-line)
         ([(control shift return)] . crux-smart-open-line-above)
	 ("C-c u" . crux-view-url)
	 ;; ("C-c e" . crux-eval-and-replace)
	 ("C-x 4 t" . crux-transpose-windows)
	 ("C-c d" . crux-duplicate-current-line-or-region)
	 ("C-c D" . crux-duplicate-and-comment-current-line-or-region)
	 ;; ("C-c k" . crux-kill-other-buffers)
	 ("C-^" . crux-top-join-line)
	 ("C-k" . crux-kill-and-join-forward-2)
	 ([remap kill-whole-line]. crux-kill-whole-line)
         ("C-a"   . crux-move-beginning-of-line))
  :config
  ;; TODO need to detect when the point is at the beginning of indentation
  (defun crux-kill-and-join-backward ()
    (interactive)
    (if (and (save-mark-and-excursion
	    (let ((orig-point (point)))
	      (move-beginning-of-line 1)
	      (while (looking-at "[[:space:]\t]")
		(forward-char 1))
	      (= orig-point (point))))
	  (not (eolp)))
	(delete-indentation)
      (kill-line 0)
      (indent-according-to-mode)))

  (defun crux-kill-and-join-forward-2 (&optional arg)
    "If ARG is given, kill backwards. Otherwise kill forwards."
    (interactive "P")
    (if (not arg)
	(crux-kill-and-join-forward)
      (crux-kill-and-join-backward))))

;; better comment-dwim
(use-package comment-dwim-2
  :bind ("M-;" . comment-dwim-2))

;; Smartparens
(use-package smartparens
  :defer 1
  :hook ((
          emacs-lisp-mode lisp-mode lisp-data-mode clojure-mode cider-repl-mode
	  racket-mode racket-repl-mode scheme-mode geiser-repl-mode json-mode
          ) . smartparens-strict-mode)
  :bind (:map smartparens-mode-map
         ;; This is the paredit mode map minus a few key bindings
         ;; that I use in other modes (e.g. M-?)
         ("C-M-f" . sp-forward-sexp) ;; navigation
         ("C-M-b" . sp-backward-sexp)
         ("C-M-u" . sp-backward-up-sexp)
         ("C-M-d" . sp-down-sexp)
         ("C-M-p" . sp-backward-down-sexp)
         ("C-M-n" . sp-up-sexp)
         ("M-S" . sp-splice-sexp) ;; depth-changing commands
         ("M-R" . sp-splice-sexp-killing-around)
         ("M-(" . sp-wrap-round)
         ("C-)" . sp-forward-slurp-sexp) ;; barf/slurp
         ("M-<right>" . sp-forward-slurp-sexp)
         ("C-}" . sp-forward-barf-sexp)
         ("M-<left>" . sp-forward-barf-sexp)
         ("C-(" . sp-backward-slurp-sexp)
         ("M-S-<left>" . sp-backward-slurp-sexp)
         ("C-{" . sp-backward-barf-sexp)
         ("M-S-<right>" . sp-backward-barf-sexp)
         ("M-S" . sp-split-sexp) ;; misc
         ("M-j" . sp-join-sexp)
	 )
  :config
  (require 'smartparens-config)
  (setq sp-base-key-bindings 'paredit)
  (setq sp-autoskip-closing-pair 'always)

  ;; Don't insert annoying colon after Python def
  (setq sp-python-insert-colon-in-function-definitions nil)

  ;; Always highlight matching parens
  (show-smartparens-global-mode +1)

  ;; Blink matching parens
  (setq blink-matching-paren t)

  (defun whole-line-or-region-sp-kill-region (prefix)
    "Call `sp-kill-region' on region or PREFIX whole lines."
    (interactive "*p")
    (whole-line-or-region-wrap-beg-end 'sp-kill-region prefix))

  ;; Create keybindings to wrap symbol/region in pairs
  (defun prelude-wrap-with (s)
    "Create a wrapper function for smartparens using S."
    `(lambda (&optional arg)
       (interactive "P")
       (sp-wrap-with-pair ,s)))
  (define-key prog-mode-map (kbd "M-(") (prelude-wrap-with "("))
  (define-key prog-mode-map (kbd "M-[") (prelude-wrap-with "["))
  (define-key prog-mode-map (kbd "M-{") (prelude-wrap-with "{"))
  (define-key prog-mode-map (kbd "M-\"") (prelude-wrap-with "\""))
  (define-key prog-mode-map (kbd "M-'") (prelude-wrap-with "'"))
  (define-key prog-mode-map (kbd "M-`") (prelude-wrap-with "`"))

  ;; smart curly braces
  (sp-pair "{" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))
  (sp-pair "[" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))
  (sp-pair "(" nil :post-handlers
           '(((lambda (&rest _ignored)
                (crux-smart-open-line-above)) "RET")))

  ;; Don't include semicolon ; when slurping
  (add-to-list 'sp-sexp-suffix '(java-mode regexp ""))
  (add-to-list 'sp-sexp-suffix '(c-mode regexp ""))
  (add-to-list 'sp-sexp-suffix '(c++-mode regexp ""))
  (add-to-list 'sp-sexp-suffix '(nix-mode regexp ""))

  ;; use smartparens-mode everywhere
  (smartparens-global-mode))

;; Smart-region: Smart region selection
;; Smart region guesses what you want to select by one command:
;; - If you call this command multiple times at the same position,
;;   it expands the selected region (with `er/expand-region’).
;; - Else, if you move from the mark and call this command,
;;   it selects the region rectangular (with `rectangle-mark-mode’).
;; - Else, if you move from the mark and call this command at the same column as
;;   mark, it adds a cursor to each line (with `mc/edit-lines’).

(use-package expand-region
  :defer t)

(use-package smart-region
  ;; C-SPC is smart-region
  :bind (([remap set-mark-command] . smart-region)))

;; Personal custom multi-edit package
;; Very similar to meow's beacon-mode
(use-package macrursors
  :custom
  (macrursors-preapply-command
   (lambda ()
     (corfu-mode -1)
     (goggles-mode -1)
     (beacon-mode -1)))
  (macrursors-postapply-command
   (lambda ()
     (corfu-mode 1)
     (goggles-mode 1)
     (beacon-mode 1)))
  :config
  (define-prefix-command 'macrursors-mark-map)
  (global-set-key (kbd "C-;") 'macrursors-mark-map)
  (define-key macrursors-mark-map (kbd "C-;") #'macrursors-mark-all-instances-of)
  (define-key macrursors-mark-map (kbd ";") #'macrursors-mark-all-instances-of)
  (define-key macrursors-mark-map (kbd "l") #'macrursors-mark-all-lists)
  (define-key macrursors-mark-map (kbd "s") #'macrursors-mark-all-symbols)
  (define-key macrursors-mark-map (kbd "e") #'macrursors-mark-all-sexps)
  (define-key macrursors-mark-map (kbd "f") #'macrursors-mark-all-defuns)
  (define-key macrursors-mark-map (kbd "n") #'macrursors-mark-all-numbers)
  (define-key macrursors-mark-map (kbd ".") #'macrursors-mark-all-sentences)
  (define-key macrursors-mark-map (kbd "r") #'macrursors-mark-all-lines))


;; Multiple cursors
;; (use-package multiple-cursors
;;   :bind (;; ("C-c m" . mc/mark-all-dwim)
;; 	 ("C-c m" . mc/mark-all-like-this)
;;          ("C->" . mc/mark-next-like-this)
;;          ("C-<" . mc/mark-previous-like-this)
;; 	 ("C-M-<" . mc/mark-all-in-region-regexp)
;; 	 ("C-M->" . mc/edit-lines)
;;          :map mc/keymap
;;          ("C-x v" . mc/vertical-align-with-space)
;;          ("C-x n" . mc-hide-unmatched-lines-mode))
;;   :custom
;;   (mc/always-run-for-all t)
;;   :config
;;   (global-unset-key (kbd "M-<down-mouse-1>"))
;;   (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)

;;   (with-eval-after-load 'multiple-cursors-core
;;     ;; Immediately load mc list
;;     (mc/load-lists)
;;     ;; Define keys
;;     (define-key mc/keymap (kbd "M-T") 'mc/reverse-regions)
;;     (define-key mc/keymap (kbd "C-,") 'mc/unmark-next-like-this)
;;     (define-key mc/keymap (kbd "C-.") 'mc/skip-to-next-like-this)
;;     (define-key mc/keymap (kbd "<return>") nil))

;;   (setq mc/max-cursors 201)
;;   (defun mc/create-fake-cursor-at-point (&optional id)
;;     "Overriding mc/create-fake-cursor-at-point to save hidden cursors"
;;     (unless mc--max-cursors-original
;;       (setq mc--max-cursors-original mc/max-cursors))
;;     (if mc/max-cursors
;; 	(if (< (mc/num-cursors) mc/max-cursors)
;;             (let ((overlay (mc/make-cursor-overlay-at-point)))
;; 	      (overlay-put overlay 'mc-id (or id (mc/create-cursor-id)))
;; 	      (overlay-put overlay 'type 'fake-cursor)
;; 	      (overlay-put overlay 'priority 100)
;; 	      (mc/store-current-state-in-overlay overlay)
;; 	      (when (use-region-p)
;; 		(overlay-put overlay 'region-overlay
;;                              (mc/make-region-overlay-between-point-and-mark)))
;; 	      overlay)
;;           (if (use-region-p)
;; 	      (progn (setq-local cory/mc-hidden-cursors (cons (cons (point-marker) (copy-marker (mark-marker))) cory/mc-hidden-cursors)))
;;             (setq-local cory/mc-hidden-cursors (cons (cons (point-marker) (point-marker)) cory/mc-hidden-cursors))))
;;       (let ((overlay (mc/make-cursor-overlay-at-point)))
;; 	(overlay-put overlay 'mc-id (or id (mc/create-cursor-id)))
;; 	(overlay-put overlay 'type 'fake-cursor)
;; 	(overlay-put overlay 'priority 100)
;; 	(mc/store-current-state-in-overlay overlay)
;; 	(when (use-region-p)
;;           (overlay-put overlay 'region-overlay
;; 		       (mc/make-region-overlay-between-point-and-mark)))
;; 	overlay)))


;;   (defun mc--maybe-set-killed-rectangle ()
;;     "There are some bugs regarding saving to kill ring for
;;  rectangle editing, but I don't use it, so just ignore it")

;;   (defun cory/apply-macro-for-the-next-hidden-cursor ()
;;     "Apply kmacro to the next hidden cursor"
;;     (interactive)
;;     (let* ((next-cursor (car cory/mc-hidden-cursors))
;;            (p (car next-cursor))
;;            (m (cdr next-cursor)))
;;       (if (not (= p m))
;;           (progn
;;             (push-mark m t nil)
;;             (goto-char p)
;;             (activate-mark))
;; 	(goto-char p))
;;       (call-last-kbd-macro)
;;       (setq-local cory/mc-hidden-cursors (cdr cory/mc-hidden-cursors))))

;;   (defun mc/remove-cursor-at-point-if-exist ()
;;     "Remove cursors at point, either fake or real."
;;     (interactive)
;;     (let ((removed nil))
;;       (cl-loop for cursor in (mc/all-fake-cursors)
;;                for start = (overlay-start cursor)
;;                do (when (= start (point))
;; 		    (mc/remove-fake-cursor cursor)
;; 		    (setq-local removed t)))
;;       removed))

;;   (defun cory/mc-remove-current-cursor ()
;;     "blabla"
;;     (interactive)
;;     (let ((old-point (point)))
;;       (when (not (call-interactively 'mc/remove-cursor-at-point-if-exist))
;; 	(if (mc/last-fake-cursor-before (point))
;;             (call-interactively 'mc/cycle-backward)
;;           (call-interactively 'mc/cycle-forward))
;; 	(setq-local new-point (point))
;; 	(goto-char old-point)
;; 	(call-interactively 'mc/remove-cursor-at-point-if-exist)
;; 	(goto-char new-point))))

;;   (defun cory/apply-macro-for-all-hidden-cursors ()
;;     "Apply kmacro to all hidden cursors"
;;     (interactive)
;;     (while cory/mc-hidden-cursors
;;       (let* ((next-cursor (car cory/mc-hidden-cursors))
;;              (p (car next-cursor))
;;              (m (cdr next-cursor)))
;; 	(if (not (= p m))
;;             (progn
;; 	      (push-mark m t t)
;; 	      (goto-char p))
;;           (goto-char p))
;; 	(call-last-kbd-macro)
;; 	(setq-local cory/mc-hidden-cursors (cdr cory/mc-hidden-cursors)))))

;;   (defun mc/mark-all-like-this ()
;;     "example: override mc/mark-all-like-this to make it work with hidden cursors"
;;     (interactive)
;;     (unless (region-active-p)
;;       (error "Mark a region to match first."))
;;     (mc/remove-fake-cursors)
;;     (setq-local cory/mc-hidden-cursors nil)
;;     (let ((master (point))
;;           (case-fold-search nil)
;;           (point-first (< (point) (mark)))
;;           (re (regexp-opt (mc/region-strings) mc/enclose-search-term)))
;;       (mc/save-excursion
;;        (goto-char 0)
;;        (while (search-forward-regexp re nil t)
;; 	 (push-mark (match-beginning 0))
;; 	 (when point-first (exchange-point-and-mark))
;; 	 (unless (and (= master (point)))
;;            (mc/create-fake-cursor-at-point))
;; 	 (when point-first (exchange-point-and-mark)))))
;;     (if (> (mc/num-cursors) 1)
;; 	(multiple-cursors-mode 1)
;;       (mc/disable-multiple-cursors-mode))
;;     (when cory/mc-hidden-cursors
;;       (cory/mc-remove-current-cursor)
;;       (setq-local cory/mc-hidden-cursors (reverse cory/mc-hidden-cursors))
;;       (message "Visible cursors threshold is hit, hidden cursors created, please record macro to apply changes to them"))))

;; Visual regex replacement
(use-package visual-regexp
  :bind
  (("C-c c" . cory/replace)
   ("C-c C" . vr/query-replace)
   ;; for multiple-cursors
   ("C-c M" . vr/mc-mark))
  :config
  (defun cory/replace ()
    (interactive)
    ;; If region is active, only replace the region
    (if (and transient-mark-mode mark-active (not (eq (mark) (point))))
        (call-interactively 'vr/replace)
      (save-excursion
	(goto-char 0)
	(call-interactively 'vr/replace)))))

;; Move text
(use-package move-text
  :bind (([(control shift up)]   . move-text-up)
         ([(control shift down)] . move-text-down)
         ([(meta shift up)]      . move-text-up)
         ([(meta shift down)]    . move-text-down)
	 ("C-S-n" . move-text-down)
	 ("C-S-p" . move-text-up)))

;; ;; Copy text as Discord/GitHub/etc formatted code
;; (use-package copy-as-format
;;   :bind
;;   (("C-c c c" . copy-as-format)
;;    ("C-c c g" . copy-as-format-github)
;;    ("C-c c t" . copy-as-format-markdown-table)
;;    ("C-c c m" . copy-as-format-markdown)
;;    ("C-c c o" . copy-as-format-org-mode)
;;    ("C-c c d" . copy-as-format-slack)
;;    ("C-c c v" . org-copy-visible))
;;   :config
;;   (setq copy-as-format-default "slack")
;;   (defun copy-as-format--markdown-table (text _multiline)
;;     (s-replace "--+--" "--|--" text))
;;   (add-to-list 'copy-as-format-format-alist '("markdown-table" copy-as-format--markdown-table)))

;; Code folding
;; (dolist (mode '(c-mode-common-hook
;; 		emacs-lisp-mode-hook
;; 		lisp-mode-hook
;; 		clojure-mode-hook
;; 		clojurescript-mode-hook
;; 		clojurec-mode-hook
;; 		java-mode-hook
;; 		perl-mode-hook
;; 		sh-mode-hook
;; 		nix-mode-hook))
;;   (add-hook mode 'hs-minor-mode))
;; (global-set-key (kbd "C-+") 'hs-toggle-hiding)

(use-package origami
  :bind
  (("C-=" . origami-toggle-node)
   ("C-+" . origami-show-only-node)
   ;; ("C-+" . origami-recursively-toggle-node)
   )
  :config
  (global-origami-mode))

;; Color picker
;; (use-package webkit-color-picker
;;   :ensure t
;;   :bind (("C-c p" . webkit-color-picker-show)))

;;; Easier macro handling
;; (use-package kmacro-x
;;   :ensure t
;;   :init (kmacro-x-atomic-undo-mode 1)
;;   :bind ("C-c k" . kmacro-x-mc-region))

;;; Delete selection mode
(delete-selection-mode 1)
#+end_src

** search

#+begin_src emacs-lisp :tangle yes
;;; Search functions

;; Phi search
(use-package phi-search)

(require 's)

(defun cory/regex-combos (l)
  "Return a list of regexes that will match combitations of the strings in `L'."
  (if (not (cdr l))
      l
    (cl-reduce
     #'append
     (mapcar
      (lambda (e)
	(mapcar
	 (lambda (f) (concat e ".*" f))
	 (cory/regex-combos (remove e l))))
      l))))

(defun cory/isearch-string ()
  "Return the string to isearch for."
  (let ((search-args (s-split " " (car consult--line-history))))
    (if (cdr search-args)
	(concat
	 "^.*\\("
	 (cl-reduce
	  (lambda (x y) (concat x "\\|" y))
	  (cory/regex-combos search-args))
	 "\\).*$")
      (car search-args))))

(defun cory/isearch-forward-resume ()
  (interactive)
  (let ((search-str (cory/isearch-string)))
    (isearch-resume search-str t nil t search-str t)))

(defun cory/isearch-backward-resume ()
  (interactive)
  (let ((search-str (cory/isearch-string)))
    (isearch-resume search-str t nil nil search-str t)))

(defun cory/consult-line-backward (&optional initial start)
  "Search for a matching line, but backwards.

Depending on the setting `consult-point-placement' the command jumps to the
beginning or the end of the first match on the line or the line beginning. The
default candidate is the non-empty line next to point. This command obeys
narrowing. Optional INITIAL input can be provided. The search starting point is
changed if the START prefix argument is set. The symbol at point and the last
`isearch-string' is added to the future history."
  (interactive (list nil (not (not current-prefix-arg))))
  (let* ((curr-line (line-number-at-pos (point) consult-line-numbers-widen))
         (top (not (eq start consult-line-start-from-top)))
         (candidates (or (consult--with-increased-gc
                         (reverse (consult--line-candidates top curr-line)))
                        (user-error "No lines"))))
    (consult--read
     candidates
     :prompt (if top "Go to line (backward) from top: " "Go to line (backward): ")
     :annotate (consult--line-prefix curr-line)
     :category 'consult-location
     :sort nil
     :require-match t
     ;; Always add last isearch string to future history
     :add-history (list (thing-at-point 'symbol) isearch-string)
     :history '(:input consult--line-history)
     :lookup #'consult--line-match
     :default (car candidates)
     ;; Add isearch-string as initial input if starting from isearch
     :initial (or initial
                 (and isearch-mode
                    (prog1 isearch-string (isearch-done))))
     :state (consult--location-state candidates))))

(defun cory/visual-isearch-forward ()
  (interactive)
  (consult-line)
  (beginning-of-line)
  (cory/isearch-forward-resume))

(defun cory/visual-isearch-backward ()
  (interactive)
  (cory/consult-line-backward)
  (end-of-line)
  (cory/isearch-backward-resume))

(defun cory/search-forward-dwim ()
  (interactive)
  ;; Are we using multiple cursors?
  (cond ((and (boundp 'multiple-cursors-mode)
	    multiple-cursors-mode
	    (fboundp  'phi-search))
         (call-interactively 'phi-search))
        ;; Are we defining a macro?
        (defining-kbd-macro
          (call-interactively 'isearch-forward))
        ;; Fall back to isearch.
        (t
         ;; If region is active, prepopulate the isearch term.
	 (if (and transient-mark-mode mark-active (not (eq (mark) (point))))
	     (let ((region (buffer-substring-no-properties (mark) (point))))
               (deactivate-mark)
	       (setq consult--line-history (cons region consult--line-history))
               (isearch-resume region nil nil t region nil))
	   (cory/visual-isearch-forward)))))

(defun cory/search-backward-dwim ()
  (interactive)
  ;; Are we using multiple cursors?
  (cond ((and (boundp 'multiple-cursors-mode)
            multiple-cursors-mode
            (fboundp  'phi-search-backward))
         (call-interactively 'phi-search-backward))
        ;; Are we defining a macro?
        (defining-kbd-macro
          (call-interactively 'isearch-backward))
        ;; Fall back to isearch.
        (t
         ;; If region is active, prepopulate the isearch term.
         (if (and transient-mark-mode mark-active (not (eq (mark) (point))))
             (let ((region (buffer-substring-no-properties (mark) (point))))
               (deactivate-mark)
	       (setq consult--line-history (cons region consult--line-history))
               (isearch-resume region nil nil nil region nil))
           (cory/visual-isearch-backward)))))
#+end_src

** templates

#+begin_src emacs-lisp :tangle yes
;; Templates
(use-package tempel
  ;; Require trigger prefix before template name when completing.
  ;; :custom
  ;; (tempel-trigger-prefix "")

  :hook
  ((prog-mode text-mode) . tempel-setup-capf)
  (emacs-lisp-mode . elisp-super-capf)

  :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
         ("M-*" . tempel-insert)
	 :map tempel-map
	 ("C-<tab>" . tempel-next)
	 ("C-S-<tab>" . tempel-previous)
	 ([remap keyboard-quit] . tempel-done))

  :init
  ;; Setup completion at point
  (defun tempel-setup-capf ()
    ;; Add the Tempel Capf to `completion-at-point-functions'.
    ;; `tempel-expand' only triggers on exact matches. Alternatively use
    ;; `tempel-complete' if you want to see all matches, but then you
    ;; should also configure `tempel-trigger-prefix', such that Tempel
    ;; does not trigger too often when you don't expect it. NOTE: We add
    ;; `tempel-expand' *before* the main programming mode Capf, such
    ;; that it will be tried first.
    (setq-local completion-at-point-functions
                (cons #'tempel-complete
		      completion-at-point-functions)))

  (defun elisp-super-capf ()
    (setq-local completion-at-point-functions
		(list (cape-super-capf
		       #'tempel-complete
		       #'elisp-completion-at-point)
		      #'cape-dabbrev
		      #'cape-file)))

  ;; Optionally make the Tempel templates available to Abbrev,
  ;; either locally or globally. `expand-abbrev' is bound to C-x '.
  ;; (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
  ;; (global-tempel-abbrev-mode)
  )

;; Snippets
;; (use-package yasnippet
;;   :config
;;   ;; Don't touch TAB!!!

;;   ;; The active keymap while a snippet expansion is in progress.
;;   (setq yas-keymap
;; 	(let ((map (make-sparse-keymap)))
;; 	  (define-key map (kbd "C-<tab>")   (yas-filtered-definition 'yas-next-field-or-maybe-expand))
;; 	  (define-key map (kbd "C-M-<tab>") (yas-filtered-definition 'yas-prev-field))
;; 	  (define-key map (kbd "C-g")   (yas-filtered-definition 'yas-abort-snippet))
;; 	  (define-key map (kbd "C-d")   (yas-filtered-definition yas-maybe-skip-and-clear-field))
;; 	  (define-key map (kbd "DEL")   (yas-filtered-definition yas-maybe-clear-field))
;; 	  map))

;;   ;; The keymap used when `yas-minor-mode' is active.
;;   (setq yas-minor-mode-map
;; 	(let ((map (make-sparse-keymap)))
;; 	  (define-key map (kbd "C-<tab>") yas-maybe-expand)
;; 	  (define-key map "\C-c&\C-s" 'yas-insert-snippet)
;; 	  (define-key map "\C-c&\C-n" 'yas-new-snippet)
;; 	  (define-key map "\C-c&\C-v" 'yas-visit-snippet-file)
;; 	  map))

;;   (yas-global-mode 1))

;; (use-package common-lisp-snippets)

;; (use-package clojure-snippets)

;; (use-package java-snippets)

;; (use-package gitignore-snippets
;;   :config (gitignore-snippets-init))
#+end_src

** shell

#+begin_src emacs-lisp :tangle yes
;;
;; --- TERMINALS ---
;;

;;; Terminal

;; (use-package term
;;   :config
;;   (setq explicit-shell-file-name "zsh")
;;   ;;(setq explicit-zsh-args '())
;;   (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

;; Use local Emacs instance as $EDITOR (e.g. in `git commit' or `crontab -e')
(use-package with-editor
  :hook ((shell-mode-hook eshell-mode-hook term-exec-hook vterm-exec-hook)
         . with-editor-export-editor)
  :bind (([remap async-shell-command] . with-editor-async-shell-command)
         ([remap shell-command] . with-editor-shell-command)))

;; Enhanced shell completion
;; (use-package pcmpl-args) ; slow?

;;; Eshell

(setenv "PAGER" "eshell/less")

;; Don't print the welcome banner and
;; use native 'sudo', system sudo asks for password every time.
(require 'em-tramp)
(setq eshell-modules-list
      '(eshell-alias
        eshell-basic
        eshell-cmpl
        eshell-dirs
        eshell-glob
        eshell-hist
        eshell-ls
        eshell-pred
        eshell-prompt
        eshell-script
        eshell-term
        eshell-tramp
        eshell-unix))

(require 'em-smart)
(setq eshell-where-to-jump 'begin)
(setq eshell-review-quick-commands nil)
(setq eshell-smart-space-goes-to-end t)

(defun cory/eshell-clear-buffer ()
  "Clear terminal"
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)
    (eshell-send-input)))

(defun cory/eshell-forward-char-or-complete-from-history (&optional arg)
  "If at the end of the eshell buffer, complete from history.
Else, go foward ARG characters."
  (interactive)
  (if (and (= (point) (point-max))
	(not (= (save-excursion (eshell-bol) (point)) (point-max))))
      (cape-history t)
    (forward-char arg)))

(defun cory/eshell-move-end-of-line-or-complete-from-history (&optional arg)
  "If at the end of the eshell buffer, complete from history.
Else, go to the end of line ARG number of times."
  (interactive)
  (if (and (= (point) (point-max))
	(not (= (save-excursion (eshell-bol) (point)) (point-max))))
      (cape-history t)
    (move-end-of-line arg)))

(defun cory/configure-eshell ()
  "Eshell configuration that will run the first time eshell launches."
  ;; Save command history when commands are entered
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

  ;; Truncate buffer for performance
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

  (setq eshell-history-size 1000
	eshell-buffer-maximum-lines 1000
	eshell-hist-ignoredups t
	eshell-scroll-to-bottom-on-input t)

  ;; (setq-local completion-in-region-function #'consult-completion-in-region)

  ;; Keybinds
  (local-set-key (kbd "M-s") #'consult-history)
  (local-set-key (kbd "M-r") #'consult-history)
  (local-set-key (kbd "C-l") #'cory/eshell-clear-buffer)
  (local-set-key (kbd "C-f") #'cory/eshell-forward-char-or-complete-from-history)
  (local-set-key (kbd "<right>") #'cory/eshell-forward-char-or-complete-from-history)
  (local-set-key (kbd "C-e") #'cory/eshell-move-end-of-line-or-complete-from-history)
  (local-set-key (kbd "<end>") #'cory/eshell-move-end-of-line-or-complete-from-history)

  ;; Alias setup
  ;; (eshell/alias "nixos-update" "nix flake update")
  ;; (eshell/alias "nixos-clean" "sudo nix-collect-garbage --delete-older-than $1")
  ;; (eshell/alias "nixos-superclean" "sudo nix-collect-garbage --delete-old")
  ;; (eshell/alias "n" "cd $HOME/.config/nix")
  ;; (eshell/alias "nd" "nix develop $*")
  ;; (eshell/alias "ls" "eshell/ls -A")
  ;; (eshell/alias "l" "ls $*")
  ;; (eshell/alias "ll" "ls -l -h $*")
  ;; (eshell/alias "c" "clear-scrollback")
  ;; (eshell/alias "clear" "clear-scrollback")
  ;; (eshell/alias "grep" "grep -i --color=auto $*")
  ;; (eshell/alias "rm" "eshell/rm --verbose $*")
  ;; (eshell/alias "mv" "eshell/mv --interactive --verbose $1 $2")
  ;; (eshell/alias "cp" "eshell/cp --interactive --verbose $1 $2 $3")
  ;; (eshell/alias "nf" "neofetch $*")
  ;; (eshell/alias "e" "find-file $1")
  ;; (eshell/alias "eo" "find-file-other-window $1")
  ;; (eshell/alias "edit" "find-file $1")
  ;; (eshell/alias "edit-other" "find-file-other-window $1")
  )

(add-hook 'eshell-first-time-mode-hook 'cory/configure-eshell)

;; Optimize corfu for eshell
;; (add-hook 'eshell-mode-hook
;;           (lambda () (setq-local corfu-quit-at-boundary t
;; 			    corfu-quit-no-match t
;; 			    corfu-auto t
;; 			    completion-at-point-functions
;; 			    (list (cape-super-capf
;; 				   #'cape-history
;; 				   #'pcomplete-completions-at-point)))
;; 	    (corfu-mode 1)))

;; Don't use corfu in eshell
(add-hook 'eshell-mode-hook
          (lambda () (setq-local
		 completion-cycle-threshold t
		 completion-at-point-functions
		 (list #'pcomplete-completions-at-point)
		 completion-styles '(basic partial-completion emacs22))
	    (corfu-mode -1)))

;; Eshell popup
;; (add-to-list 'display-buffer-alist
;;              '("\`\eshell\\(?:<[[:digit:]]+>\)?\'"
;;                (display-buffer-in-side-window (side . bottom))))

;; Use vterm for visual commands
(use-package eshell-vterm
  :load-path "site-lisp/eshell-vterm"
  :demand t
  :after eshell
  :config
  (eshell-vterm-mode)
  (defalias 'eshell/v 'eshell-exec-visual))

;; Eshell's zoxide
(use-package eshell-z
  ;; :hook (eshell-mode . eshell-z)
  ;; :config
  ;; (defalias 'eshell/cd 'eshell-z)
  )

;; One prompt at all times
(use-package eshell-fixed-prompt
  :disabled t
  :hook (eshell-mode . eshell-fixed-prompt-mode))

;; Syntax highlighting
(use-package eshell-syntax-highlighting
  :ensure t
  :config
  ;; Enable in all future ehell buffers
  (eshell-syntax-highlighting-global-mode +1))

;; Eshell auto-complete
;; `company-mode' backend to provide eshell history suggestion
;; (use-package esh-autosuggest
;;   :ensure t
;;   :hook (eshell-mode . esh-autosuggest-mode))

;; Eshell fish completion
(use-package fish-completion
  :disabled t
  :config
  (when (and (executable-find "fish")
           (require 'fish-completion nil t))
    (global-fish-completion-mode)))

;; Eshell up
(use-package eshell-up
  :config
  (defalias 'eshell/up 'eshell-up)
  (defalias 'eshell/pk 'eshell-up-peek))

;; Eshell help
(use-package esh-help
  :ensure t
  :defer t
  :config
  (setup-esh-help-eldoc))

;; Info (from Emacs wiki)
(defun eshell/info (subject)
  "Read the Info manual on SUBJECT."
  (let ((buf (current-buffer)))
    (Info-directory)
    (let ((node-exists (ignore-errors (Info-menu subject))))
      (if node-exists
          0
        ;; We want to switch back to *eshell* if the requested
        ;; Info manual doesn't exist.
        (switch-to-buffer buf)
        (eshell-print (format "There is no Info manual on %s.\n"
                              subject))
        1))))

;; Less/More (from Emacs wiki)
(defun eshell-view-file (file)
  "A version of `view-file' which properly respects the eshell prompt."
  (interactive "fView file: ")
  (unless (file-exists-p file) (error "%s does not exist" file))
  (let ((had-a-buf (get-file-buffer file))
        (buffer (find-file-noselect file)))
    (if (eq (with-current-buffer buffer (get major-mode 'mode-class))
           'special)
        (progn
          (switch-to-buffer buffer)
          (message "Not using View mode because the major mode is special"))
      (let ((undo-window
	     (list (window-buffer) (window-start)
                   (+ (window-point)
                      (length (funcall eshell-prompt-function))))))
        (switch-to-buffer buffer)
        (view-mode-enter (cons (selected-window) (cons nil undo-window))
                         'kill-buffer)))))

(defun eshell/less (&rest args)
  "Invoke `view-file' on a file.  \"less +42 foo\" will go to line 42 in the buffer for foo."
  (while args
    (if (string-match "\\`\\+\\([0-9]+\\)\\'" (car args))
        (let* ((line (string-to-number (match-string 1 (pop args))))
               (file (pop args)))
          (eshell-view-file file)
          (goto-line line))
      (eshell-view-file (pop args)))))

(defalias 'eshell/more 'eshell/less)

;; Delete backup files (from Emacs wiki)
(defun eshell/rmb ()
  "Delete files matching pattern \".*~\" and \"*~\"."
  (eshell/rm (directory-files "." nil "^\\.?.*~$" nil)))

(defun eshell/extract (file &rest args)
  "Unpack FILE with ARGS.
Stolen from aweshell."
  (let ((command (-some (lambda (x)
                          (if (string-match-p (car x) file)
                              (cadr x)))
                        '((".*\.tar.bz2" "tar xjf")
                          (".*\.tar.gz" "tar xzf")
                          (".*\.bz2" "bunzip2")
                          (".*\.rar" "unrar x")
                          (".*\.gz" "gunzip")
                          (".*\.tar" "tar xf")
                          (".*\.tbz2" "tar xjf")
                          (".*\.tgz" "tar xzf")
                          (".*\.zip" "unzip")
                          (".*\.Z" "uncompress")
                          (".*" "echo 'Could not unpack the file:'")))))
    (let ((unpack-command (concat command " " file " " (mapconcat 'identity args " "))))
      (eshell/printnl "Unpack command: " unpack-command)
      (eshell-command-result unpack-command))
    ))

(defun eshell/cat (filename)
  "Like cat(1) but with syntax highlighting.
Stole from aweshell. FILENAME is the file to display."
  (let ((existing-buffer (get-file-buffer filename))
        (buffer (find-file-noselect filename)))
    (eshell-print
     (with-current-buffer buffer
       (if (fboundp 'font-lock-ensure)
           (font-lock-ensure)
         (with-no-warnings
           (font-lock-fontify-buffer)))
       (let ((contents (buffer-string)))
         (remove-text-properties 0 (length contents) '(read-only nil) contents)
         contents)))
    (unless existing-buffer
      (kill-buffer buffer))
    nil))

;; Running programs in a term-mode buffer
;; (with-eval-after-load 'esh-opt
;;   (setq eshell-destroy-buffer-when-process-dies t)
;;   (setq eshell-visual-commands '("htop" "zsh" "vim")))

;;; Give eshell/ls icons
(defun cory/eshell-prettify (file)
  "Add features to listings in `eshell/ls' output.
The features are:
1. Add decoration like 'ls -F':
 * Mark directories with a `/'
 * Mark executables with a `*'
2. Make each listing into a clickable link to open the
corresponding file or directory.
3. Add icons (requires `all-the-icons`)
This function is meant to be used as advice around
`eshell-ls-annotate', where FILE is the cons describing the file."
  (let* ((name (car file))
         (icon (if (eq (cadr file) t)
                   (all-the-icons-icon-for-dir name)
                 (all-the-icons-icon-for-file name)))
         (suffix
          (cond
           ;; Directory
           ((eq (cadr file) t)
            "/")
           ;; Executable
           ((and (/= (user-uid) 0) ; root can execute anything
	       (eshell-ls-applicable (cdr file) 3 #'file-executable-p (car file)))
            "*"))))
    (cons
     (concat " "
             icon
             " "
             (propertize name
                         'keymap eshell-ls-file-keymap
                         'mouse-face 'highlight
                         'file-name (expand-file-name (substring-no-properties (car file)) default-directory))
             (when (and suffix (not (string-suffix-p suffix name)))
               (propertize suffix 'face 'shadow)))
     (cdr file)
     )))

(defun eshell-ls-file-at-point ()
  "Get the full path of the Eshell listing at point."
  (get-text-property (point) 'file-name))

(defun eshell-ls-find-file ()
  "Open the Eshell listing at point."
  (interactive)
  (find-file (eshell-ls-file-at-point)))

(defun eshell-ls-delete-file ()
  "Delete the Eshell listing at point."
  (interactive)
  (let ((file (eshell-ls-file-at-point)))
    (when (yes-or-no-p (format "Delete file %s?" file))
      (delete-file file 'trash))))

(defvar eshell-ls-file-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "RET") #'eshell-ls-find-file)
    (define-key map (kbd "<return>") #'eshell-ls-find-file)
    (define-key map [mouse-1] #'eshell-ls-find-file)
    (define-key map (kbd "D") #'eshell-ls-delete-file)
    map)
  "Keys in effect when point is over a file from `eshell/ls'.")

(advice-add #'eshell-ls-annotate :filter-return #'cory/eshell-prettify)

;; Eshell prompt
(use-package eshell-prompt-extras
  :config
  (defun epe-theme-cory ()
    "Cory's prompt."
    ;; If the prompt spans over multiple lines, the regexp should match
    ;; last line only.
    (setq eshell-prompt-regexp "^╰─λ ")
    (let* ((icon (all-the-icons-icon-for-mode 'nix-mode))
	   (nix (propertize
		 icon
		 'face
		 (plist-put
		  (get-text-property 0 'face icon)
		  :height 1.0)
		 'font-lock-face
		 (plist-put
		  (get-text-property 0 'font-lock-face icon)
		  :height 1.0)
		 'display
		 '(raise 0))))
      (concat
       (epe-colorize-with-face (epe-status) 'epe-status-face)
       (when (epe-remote-p)
	 (epe-colorize-with-face
	  (concat "(" (epe-remote-user) "@" (epe-remote-host) ")")
	  'epe-remote-face))
       (when (and epe-show-python-info (bound-and-true-p venv-current-name))
	 (epe-colorize-with-face (concat "(" venv-current-name ") ") 'epe-venv-face))
       (let ((f (cond ((eq epe-path-style 'fish) 'epe-fish-path)
                      ((eq epe-path-style 'single) 'epe-abbrev-dir-name)
                      ((eq epe-path-style 'full) 'abbreviate-file-name))))
	 (pcase (epe-extract-git-component (funcall f (eshell/pwd)))
	   (`(,prefix nil)
            (format
             (propertize "╭╴%s %s" 'face '(:weight regular))
	     nix
             (propertize prefix 'face '(:weight bold :foreground "#3647d9"))))
	   (`(,prefix ,git-component)
            (format
             (epe-colorize-with-face "╭╴%s %s%s %s %s" '(:weight regular))
	     nix
             (epe-colorize-with-face prefix '(:weight bold :foreground "#3647d9"))
             (if (string-empty-p git-component)
		 ""
               (concat "/"
                       (epe-colorize-with-face git-component '(:weight bold :foreground "#2d9574"))))
             (epe-colorize-with-face
              (concat (or (epe-git-branch)
			 (epe-git-tag))
                      (epe-git-dirty)
                      (epe-git-untracked))
              '(:weight italic :foreground "#1f8c35"))
	     (epe-colorize-with-face
	      (let ((unpushed (epe-git-unpushed-number)))
		(if (= unpushed 0) ""
		  (concat "↑" (number-to-string unpushed))))
	      '(:foreground "#e01bd0"))))))
       (epe-colorize-with-face "\n╰─λ" '(:weight regular))
       " ")))
  (with-eval-after-load "esh-opt"
    (setq eshell-highlight-prompt nil
          eshell-prompt-function 'epe-theme-cory)))

;; Eshell undistract me
(setq eshell-undistract-me-play-sound t)
(setq eshell-undistract-me-sound-path "/run/current-system/sw/share/sounds/freedesktop/stereo/complete.oga")
(add-hook 'eshell-pre-command-hook #'eshell-undistract-me-pre-command)
(add-hook 'eshell-before-prompt-hook #'eshell-undistract-me-before-prompt)

;; Vterm
(use-package vterm
  :ensure t
  :commands (vterm))

;; (use-package multi-vterm
;;   :ensure t
;;   :bind
;;   ("C-c C-t" . multi-vterm-dedicated-toggle))
#+end_src

** projects

#+begin_src emacs-lisp :tangle yes
;; Project Management
(use-package project)

;; Git Management
(use-package magit
  :bind (("C-c g s" . magit-status)
	 :map magit-stash-mode-map
	 ("W" . magit-toggle-whitespace))
  :commands (magit-status magit-get-current-branch)
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  :config
  (defun magit-toggle-whitespace ()
    (interactive)
    (if (member "-w" magit-diff-options)
	(magit-dont-ignore-whitespace)
      (magit-ignore-whitespace)))

  (defun magit-ignore-whitespace ()
    (interactive)
    (add-to-list 'magit-diff-options "-w")
    (magit-refresh))

  (defun magit-dont-ignore-whitespace ()
    (interactive)
    (setq magit-diff-options (remove "-w" magit-diff-options))
    (magit-refresh)))

(use-package forge)
#+end_src

** ssh

#+begin_src emacs-lisp :tangle yes
;; Tramp
;; (use-package tramp
;;   :defer t
;;   :config
;;   (setq tramp-default-method "ssh")

;;   ;; Only for debugging slow tramp connections
;;   ;;(setq tramp-verbose 7)

;;   ;; Skip version control for tramp files
;;   (setq vc-ignore-dir-regexp
;;         (format "\\(%s\\)\\|\\(%s\\)"
;;                 vc-ignore-dir-regexp
;;                 tramp-file-name-regexp))

;;   ;; Use ControlPath from .ssh/config
;;   (setq tramp-ssh-controlmaster-options "")

;;   ;; Backup tramp files like local files and don't litter the remote
;;   ;; file system with my emacs backup files
;;   (setq tramp-backup-directory-alist backup-directory-alist)

;;   ;; See https://www.gnu.org/software/tramp/#Ad_002dhoc-multi_002dhops
;;   ;; For all hosts, except my local one, first connect via ssh, and then apply sudo -u root:
;;   (dolist (tramp-proxies '((nil "\\`root\\'" "/ssh:%h:")
;;                            ((regexp-quote (system-name)) nil nil)
;;                            ("localhost" nil nil)
;;                            ("blif\\.vpn" nil nil)
;;                            ("skor-pi" nil nil)
;;                            ;; Add tramp proxy for atomx user
;;                            (nil "atomx" "/ssh:%h:")))
;;     (add-to-list 'tramp-default-proxies-alist tramp-proxies)))

;; SSH Functions
(defun cory/write-ssh-address-to-history (address)
  (write-region (concat address "
") nil "~/.emacs.d/ssh_history" t))

(defun cory/read-ssh-history ()
  "Return a list of ssh addresses previously connected to."
  (with-temp-buffer
    (insert-file-contents "~/.emacs.d/ssh_history")
    (split-string (buffer-string) "\n" t)))

(defun cory/clean-ssh-history ()
  (interactive)
  (write-region "" nil "~/.emacs.d/ssh_history"))

(defun cory/connect-ssh ()
  "Requires sshfs to be installed."
  (interactive)
  (let* ((server (completing-read "user@server.address:" (cory/read-ssh-history)))
	 (mount-path (concat temporary-file-directory ".emacs-sshfs-mount-" server))
	 (user (string-trim-right server "@.*")))
    (cory/write-ssh-address-to-history server)
    (unless (file-directory-p mount-path)
      (make-directory mount-path))
    (unless (file-exists-p (concat mount-path "/home"))
      (shell-command (concat "sshfs -o idmap=user,transform_symlinks "
			     server ":/ " mount-path)))
    (find-file (read-file-name "Find file:"
			       (concat mount-path "/home/" user "/")))))

(defun cory/disconnect-ssh ()
  "Manually disconnects the ssh connection to the server. Requires fusemount."
  (interactive)
  (shell-command
   (concat "fusermount -u "
	   (concat temporary-file-directory
		   ".emacs-sshfs-mount-"
		   (completing-read "user@server.address:"
				    (cory/read-ssh-history))))))
#+end_src

** movement

#+begin_src emacs-lisp :tangle yes
;; Jump around
(use-package avy
  :ensure t
  :bind
  (;; ("M-g g" . avy-goto-line)
   ;; ("M-g c" . avy-goto-char-in-line)
   ;; ("M-g m" . avy-move-line)
   ("<C-m>" . avy-goto-char-timer)
   ("C-S-m" . avy-pop-mark)
   ;; ("C-j" . avy-goto-end-of-line-num)
   ;; ("C-S-j" . avy-goto-line-num)
   ("C-M-s" . isearch-forward-other-window)
   ("C-M-r" . isearch-backward-other-window)
   :map isearch-mode-map
   ("<C-m>" . avy-isearch))

  :custom
  ;; (setq avy-keys '(?q ?e ?r ?y ?u ?o ?p
  ;;                     ?a ?s ?d ?f ?g ?h ?j
  ;;                     ?k ?l ?' ?x ?c ?v ?b
  ;;                     ?n ?, ?/))
  ;; (avy-keys (append (string-to-list "aoehsfb")
  ;; 		    (string-to-list "ulrpdc")
  ;; 		    (string-to-list "qjvg")
  ;; 		    (string-to-list (upcase "aoehsfb"))
  ;; 		    (string-to-list (upcase "ulrpdc"))
  ;; 		    (string-to-list (upcase "qjvg"))
  ;; 		    (number-sequence ?, ?')))
  ;; (avy-keys (nconc (number-sequence ?a ?z)
  ;; 		   (number-sequence ?A ?Z)))
  (avy-keys (append (string-to-list "atenisubopyflmc")
		    (string-to-list (upcase "atenisubopyflmc"))))
  (avy-timeout-seconds 0.25)

  :config

  ;; Most of the below was copied from and/or inspired by
  ;; https://github.com/xl666/avy-conf/blob/main/avy.org

  ;; Need to use C- now because all letters of the alphabet are taken
  ;; Rebind default avy actions
  (setf (alist-get ?\C-y avy-dispatch-alist) 'avy-action-yank
	(alist-get ?\M-w avy-dispatch-alist) 'avy-action-copy
	(alist-get ?\C-k avy-dispatch-alist) 'avy-action-kill-move
	(alist-get (kbd "<C-m>") avy-dispatch-alist) 'avy-action-teleport)

  ;; Avy helper functions for both generic and complex avy actions
  (defun avy-generic-command-action (action-f)
    "Excecutes action-f at point and stays"
    (save-excursion
      (goto-char pt)
      (funcall action-f))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-generic-command-action-no-stay (action-f)
    "Excecutes action-f at point and returns to original position"
    (goto-char pt)
    (funcall action-f)
    t)

  ;;; Actions from "Avy can do anything"

  (defun avy-action-mark-to-char (pt)
    (activate-mark)
    (goto-char (+ 1 pt)))
  (setf (alist-get 67108896 avy-dispatch-alist) 'avy-action-mark-to-char) ; C-SPC

  (defun avy-action-helpful (pt)
    (avy-generic-command-action #'helpful-at-point))
  (setf (alist-get ?\C-h avy-dispatch-alist) 'avy-action-helpful)

  (defun avy-action-flyspell (pt)
    (avy-generic-command-action #'flyspell-auto-correct-word))
  (setf (alist-get 67108923 avy-dispatch-alist) 'avy-action-flyspell) ; C-;

  (defun avy-action-kill-whole-line (pt)
    (avy-generic-command-action #'kill-whole-line))
  (setf (alist-get (kbd "C-M-k") avy-dispatch-alist) 'avy-action-kill-whole-line)

  (defun avy-action-copy-whole-line (pt)
    (avy-generic-command-action (lambda () (cl-destructuring-bind (start . end)
					  (bounds-of-thing-at-point 'line)
					(copy-region-as-kill start end)))))
  (setf (alist-get (kbd "C-M-w") avy-dispatch-alist) 'avy-action-copy-whole-line)

  (defun avy-action-yank-whole-line (pt)
    (avy-action-copy-whole-line pt)
    (save-excursion (yank)) t)
  (setf (alist-get (kbd "C-M-y") avy-dispatch-alist) 'avy-action-yank-whole-line)

  (defun avy-action-teleport-whole-line (pt)
    (avy-action-kill-whole-line pt)
    (save-excursion (yank)) t)
  (setf (alist-get (kbd "C-M-t") avy-dispatch-alist) 'avy-action-teleport-whole-line)

  (defun avy-action-define (pt)
    (avy-generic-command-action #'dictionary-search-dwim))
  (setf (alist-get (kbd "C-=") avy-dispatch-alist) 'avy-action-define)

  (defun avy-action-embark (pt)
    (unwind-protect (avy-generic-command-action #'embark-act)) t)
  (setf (alist-get (kbd "<C-i>") avy-dispatch-alist) 'avy-action-embark)

  ;;; New behavior

  ;; Open org link (only relevant for org files)
  (defun avy-action-open-at-point (pt)
    (goto-char pt)
    (org-open-at-point)
    t)
  (setf (alist-get ?\C-o avy-dispatch-alist) 'avy-action-open-at-point)

  ;; Clone line below
  (defun avy-action-clone-line (pt)
    (goto-char pt)
    (move-beginning-of-line 1)
    (cl-destructuring-bind (start . end)
        (bounds-of-thing-at-point 'line)
      (copy-region-as-kill start end))
    (yank)
    (indent-for-tab-command)
    t)
  (setf (alist-get ?\C-l avy-dispatch-alist) 'avy-action-clone-line)

  ;;; Regions

  ;; - The idea is to be able to act in arbitrary regions without the need of manually marking a region
  ;; - It relies on two basic operations:
  ;;   - First mark the beginning of the region with a set-point action
  ;;   - Then apply a region action selecting the end of the region
  ;; - Region actions are the same as Original actions but for regions
  ;; - Region actions take the original code of avy actions as much as possible
  ;; - A necessary hack is to simulate region selection instead of using direct functions like `copy-region-as-kill' as those functions do not allow to manipulate regions if parenthesis or other syntax elements are not balanced. This has a weird behavior in modes like emacs-lisp so I’m not sure if it is a syntax problem

  ;; set-point-action
  (defun avy-action-mark-point (pt)
    "Sets a point for other commands"
    (setq my-avy-point pt)
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    (message "Point set!"))
  (setf (alist-get ?. avy-dispatch-alist) 'avy-action-mark-point)

  ;; Common region functions
  (defun avy--quick-mark-region (pt)
    "Intermediate function to mark regions, used in region actions"
    (when (> my-avy-point pt)
      (progn
	(setf aux pt)
	(setf pt my-avy-point)
	(setf my-avy-point aux)))
    (goto-char my-avy-point)
    (set-mark my-avy-point)
    (activate-mark)
    (goto-char (+ 1 pt))
    (setq my-avy-point nil))

  (defun avy--return-point-region-action ()
    "Makes sure that the point returns to its original place even if it is in another window"
    (let ((dat (ring-ref avy-ring 0)))
      (select-frame-set-input-focus
       (window-frame (cdr dat)))
      (select-window (cdr dat))
      (goto-char (car dat))))

  (defun avy--check-for-region-errors ()
    "Cheks if set point action was previously made, cleans action otherwise"
    (progn (message "No point set")
           (avy--return-point-region-action)
           nil))

  ;; Region actions
  (defun avy-action-copy-region (pt)
    "Copy region and stays"
    (if my-avy-point
	(progn
          (save-excursion
            (avy--quick-mark-region pt)
            (call-interactively 'kill-ring-save))
          (avy--return-point-region-action)
          (message "Copied: %s" (current-kill 0))
          t)
      (avy--check-for-region-errors)))
  (setf (alist-get ?\M-W avy-dispatch-alist) 'avy-action-copy-region)

  (defun avy-action-yank-region (pt)
    "Yank region and stays"
    (avy-action-copy-region pt)
    (yank)
    t)
  (setf (alist-get 33554457 avy-dispatch-alist) 'avy-action-yank-region) ; C-Y

  (defun avy-action-kill-region-move (pt)
    "Kills a region and moves"
    (if my-avy-point
	(progn
          (avy--quick-mark-region pt)
          (call-interactively 'kill-region)
          (message "Killed: %s" (current-kill 0))
          (point)
          t)
      (avy--check-for-region-errors)))
  (setf (alist-get 33554443 avy-dispatch-alist) 'avy-action-kill-region-move) ; C-K

  (defun avy-action-teleport-region (pt)
    "Teleports an arbitrary region using my-avy-point"
    (if my-avy-point
	(progn
	  (save-excursion
            (avy--quick-mark-region pt)
            (call-interactively 'kill-region))
	  (select-window
	   (cdr
            (ring-ref avy-ring 0)))
	  (yank)
	  t)
      (avy--check-for-region-errors)))
  (setf (alist-get 33554452 avy-dispatch-alist) 'avy-action-teleport-region) ; C-T

  ;;; Quick char actions
  ;; For some modes it is useful to have a shortcut for a common character, for example parenthesis in emacs-lisp

  ;; Basic funcion
  (defun avy-goto-quick-char (char &optional arg)
    "Simulates char press for filtering"
    (interactive (list char
                       current-prefix-arg))
    (avy-with avy-goto-char
      (avy-jump

       (regexp-quote (string char)))))

  ;; `emacs-lisp-mode'
  (defun avy-goto-parenthesis ()
    "Filter avy selecton with open parenthesis"
    (interactive)
    (avy-goto-quick-char 40)) ;; (
  ;; TODO Pick another keybind for paren jump
  ;; (define-key emacs-lisp-mode-map (kbd "S-SPC") 'avy-goto-parenthesis)

  ;;; TODO Auto actions and compounds

  ;;; LSP

  ;; (defun avy-action-lsp-help (pt)
  ;;   (avy-generic-command-action #'lsp-describe-thing-at-point))
  ;; (setf (alist-get 16777320 avy-dispatch-alist) 'avy-action-lsp-help) ; H-h

  (defun avy-action-lsp-goto-definition (pt)
    (avy-generic-command-action-no-stay #'xref-find-definitions))
  (setf (alist-get (kbd "M-.") avy-dispatch-alist) 'avy-action-lsp-goto-definition) ; M-.

  (defun avy-action-lsp-goto-references (pt)
    (avy-generic-command-action-no-stay #'xref-find-references))
  (setf (alist-get (kbd "M-?") avy-dispatch-alist) 'avy-action-lsp-goto-references) ; M-?

  (defun avy-action-lsp-rename (pt)
    (avy-generic-command-action
     (lambda () (call-interactively 'eglot-rename))))
  (setf (alist-get 16777330 avy-dispatch-alist) 'avy-action-lsp-rename) ; C-r

  ;;; Functions

  ;; Avy + Isearch
  ;; Isearch in other windows
  (defun isearch-forward-other-window (prefix)
    "Function to isearch-forward in other-window."
    (interactive "P")
    (unless (one-window-p)
      (save-excursion
	(let ((next (if prefix -1 1)))
          (other-window next)
          (isearch-forward)
          (other-window (- next))))))

  (defun isearch-backward-other-window (prefix)
    "Function to isearch-backward in other-window."
    (interactive "P")
    (unless (one-window-p)
      (save-excursion
	(let ((next (if prefix 1 -1)))
          (other-window next)
          (isearch-backward)
          (other-window (- next))))))

  ;; Dictionary search dwim
  (defun dictionary-search-dwim (&optional arg)
    "Search for definition of word at point. If region is active,
search for contents of region instead. If called with a prefix
argument, query for word to search."
    (interactive "P")
    (if arg
	(dictionary-search nil)
      (if (use-region-p)
          (dictionary-search (buffer-substring-no-properties
                              (region-beginning)
                              (region-end)))
	(if (thing-at-point 'word)
            (dictionary-lookup-definition)
          (dictionary-search-dwim '(4))))))

  ;; Show help in avy dispatch with ?
  (defun avy-show-dispatch-help ()
    (let* ((len (length "avy-action-"))
           (fw (frame-width))
           (raw-strings (mapcar
			 (lambda (x)
			   (format "%2s: %-19s"
				   (propertize
				    (char-to-string (car x))
				    'face 'aw-key-face)
				   (substring (symbol-name (cdr x)) len)))
			 avy-dispatch-alist))
           (max-len (1+ (apply #'max (mapcar #'length raw-strings))))
           (strings-len (length raw-strings))
           (per-row (floor fw max-len))
           display-strings)
      (cl-loop for string in raw-strings
               for N from 1 to strings-len do
               (push (concat string " ") display-strings)
               (when (= (mod N per-row) 0) (push "\n" display-strings)))
      (message "%s" (apply #'concat (nreverse display-strings)))))

  (defun avy-goto-line-num (&optional arg)
    (interactive "p")
    (let ((avy-keys (number-sequence ?0 ?9)))
      (avy-goto-line arg)))

  (defun avy-goto-end-of-line-num (&optional arg)
    (interactive "p")
    (let ((avy-keys (number-sequence ?0 ?9)))
      (avy-goto-end-of-line arg))))

(use-package avy-zap
  :bind
  (("M-z" . avy-zap-to-char-dwim)
   ("M-Z" . avy-zap-up-to-char-dwim)))

(use-package ace-link
  :bind
  (("M-o" . ace-link))
  :init
  ;; Binds `o' to ace-link in the supported modes
  (ace-link-setup-default))
#+end_src

* Langs

** clojure

#+begin_src emacs-lisp :tangle yes
;;; TODO Clean up clojure config
;;; Clojure
(use-package clojure-mode
  :defer t
  :interpreter ("bb" . clojure-mode)
  :config
  ;; Eval top level forms inside comment forms instead of the comment form itself
  (setq clojure-toplevel-inside-comment-form t)
  ;; Indent fn-traced and defn-traced the same as a regular defn.
  ;; The macros are for re-frame-10x tracing.
  (put-clojure-indent 'fn-traced :defn)
  (put-clojure-indent 'defn-traced :defn))

(use-package cider
  :bind (:map cider-mode-map
         ("M-?" . cider-maybe-clojuredocs)
         :map cider-repl-mode-map
         ("M-?" . cider-doc))
  :hook ( ;; ((cider-mode cider-repl-mode) . cider-company-enable-fuzzy-completion)
         (cider-mode . eldoc-mode))
  :config
  (defun cider-maybe-clojuredocs (&optional arg)
    "Like `cider-doc' but call `cider-clojuredocs' when invoked with prefix arg in `clojure-mode'."
    (interactive "P")
    (if (and arg (eq major-mode 'clojure-mode))
        (cider-clojuredocs arg)
      (cider-doc)))

  ;; Location of the jdk sources for NixOS
  (setq cider-jdk-src-paths "/etc/profiles/per-user/cory/lib/openjdk/lib/src.zip")

  (require 's)

  ;; Inject reveal middleware in cider-jack-in when the `:reveal' alias is set
  (defun cider-cli-global-options-contains-reveal? (&rest _)
    (and cider-clojure-cli-global-options
       (s-contains? ":reveal" cider-clojure-cli-global-options)))
  (add-to-list 'cider-jack-in-nrepl-middlewares
               '("vlaaad.reveal.nrepl/middleware" :predicate cider-cli-global-options-contains-reveal?))

  ;; Inject shadowcljs nrepl middleware in cider-jack-in when the `:cljs' alias is set
  (defun cider-cli-global-options-contains-cljs? (&rest _)
    (and cider-clojure-cli-global-options
       (s-contains? ":cljs" cider-clojure-cli-global-options)))
  (add-to-list 'cider-jack-in-nrepl-middlewares
               '("shadow.cljs.devtools.server.nrepl/middleware" :predicate cider-cli-global-options-contains-cljs?))


  ;; jack-in for babashka
  (defun cider-jack-in-babashka ()
    "Start an babashka nREPL server for the current project and connect to it."
    (interactive)
    (let* ((default-directory (project-root (project-current t)))
           (process-filter (lambda (proc string)
                             "Run cider-connect once babashka nrepl server is ready."
                             (when (string-match "Started nREPL server at .+:\\([0-9]+\\)" string)
                               (cider-connect-clj (list :host "localhost"
                                                        :port (match-string 1 string)
                                                        :project-dir default-directory)))
                             ;; Default behavior: write to process buffer
                             (internal-default-process-filter proc string))))
      (set-process-filter
       (start-file-process "babashka" "*babashka*" "bb" "--nrepl-server" "0")
       process-filter)))

  ;; Store more items in repl history (default 500)
  (setq cider-repl-history-size 2000)
  ;; When loading the buffer (C-c C-k) save first without asking
  (setq cider-save-file-on-load t)
  ;; Don't show cider help text in repl after jack-in
  (setq cider-repl-display-help-banner nil)
  ;; Don't focus repl after sending somehint to there from another buffer
  (setq cider-switch-to-repl-on-insert nil)
  ;; Eval automatically when insreting in the repl (e..g. C-c C-j d/e) (unless called with prefix)
  (setq cider-invert-insert-eval-p t)
  ;; Don't focus error buffer when error is thrown
  (setq cider-auto-select-error-buffer nil)
  ;; Don't focus inspector after evaluating something
  (setq cider-inspector-auto-select-buffer nil)
  ;; Display context dependent info in the eldoc where possible.
  (setq cider-eldoc-display-context-dependent-info t)
  ;; Don't pop to the REPL buffer on connect
  ;; Create and display the buffer, but don't focus it.
  (setq cider-repl-pop-to-buffer-on-connect 'display-only)
  ;; Just use symbol under point and don't prompt for symbol in e.g. cider-doc.
  (setq cider-prompt-for-symbol nil))

(use-package clj-refactor
  :hook (clojure-mode . clj-refactor-mode)
  :config
  (dolist (magit-require '(("csv" . "clojure.data.csv")
                           ("edn" . "clojure.edn")
                           ;; ("http" . "clj-http.client")
                           ("reagent" . "reagent.core")
                           ("re-frame" . "re-frame.core")))
    (add-to-list 'cljr-magic-require-namespaces magit-require)))

;; (use-package ob-clojure
;;   :after ob
;;   :config
;;   (setq org-babel-clojure-backend 'cider))

(use-package clojure-mode-extra-font-locking)
(use-package paredit)

;; Enable paredit for Clojure
(add-hook 'clojure-mode-hook 'enable-paredit-mode)

;; This is useful for working with camel-case tokens, like names of
;; Java classes (e.g. JavaClassName)
(add-hook 'clojure-mode-hook 'subword-mode)

;; syntax hilighting for midje
(add-hook 'clojure-mode-hook
          (lambda ()
            (setq inferior-lisp-program "lein repl")
            (font-lock-add-keywords
             nil
             '(("(\\(facts?\\)"
                (1 font-lock-keyword-face))
	       ("(\\(background?\\)"
                (1 font-lock-keyword-face))))
            (define-clojure-indent (fact 1))
            (define-clojure-indent (facts 1))
            (rainbow-delimiters-mode)))

;; provides minibuffer documentation for the code you're typing into the repl
(add-hook 'cider-mode-hook 'eldoc-mode)

;; go right to the REPL buffer when it's finished connecting
(setq cider-repl-pop-to-buffer-on-connect t)

;; When there's a cider error, show its buffer and switch to it
(setq cider-show-error-buffer t)
(setq cider-auto-select-error-buffer t)

;; Where to store the cider history.
(setq cider-repl-history-file "~/.emacs.d/cider-history")

;; Wrap when navigating history.
(setq cider-repl-wrap-history t)

;; enable paredit in your REPL
(add-hook 'cider-repl-mode-hook 'paredit-mode)

;; Use clojure mode for other extensions
(add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
(add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
(add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
(add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode))

;; Define keybindings just for clojure-mode
;; (define-key clojure-mode-map (kbd "SPC l c") 'cider-jack-in)

;; Clojure-mode specific keybindings
(add-hook 'clojure-mode-hook
	  '(cory/leader-keys
	    ","  '(:ignore t :which-key "clojure")
	    ",c" '(cider-jack-in-clj :which-key "cider jack in")
	    ",k" '(cider-load-buffer :which-key "load buffer")))

(setq read-process-output-max (* 1024 1024))
#+end_src

** common-lisp

#+begin_src emacs-lisp :tangle yes
;;; Common Lisp

(use-package sly
  :commands (sly sly-connect)
  :init
  (setq-default sly-symbol-completion-mode nil)
  (setq inferior-lisp-program "sbcl")
  ;; (setq sly-default-lisp 'roswell)
  ;; (setq ros-config (concat user-emacs-directory
  ;;                          "ros-conf.lisp"))
  ;; (setq sly-lisp-implementations
  ;;       `((sbcl ("sbcl") :coding-system utf-8-unix)
  ;;         (ccl ("ccl") :coding-system utf-8-unix)
  ;;         (ecl ("ecl") :coding-system utf-8-unix)
  ;;         (roswell ("ros" "-Q" "-l" ,ros-config "run"))
  ;;         (qlot ("qlot" "exec" "ros" "-l" ,ros-config "run" "-S" ".")
  ;;               :coding-system utf-8-unix)))
  (setq sly-lisp-implementations
        `((sbcl ("sbcl") :coding-system utf-8-unix)))

  ;; (defun qlot-sly ()
  ;;   "Start a sly repl using qlot at the projects root"
  ;;   (interactive)
  ;;   (let ((dir (cdr (project-current))))
  ;;     (if (cd dir)
  ;;         (sly 'qlot)
  ;;       (error (format "Failed to cd to %s" dir)))))

  ;; (defun sly-critique-defun ()
  ;;   "Lint this file with lisp-critic"
  ;;   (interactive)
  ;;   ;; (sly-eval-async '(ql:quickload :lisp-critic))
  ;;   (let ((form (apply #'buffer-substring-no-properties
  ;;                      (sly-region-for-defun-at-point))))
  ;;     (sly-eval-async
  ;;      `(cl:format  "~a" (list ,(read form)))
  ;;      nil (sly-current-package))))

  ;; (defun sly-critique-file ()
  ;;   "Lint this file with lisp-critic"
  ;;   (interactive)
  ;;   (sly-eval-async '(ql:quickload :lisp-critic))
  ;;   (sly-eval-async `(lisp-critic:critique ,(buffer-file-name))))
  )

(use-package sly-asdf
  :config
  (add-to-list 'sly-contribs 'sly-asdf 'append))

(use-package sly-repl-ansi-color
  :config
  (push 'sly-repl-ansi-color sly-contribs))

;; (use-package common-lisp-snippets)

(use-package lisp-extra-font-lock)
#+end_src

** cpp

#+begin_src emacs-lisp :tangle yes
;;; C++
(use-package modern-cpp-font-lock
  :ensure t)
(modern-c++-font-lock-global-mode t)

(use-package cpp-auto-include)

(use-package cmake-font-lock
  :hook (cmake-mode . cmake-font-lock-activate))

(use-package cmake-mode
  :mode ("CMakeLists.txt" "\\.cmake\\'"))

;; (use-package irony
;;   :hook (((c++-mode c-mode objc-mode) . irony-mode-on-maybe)
;;          (irony-mode . irony-cdb-autosetup-compile-options))
;;   :config
;;   (defun irony-mode-on-maybe ()
;;     ;; avoid enabling irony-mode in modes that inherits c-mode, e.g: solidity-mode
;;     (when (member major-mode irony-supported-major-modes)
;;       (irony-mode 1))))

;; (use-package irony-eldoc
;;   :hook (irony-mode . irony-eldoc))

(use-package srefactor
  :bind
  (:map c-mode-map
   ("C-c C-r" . srefactor-refactor-at-point)
   :map c++-mode-map
   ("C-c C-r" . srefactor-refactor-at-point))
  :config
  (semantic-mode 1))

;; (defun code-compile ()
;;   (interactive)
;;   (unless (file-exists-p "Makefile")
;;     (set (make-local-variable 'compile-command)
;; 	 (let ((file (file-name-nondirectory buffer-file-name)))
;; 	   (format "%s -o %s %s"
;; 		   (if  (equal (file-name-extension file) "cpp") "clang++" "clang" )
;; 		   (file-name-sans-extension file)
;; 		   file)))
;;     (compile compile-command)))

;;(global-set-key [f9] 'code-compile)
#+end_src

** elisp

#+begin_src emacs-lisp :tangle yes
;;; Lisps

;; Nicer elisp regex syntax highlighting
(use-package easy-escape
  :hook ((emacs-lisp-mode lisp-mode) . easy-escape-minor-mode))

;; From: https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94
;; redefines the silly indent of keyword lists
;; before
;;   (:foo bar
;;         :baz qux)
;; after
;;   (:foo bar
;;    :baz qux)
(eval-after-load "lisp-mode"
  '(defun lisp-indent-function (indent-point state)
     "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.
INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.
If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:
- `defun', meaning indent `defun'-style
  \(this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);
- an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;
- a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.
This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
     (let ((normal-indent (current-column))
           (orig-point (point)))
       (goto-char (1+ (elt state 1)))
       (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
       (cond
        ;; car of form doesn't seem to be a symbol, or is a keyword
        ((and (elt state 2)
	    (or (not (looking-at "\\sw\\|\\s_"))
	       (looking-at ":")))
         (if (not (> (save-excursion (forward-line 1) (point))
		  calculate-lisp-indent-last-sexp))
             (progn (goto-char calculate-lisp-indent-last-sexp)
                    (beginning-of-line)
                    (parse-partial-sexp (point)
                                        calculate-lisp-indent-last-sexp 0 t)))
         ;; Indent under the list or under the first sexp on the same
         ;; line as calculate-lisp-indent-last-sexp.  Note that first
         ;; thing on that line has to be complete sexp since we are
         ;; inside the innermost containing sexp.
         (backward-prefix-chars)
         (current-column))
        ((and (save-excursion
	      (goto-char indent-point)
	      (skip-syntax-forward " ")
	      (not (looking-at ":")))
	    (save-excursion
	      (goto-char orig-point)
	      (looking-at ":")))
         (save-excursion
           (goto-char (+ 2 (elt state 1)))
           (current-column)))
        (t
         (let ((function (buffer-substring (point)
                                           (progn (forward-sexp 1) (point))))
               method)
           (setq method (or (function-get (intern-soft function)
					 'lisp-indent-function)
			   (get (intern-soft function) 'lisp-indent-hook)))
           (cond ((or (eq method 'defun)
		     (and (null method)
			(> (length function) 3)
			(string-match "\\`def" function)))
                  (lisp-indent-defform state indent-point))
                 ((integerp method)
                  (lisp-indent-specform method state
                                        indent-point normal-indent))
                 (method
                  (funcall method indent-point state)))))))))

;;; Elisp

;; subr-x
(put 'if-let   'byte-obsolete-info nil)
(put 'when-let 'byte-obsolete-info nil)

;; emacs-lisp-mode
(defvar eval-print-as-comment-prefix ";;=> ")

(defun eval-print-as-comment (&optional arg)
  (interactive "P")
  (let ((start (point)))
    (eval-print-last-sexp arg)
    (save-excursion
      (goto-char start)
      (save-match-data
        (re-search-forward "[[:space:]\n]*" nil t)
        (insert eval-print-as-comment-prefix)))))

(define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)
(define-key emacs-lisp-mode-map (kbd "C-c C-b") 'eval-buffer)
(define-key emacs-lisp-mode-map (kbd "C-c C-k") 'eval-buffer)
(define-key emacs-lisp-mode-map (kbd "C-c C-;") 'eval-print-as-comment)

;; Make the faces of code only inside elisp code styled in such a way that
;; elisp appears like its "literally programmed"

;; (copy-face 'font-lock-comment-face
;; 	   'elisp-font-lock-comment-face)
;; (copy-face 'font-lock-comment-delimiter-face
;; 	   'elisp-font-lock-comment-delimiter-face)

;; (set-face-attribute 'elisp-font-lock-comment-face nil
;;                     :inherit 'variable-pitch)
;; (set-face-attribute 'elisp-font-lock-comment-delimiter-face nil
;;                     :inherit 'variable-pitch)

;; (add-hook
;;  'emacs-lisp-mode-hook
;;  (lambda ()
;;    (set (make-local-variable 'font-lock-comment-face)
;; 	'elisp-font-lock-comment-face)
;;    (set (make-local-variable 'font-lock-comment-delimiter-face)
;; 	'elisp-font-lock-comment-delimiter-face)))
#+end_src

** java

#+begin_src emacs-lisp :tangle yes
;;; Java

(use-package eglot-java
  :hook
  (java-mode . eglot-java-mode)
  :bind
  (:map eglot-java-mode-map
   ("C-c C-l n" . eglot-java-file-new)
   ("C-c C-l x" . eglot-java-run-main)
   ("C-c C-l t" . eglot-java-run-test)
   ("C-c C-l N" . eglot-java-project-new)
   ("C-c C-l T" . eglot-java-project-build-task)
   ("C-c C-l R" . eglot-java-project-build-refresh)))

;; For groovy and gradle support
(use-package groovy-mode :defer t)

;; Viewing Java Class files
(defun javap-handler-real (operation args)
  "Run the real handler without the javap handler installed."
  (let ((inhibit-file-name-handlers
         (cons 'javap-handler
               (and (eq inhibit-file-name-operation operation)
                  inhibit-file-name-handlers)))
        (inhibit-file-name-operation operation))
    (apply operation args)))

(defun javap-handler (op &rest args)
  "Handle .class files by putting the output of javap in the buffer."
  (cond
   ((eq op 'get-file-buffer)
    (let ((file (car args)))
      (with-current-buffer (create-file-buffer file)
        (call-process "javap" nil (current-buffer) nil "-verbose"
                      "-classpath" (file-name-directory file)
                      (file-name-sans-extension (file-name-nondirectory file)))
        (setq buffer-file-name file)
        (setq buffer-read-only t)
        (set-buffer-modified-p nil)
        (goto-char (point-min))
        (java-mode)
        (current-buffer))))
   ((javap-handler-real op args))))

(add-to-list 'file-name-handler-alist '("\\.class$" . javap-handler))
#+end_src

** python

#+begin_src emacs-lisp :tangle yes
;;; Python

;; python.el' provides python-mode' which is the builtin major-mode for the
;; Python language.

(use-package python
  :config
  ;; Remove guess indent python message
  (setq python-indent-guess-indent-offset-verbose nil))

;;<OPTIONAL> I use poetry (https://python-poetry.org/) to manage my python environments.
;; See: https://github.com/galaunay/poetry.el.
;; There are alternatives like https://github.com/jorgenschaefer/pyvenv.
(use-package poetry
  :ensure t
  :defer t
  :config
  ;; Checks for the correct virtualenv. Better strategy IMO because the default
  ;; one is quite slow.
  (setq poetry-tracking-strategy 'switch-buffer)
  :hook (python-mode . poetry-tracking-mode))

;; <OPTIONAL> Buffer formatting on save using black.
;; See: https://github.com/pythonic-emacs/blacken.
(use-package blacken
  :ensure t
  :defer t
  :custom
  (blacken-allow-py36 t)
  (blacken-skip-string-normalization t)
  :hook (python-mode-hook . blacken-mode))

;; <OPTIONAL> Numpy style docstring for Python.  See:
;; https://github.com/douglasdavis/numpydoc.el.  There are other packages
;; available for docstrings, see: https://github.com/naiquevin/sphinx-doc.el
(use-package numpydoc
  :ensure t
  :defer t
  :custom
  (numpydoc-insert-examples-block nil)
  (numpydoc-template-long nil)
  :bind (:map python-mode-map
         ("C-c C-n" . numpydoc-generate)))
#+end_src

** scheme

#+begin_src emacs-lisp :tangle yes
;;
;; --- RACKET ---
;;

(use-package racket-mode
  :mode "\\.rkt\\'"
  :bind
  (:map racket-mode-map
   ("C-c C-r" . racket-run)
   :map racket-repl-mode-map
   ("C-c C-r" . racket-run))
  :config
  (defun setup-racket-eldoc ()
    (eldoc-mode +1)
    (setq eldoc-documentation-function #'racket-xp-eldoc-function))

  (add-hook 'racket-mode-hook      #'racket-unicode-input-method-enable)
  (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)
  (add-hook 'racket-mode-hook      #'setup-racket-eldoc)
  (add-hook 'racket-mode-hook      #'racket-xp-mode))

(use-package dr-racket-like-unicode)
;; (use-package bracketed-paste)

;;
;; --- CHICKEN SCHEME ---
;;

(custom-set-variables '(scheme-program-name "csi -R r7rs"))

(add-to-list 'auto-mode-alist
             '("\\.egg\\'" . scheme-mode))
(add-to-list 'auto-mode-alist
             '("\\.scm\\'" . scheme-mode))
(add-to-list 'auto-mode-alist
             '("\\.sld\\'" . scheme-mode))
(add-hook 'scheme-mode-hook
          (lambda ()
            (setq open-paren-in-column-0-is-defun-start t)))

(defun scheme-module-indent (state indent-point normal-indent) 0)

(defun scheme-indent-hook ()
  (put 'module 'scheme-indent-function 'scheme-module-indent)
  (put 'define-library 'scheme-indent-function 'scheme-module-indent)
  (put 'define-module 'scheme-indent-function 'scheme-module-indent))

(add-hook 'scheme-mode-hook 'scheme-indent-hook)

(use-package geiser
  :hook
  (geiser-mode . (lambda () (geiser-capf-setup nil)))
  (scheme-mode . scheme-super-capf)
  ;; (scheme-mode . cory/run-geiser-p)
  ;; :bind
  ;; (:map geiser-mode-map
  ;;  ("C-c C-d d" . cory/chicken-doc-look-up-manual)
  ;;  ("C-c C-d C-d" . cory/chicken-doc-look-up-manual)
  ;;  ("C-c C-d i" . cory/chicken-doc-look-up-manual)
  ;;  ("C-c C-d TAB" . cory/chicken-doc-look-up-manual))
  :custom
  (geiser-active-implementations '(chicken))
  :config
  (with-eval-after-load 'geiser-mode
    (dolist (bind '("C-c C-d d"
		    "C-c C-d C-d"
		    "C-c C-d i"
		    "C-c C-d TAB"))
      (define-key
	geiser-mode-map
	(kbd bind)
	#'cory/chicken-doc-look-up-manual)))

  (defun scheme-super-capf ()
    (setq-local completion-at-point-functions
		(list (cape-super-capf
		       #'tempel-complete
		       #'geiser-capf--for-filename
		       #'geiser-capf--for-module
		       #'geiser-capf--for-symbol)
		      #'cape-dabbrev
		      #'cape-file)))

  (defun cory/run-geiser-p ()
    "Asks the user whether they want to start the geiser repl or not."
    (when (y-or-n-p "Start geiser repl?")
      (call-interactively 'geiser)))

  (defun cory/chicken-doc-look-up-manual (&optional arg)
    "Look up manual for symbol at point.
With prefix argument, ask for the lookup symbol (with completion)."
    (interactive "P")
    (unless (geiser-doc--manual-available-p)
      (error "No manual available"))
    (let ((symbol (or (and (not arg) (geiser--symbol-at-point))
                     (geiser-completion--read-symbol "Symbol: ")))
	  (current (buffer-name (current-buffer))))
      (eww (concat "http://api.call-cc.org/5/cdoc/?q="
		   (symbol-name symbol)
		   "&query-name=Look+up")
	   t)
      (when (get-buffer "*Chicken Documentation*")
	(kill-buffer "*Chicken Documentation*"))
      (rename-buffer "*Chicken Documentation*")
      (switch-to-buffer current)
      ;; (display-buffer "*Chicken Documentation*")
      (switch-to-buffer-other-window "*Chicken Documentation*"))))

(use-package geiser-chicken
  :after geiser)
#+end_src

** other-langs

#+begin_src emacs-lisp :tangle yes
;;; Latex
;; (use-package latex-preview-pane)

;;; Other Modes
(use-package haskell-mode
  :hook (haskell-mode . haskell-indentation-mode))
#+end_src

* Other

** dired

#+begin_src emacs-lisp :tangle yes
;;
;; --- DIRED ---
;;
(custom-set-variables '(dired-listing-switches "-gho --group-directories-first"))
(custom-set-variables '(dired-dwim-target t))
(custom-set-variables '(delete-by-moving-to-trash t))
;; TODO set `dired-compress-file-alist' to include all archive types

;; Auto refresh buffers
(global-auto-revert-mode 1)

;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)

;; Make M-> and M-< work in dired
(defun dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (dired-next-line 4))

(define-key dired-mode-map
  (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

(defun dired-jump-to-bottom ()
  (interactive)
  (end-of-buffer)
  (dired-next-line -1))

(define-key dired-mode-map
  (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)

;; Use only one dired buffer at a time
;; (use-package dired-single)

;; Open certain file extensions in external programs
(use-package dired-open
  :custom
  (dired-open-extensions '(("mp4" . "mpc-qt")
			   ("mpeg" . "mpc-qt")
			   ("ogg" . "mpc-qt")
			   ("mkv" . "mpc-qt")
			   ("webm" . "mpc-qt")
			   ("mp3" . "strawberry")
			   ("opus" . "strawberry")
			   ("wav" . "strawberry")
			   ("weba" . "strawberry")
			   ("aac" . "strawberry")
			   ("doc" . "libreoffice")
			   ("docx" . "libreoffice")
			   ("odt" . "libreoffice")
			   ("ppt" . "libreoffice")
			   ("pptx" . "libreoffice"))))

;; (use-package dirvish
;;   :config
;;   (dirvish-override-dired-mode))

(use-package sunrise
  :custom
  (sunrise-set-use-commander-keys nil)
  :bind
  ;; NOTE Sunrise uses "C-c s", "C-c t", "C-c r", "C-c v",
  ;; "C-c p", and "C-c b", from the user's space
  (("C-z" . cory/sunrise-toggle)
   :map sunrise-mode-map
   ;; Remap traditional "commander keys" to non-function keys
   ("C-c 2"     . sunrise-goto-dir)
   ("C-c 3"     . sunrise-quick-view)
   ("C-c 4"     . sunrise-advertised-find-file)
   ("C-c 5"     . sunrise-do-copy)
   ("C-c 6"     . sunrise-do-rename)
   ("C-c 7"     . dired-create-directory)
   ("C-c 8"     . sunrise-do-delete)
   ("C-c 0"     . sunrise-quit)
   ("C-c C-3"   . sunrise-sort-by-name)
   ("C-c C-4"   . sunrise-sort-by-extension)
   ("C-c C-5"   . sunrise-sort-by-time)
   ("C-c C-6"   . sunrise-sort-by-size)
   ("C-c C-7"   . sunrise-sort-by-number)
   ("C-c &"     . sunrise-do-symlink)
   ("<insert>"  . sunrise-mark-toggle)
   ("C-<prior>" . sunrise-dired-prev-subdir)
   ;; Remove binds to function keys
   ("<f2>"  . other-window)
   ("<f3>"  . kmacro-start-macro-or-insert-counter)
   ("<f4>"  . kmacro-end-or-call-macro)
   ("<f10>" . menu-bar-open))
  :hook
  ;; (sunrise-mode . hl-line-mode)
  (sunrise-mode . (lambda () (setq-local cursor-type nil)))
  :config
  (set-face-attribute 'hl-line nil :background nil :inherit 'highlight)

  (defun cory/kill-all-sunrise-buffers ()
    (interactive)
    (dolist (buf (buffer-list))
      (with-current-buffer buf
	(if (derived-mode-p 'sunrise-mode)
	    (kill-buffer buf)))))

  ;; TODO
  ;; (defun cory/kill-all-duplicate-sunrise-buffers ()
  ;;   (interactive))

  (defun cory/sunrise-toggle ()
    "Show or hide the Sunrise Commander."
    (interactive)
    (or (sunrise-quit)
       (if (and ;; (boundp 'sunrise-left-buffer)
	   ;; (boundp 'sunrise-right-buffer)
	   (buffer-live-p sunrise-left-buffer)
	   (buffer-live-p sunrise-right-buffer))
	   (cory/sunrise-show)
	 (sunrise-show))))

  (defun cory/sunrise-show ()
    "Ensure the Sunrise Commander is shown with the past two active buffers."
    (interactive)
    (message "Starting Sunrise Commander...")
    (let ((msg nil))
      (when (cory/sunrise-ensure-windows
             (selected-frame)
             sunrise-left-buffer
             sunrise-right-buffer)
	(setq msg sunrise-start-message))
      (setq sunrise-this-directory default-directory)
      (sunrise-highlight)  ; W32Emacs needs this.
      (hl-line-mode 1)
      (message "%s" msg)))

  (defun cory/sunrise-ensure-windows (frame left-buffer right-buffer)
    "Set up the Sunrise window configuration (two windows in `sunrise-mode').

LEFT-DIRECTORY and RIGHT-DIRECTORY, if non-nil, are the directories to show."
    (cl-destructuring-bind (a-window b-window view-window)
	(sunrise--analyze-frame frame)
      (let ((existing-layout-p (and a-window b-window view-window)))
	(unless existing-layout-p
          (sunrise-switch-to-nonpane-buffer)
          (sunrise--set-frame-plist
           frame
           'restore-config (current-window-configuration)
           'restore-buffer (current-buffer)
           'current-frame  frame)
          (run-hooks 'sunrise-init-hook)
          (sunrise-select-viewer-window)
          (delete-other-windows)
          (unless (and sunrise-panes-height
                     (< sunrise-panes-height (frame-height)))
            (setq sunrise-panes-height (sunrise-get-panes-size)))
          (when (and (<= sunrise-panes-height (* 2 window-min-height))
                   (eq sunrise-window-split-style 'vertical))
            (setq sunrise-panes-height (* 2 window-min-height)))
          (let ((root (selected-window)))
            (setq view-window (split-window root sunrise-panes-height))
            (setq a-window (selected-window))
            (cl-ecase sunrise-window-split-style
              (horizontal
               (setq b-window (split-window-horizontally)))
              (vertical
               (setq b-window (split-window-vertically)))
              (top
               (ignore))))

          (set-window-buffer a-window left-buffer)
          (set-window-buffer b-window right-buffer)

          (if (buffer-live-p other-window-scroll-buffer)
              (switch-to-buffer other-window-scroll-buffer)
            (sunrise-switch-to-nonpane-buffer))))

      ;; (sunrise--update-frame-plist
      ;;  frame
      ;;  'a-directory (lambda (old-directory) (or a-directory old-directory))
      ;;  'b-directory (lambda (old-directory) (or b-directory old-directory)))

      ;; (when a-window (sunrise--setup-directory-window a-directory a-window))
      ;; (when b-window (sunrise--setup-directory-window b-directory b-window))
      (sunrise-restore-panes-width)
      (run-hooks 'sunrise-start-hook)))

  )
#+end_src

** nixos

#+begin_src emacs-lisp :tangle yes
;;
;; --- NIXOS ---
;;

(use-package nix-mode
  :mode "\\.nix\\'"
  :hook
  (nix-mode . subword-mode)
  (nix-mode . nix-prettify-mode))

(defvar cory/nixos-config-location "/home/cory/.config/nix")

(defun cory/nixos-flake-rebuild ()
  "Rebuilds a NixOS system."
  (interactive)
  (async-shell-command
   (concat "nixos-rebuild switch --flake "
	   cory/nixos-config-location
	   "#"
	   (completing-read "System name:" '("pc" "laptop"))
	   " --use-remote-sudo")))

(defun cory/nix-collect-garbage ()
  "Collects the garbage made by the Nix package manager."
  (interactive)
  (async-shell-command
   (concat "sudo nix-collect-garbage --delete-older-than "
	   (let ((time (completing-read "Delete files older than:" '("7 days" "3 days" "1 day"))))
	     (cond
	      ((string= time "7 days") "7d")
	      ((string= time "3 days") "3d")
	      ((string= time "1 day") "1d")
	      (t (error "Not a valid time")))))))

(global-set-key (kbd "C-c n") #'cory/nixos-flake-rebuild)
(global-set-key (kbd "C-c N") #'cory/nix-collect-garbage)

;; ;; This package adds a significant amount of time to emacs startup
;; (use-package nixos-options
;;   :config
;;   ;; FIXME the first completing-read returns a string, not the list item we want
;;   (defun cory/nixos-options ()
;;     (interactive)
;;     (let* ((opt (completing-read "NixOS Options:" nixos-options))
;; 	   (act (completing-read opt
;; 				 '("View documentation"
;; 				   "Insert into buffer"
;; 				   "Show the description"
;; 				   "Copy"))))
;;       (cond
;;        ((string-equal act "View documentation")
;; 	(let ((buf (get-buffer-create "*nixos-options-doc*")))
;; 	  (with-current-buffer buf
;; 	    (view-mode -1)
;; 	    (erase-buffer)
;; 	    (insert (nixos-options-get-documentation-for-option opt))
;; 	    (goto-char (point-min))
;; 	    (view-mode 1))
;; 	  (switch-to-buffer-other-window buf)))
;;        ((string-equal act "Insert into buffer")
;; 	(insert (nixos-options-get-name opt)))
;;        ((string-equal act "Show the description")
;; 	(let ((buf (get-buffer-create "*nixos-options-doc*")))
;; 	  (with-current-buffer buf
;; 	    (view-mode -1)
;; 	    (erase-buffer)
;; 	    (insert (message (format
;; 			      "%s: %s"
;; 			      (car opt)
;; 			      (nixos-options-get-description opt))))
;; 	    (goto-char (point-min))
;; 	    (view-mode 1))
;; 	  (switch-to-buffer-other-window buf)))
;;        ((string-equal act "Copy")
;; 	(kill-new (nixos-options-get-name opt)))))))
#+end_src

** org

#+begin_src emacs-lisp :tangle yes
;;
;; --- ORG MODE ---
;;

(use-package org
  :defer
  :hook
  (org-mode . (lambda ()
		(org-indent-mode)
		;; (variable-pitch-mode) ; font
		;; (auto-fill-mode) ; line breaking
		(visual-line-mode)))

  (org-mode . (lambda () (interactive)
                (setq prettify-symbols-alist '(("[#A]" . " ")
                                               ("[#B]" . " ")
                                               ("[#C]" . " ")
                                               ("[ ]" . " ")
                                               ("[X]" . " ")
                                               ("[-]" . " ")
                                               ("#+begin_src" . " ")
                                               ("#+end_src" . "―")
                                               ("#+begin_collapsible" . " ")
                                               ("#+end_collapsible" . "―")
                                               ("#+begin_aside" . " ")
                                               ("#+end_aside" . "―")
                                               ("#+begin_quote" . " ")
                                               ("#+end_quote" . "―")
                                               ("#+begin_defn" .  " ")
                                               ("#+end_defn" . "―")
                                               ("#+begin_questionable" .  " ")
                                               ("#+end_questionable" . "―")
                                               ("#+begin_problem" .  " ")
                                               ("#+end_problem" . "―")
                                               ("#+EXCLUDE_TAGS:" . " ")
                                               (":PROPERTIES:" . "\n")
                                               (":END:" . "―")
                                               ("#+STARTUP:" . " ")
                                               ("#+TITLE: " . "")
                                               ("#+title: " . "")
                                               ("#+RESULTS:" . " ")
                                               ("#+NAME:" . " ")
                                               ("#+ROAM_TAGS:" . " ")
                                               ("#+FILETAGS:" . " ")
                                               ("#+HTML_HEAD:" . " ")
                                               ("#+SUBTITLE:" . " ")
                                               ("#+AUTHOR:" . " ")
                                               (":Effort:" . " ")
                                               ("SCHEDULED:" . " ")
                                               ("DEADLINE:" . " ")
                                               ("#+begin_defn" . " ")
                                               ("#+end_defn" . "―")))
                (prettify-symbols-mode)))

  :bind
  (("C-c o a" . org-agenda-list)
   ("C-c o A" . org-agenda)
   ("C-c o g" . consult-org-agenda)
   ("C-c o c" . org-capture)
   ("C-c o r" . org-refile))

  :custom
  (org-ellipsis " ▼")
  (org-hide-emphasis-markers t)
  (org-agenda-files '("~/Code/Org/Tasks.org"
		      "~/Code/Org/School.org"
		      "~/Code/Org/Homework.org"))
  (org-agenda-start-with-log-mode t)
  (org-agenda-start-on-weekday nil)
  (org-log-done 'time)
  (org-log-into-drawer t)
  (org-pretty-entities t)
  (org-startup-with-inline-images t)
  (org-image-actual-width nil)
  (org-return-follows-link t)
  (org-latex-compiler "lualatex")
  (org-preview-latex-default-process 'dvisvgm)
  (org-latex-pdf-process
   '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
  (org-agenda-current-time-string "← now ----------")
  (org-agenda-timegrid-use-ampm 1) ;; 12-hour clock
  (org-src-fontify-natively t)
  (org-src-tab-acts-natively t)
  (org-edit-src-content-indentation 0)
  (org-todo-keywords
   '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
     (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))
  (org-refile-targets
   '(("Archive.org" :maxlevel . 1)
     ("Tasks.org" :maxlevel . 1)))
  (org-tag-alist
   '((:startgroup)
     ;; Put mutually exclusive tags here
     (:endgroup)
     ("@errand" . ?E)
     ("@home" . ?H)
     ("@work" . ?W)
     ("agenda" . ?a)
     ("planning" . ?p)
     ("publish" . ?P)
     ("batch" . ?b)
     ("note" . ?n)
     ("idea" . ?i)))

  ;; Configure custom agenda views
  (org-agenda-custom-commands
   '(("d" "Dashboard"
      ((agenda "" ((org-deadline-warning-days 7)))
       (todo "NEXT"
	     ((org-agenda-overriding-header "Next Tasks")))
       (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

     ("n" "Next Tasks"
      ((todo "NEXT"
	     ((org-agenda-overriding-header "Next Tasks")))))

     ("W" "Work Tasks" tags-todo "+work")

     ;; Low-effort next actions
     ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
      ((org-agenda-overriding-header "Low Effort Tasks")
       (org-agenda-max-todos 20)
       (org-agenda-files org-agenda-files)))

     ("w" "Workflow Status"
      ((todo "WAIT"
	     ((org-agenda-overriding-header "Waiting on External")
	      (org-agenda-files org-agenda-files)))
       (todo "REVIEW"
	     ((org-agenda-overriding-header "In Review")
	      (org-agenda-files org-agenda-files)))
       (todo "PLAN"
	     ((org-agenda-overriding-header "In Planning")
	      (org-agenda-todo-list-sublevels nil)
	      (org-agenda-files org-agenda-files)))
       (todo "BACKLOG"
	     ((org-agenda-overriding-header "Project Backlog")
	      (org-agenda-todo-list-sublevels nil)
	      (org-agenda-files org-agenda-files)))
       (todo "READY"
	     ((org-agenda-overriding-header "Ready for Work")
	      (org-agenda-files org-agenda-files)))
       (todo "ACTIVE"
	     ((org-agenda-overriding-header "Active Projects")
	      (org-agenda-files org-agenda-files)))
       (todo "COMPLETED"
	     ((org-agenda-overriding-header "Completed Projects")
	      (org-agenda-files org-agenda-files)))
       (todo "CANC"
	     ((org-agenda-overriding-header "Cancelled Projects")
	      (org-agenda-files org-agenda-files)))))))

  (org-capture-templates
   `(("t" "Tasks / Projects")
     ("tt" "Task" entry (file+olp "~/Code/Org/Tasks.org" "Inbox")
      "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

     ("j" "Journal Entries")
     ("jj" "Journal" entry
      (file+olp+datetree "~/Code/Org/Journal.org")
      "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
      ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
      :clock-in :clock-resume
      :empty-lines 1)
     ("jm" "Meeting" entry
      (file+olp+datetree "~/Code/Org/Journal.org")
      "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
      :clock-in :clock-resume
      :empty-lines 1)

     ("w" "Workflows")
     ("we" "Checking Email" entry (file+olp+datetree "~/Code/Org/Journal.org")
      "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

     ("m" "Metrics Capture")
     ("mw" "Weight" table-line (file+headline "~/Code/Org/Metrics.org" "Weight")
      "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))

  :config
  ;; Replace list hyphen with dot
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  ;; (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  ;; (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  ;; (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
  ;; ;; (set-face-attribute 'org-indent nil   :inherit '(org-hide fixed-pitch))
  ;; (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  ;; (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  ;; (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  ;; (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

  ;; Save Org buffers after refiling
  (advice-add 'org-refile :after 'org-save-all-org-buffers))

(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

;; Drag and drop
(use-package org-download
  :commands (org-mode org-download-clipboard)
  :custom
  (org-download-screenshot-method "sleep 1 && flameshot gui -s --raw > %s")
  :bind ("C-c o s" . org-download-screenshot))

;; Org roam
(use-package org-roam
  :ensure t
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/Code/Org/Roam")
  (org-roam-complete-everywhere t)
  (org-roam-capture-templates
   `(("d" "default" plain "%?"
      :if-new (file+head
	       "%<%Y%m%d%H%M%S>-${slug}.org"
	       ,(let ((options '("#+options: _:{}"
				 "#+options: ^:{}"
				 "#+startup: latexpreview"
				 "#+startup: entitiespretty"
				 "#+startup: inlineimages"
				 "#+title: ${title}"
				 "#+date: %U")))
		  (mapconcat 'identity options "\n")))
      :unnarrowed t)))
  :bind (("C-c o n l" . org-roam-buffer-toggle)
	 ("C-c o n f" . org-roam-node-find)
	 ("C-c o n i" . org-roam-node-insert)
	 :map org-mode-map
	 ("C-M-i" . completion-at-point))
  :config
  (org-roam-setup))

;; Writing
(use-package writegood-mode
  :hook (flyspell-mode . writegood-mode)
  :bind (:map flyspell-mode-map
	 ("C-c C-g g" . writegood-grade-level)
	 ("C-c C-g e" . writegood-reading-ease)))

(use-package dictionary)

;; Spelling
(dolist (hook '(text-mode-hook))
  (add-hook hook (lambda () (flyspell-mode 1))))
(dolist (hook '(change-log-mode-hook log-edit-mode-hook))
  (add-hook hook (lambda () (flyspell-mode -1))))

(use-package flyspell-correct
  :after flyspell
  :init
  (add-to-list 'ispell-skip-region-alist '("+begin_src" . "+end_src"))
  (setq flyspell-use-meta-tab nil)
  :bind (:map flyspell-mode-map ("C-\"" . flyspell-correct-wrapper)))

(use-package frog-menu
  :custom
  ;; Need to redefine keys to account for custom keyboard layout
  (frog-menu-avy-keys (append (string-to-list "atenisubopyflmc")
			      (string-to-list (upcase "atenisubopyflmc"))
			      (number-sequence ?, ?@)))
  :config
  (defun frog-menu-flyspell-correct (candidates word)
    "Run `frog-menu-read' for the given CANDIDATES.

List of CANDIDATES is given by flyspell for the WORD.

Return selected word to use as a replacement or a tuple
of (command . word) to be used by `flyspell-do-correct'."
    (let* ((corrects (if flyspell-sort-corrections
			 (sort candidates 'string<)
                       candidates))
           (actions `(("C-s" "Save word"         (save    . ,word))
                      ("C-a" "Accept (session)"  (session . ,word))
                      ("C-b" "Accept (buffer)"   (buffer  . ,word))
                      ("C-c" "Skip"              (skip    . ,word))))
           (prompt   (format "Dictionary: [%s]"  (or ispell-local-dictionary
                                                    ispell-dictionary
                                                    "default")))
           (res      (frog-menu-read prompt corrects actions)))
      (unless res
	(error "Quit"))
      res))

  (setq flyspell-correct-interface #'frog-menu-flyspell-correct))
#+end_src

** pdf

#+begin_src emacs-lisp :tangle yes
;; PDFs
(use-package pdf-tools
  :ensure t
  :defer t
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :config
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
	TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view))
	TeX-source-correlate-start-server t)
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)

  ;; open pdfs scaled to fit page
  (setq-default pdf-view-display-size 'fit-page)
  ;; automatically annotate highlights
  (setq pdf-annot-activate-created-annotations t)
  ;; use normal isearch
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  ;; turn off cua so copy works
  (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0)))
  ;; more fine-grained zooming
  (setq pdf-view-resize-factor 1.1)
  ;; keyboard shortcuts
  (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
  (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
  (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete))
#+end_src

* Window Management

** window-management

#+begin_src emacs-lisp :tangle yes
;;
;; --- WINDOW MANAGEMENT
;;

(setq focus-follows-mouse t
      mouse-autoselect-window t)

(defun split-and-follow-below ()
  "Open a new window vertically."
  (interactive)
  (split-window-below)
  (other-window 1)
  (consult-buffer))

(defun split-and-follow-right ()
  "Open a new window horizontally."
  (interactive)
  (split-window-right)
  (other-window 1)
  (consult-buffer))

(defun kill-all-buffers-and-windows ()
  "Kill all buffers and windows."
  (interactive)
  (when (yes-or-no-p "Really kill all buffers and windows? ")
    (save-some-buffers)
    (mapc 'kill-buffer (buffer-list))
    (delete-other-windows)))

(defun previous-window ()
  "Reverse direction of `other-window'."
  (other-window -1))

(defun cory/last-real-buffer (buffers)
  (if buffers
      (let ((name (buffer-name (car buffers))))
	(if (and (equal name (string-trim name "[ \*]+" "\*"))
	      (not (equal "Sunrise" (string-trim name ".*(" ").*"))))
	    (car buffers)
	  (cory/last-real-buffer (cdr buffers))))
    nil))

(defun cory/toggle-last-buffer ()
  (interactive)
  (switch-to-buffer (cory/last-real-buffer (cdr (buffer-list)))))

(defun rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* (
                  (w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2))
                  )
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))

(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                    (car next-win-edges))
                                 (<= (cadr this-win-edges)
                                    (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                    (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(global-set-key (kbd "C-x 0") 'delete-window)
(global-set-key (kbd "C-x 1") 'delete-other-windows)
(global-set-key (kbd "C-x 2") 'split-and-follow-below)
(global-set-key (kbd "C-x 3") 'split-and-follow-right)
(global-set-key (kbd "C-x 4 q") 'kill-all-buffers-and-windows)
;; (global-set-key (kbd "C-c b") 'balance-windows)
(global-set-key (kbd "<f1>") 'cory/toggle-last-buffer)
(global-set-key (kbd "C-<f1>") 'cory/toggle-last-buffer)
(global-set-key (kbd "M-<f1>") 'cory/toggle-last-buffer)
(global-set-key (kbd "C-M-<f1>") 'cory/toggle-last-buffer)
(global-set-key (kbd "<f2>") 'other-window)
(global-set-key (kbd "C-<f2>") 'other-window)
(global-set-key (kbd "M-<f2>") 'other-window)
(global-set-key (kbd "C-M-<f2>") 'other-window)

(use-package yequake
  :custom
  (yequake-frames
   '(("eshell"
      (width . 0.5)
      (height . 0.5)
      (left . 0.5)
      (top . 0.5)
      (alpha . 0.7)
      (buffer-fns . ("*eshell*<1>"))
      (frame-parameters . ((undecorated . t))))
     ("org-capture"
      (width . 0.75)
      (height . 0.5)
      (alpha . 0.7)
      (buffer-fns . (yequake-org-capture))
      (frame-parameters . ((undecorated . t)
                           (skip-taskbar . t)
                           (sticky . t)))))))

;; Popups
;; (use-package popper
;;   :ensure t
;;   :custom
;;   (popper-reference-buffers
;;    '("\\*Messages\\*"
;;      "Output\\*$"
;;      "\\*Async Shell Command\\*"
;;      "\\*eldoc\\*"
;;      "\\*Ibuffer\\*"
;;      "\\*vc-git"
;;      "\\*Help\\*"
;;      "\\*Compile-Log\\*"
;;      "\\*Warnings\\*"
;;      "\\*Chicken Documentation\\*"
;;      geiser-repl-mode
;;      flymake-diagnostics-buffer-mode
;;      calendar-mode
;;      help-mode
;;      compilation-mode
;;      eshell-mode
;;      vterm-mode))
;;   ;; (popper-group-function #'popper-group-by-project) ; project.el projects
;;   (popper-window-height (lambda (win)
;; 			  (fit-window-to-buffer
;; 			   win
;; 			   (frame-height)
;; 			   30)))
;;   :config
;;   (popper-mode)
;;   ;; (popper-echo-mode)

;;   ;; (defvar popper-dedicated-term nil)

;;   ;; (defun popper-open-dedicated-term ()
;;   ;;   (unless popper-mode (user-error "Popper-mode not active!"))
;;   ;;   (unless (and popper-dedicated-term (buffer-live-p popper-dedicated-term))
;;   ;;     (let ((current (buffer-name (current-buffer))))
;;   ;; 	(eshell t)
;;   ;; 	(rename-buffer "*popper-dedicated-term*")
;;   ;; 	(setq popper-dedicated-term (current-buffer))
;;   ;; 	(switch-to-buffer current)))
;;   ;;   (display-buffer "*popper-dedicated-term*")
;;   ;;   (with-current-buffer "*popper-dedicated-term*"
;;   ;;     (run-hooks 'popper-open-popup-hook)))

;;   ;; (defun popper-toggle-dedicated-term ()
;;   ;;   (interactive)
;;   ;;   (if popper-open-popup-alist
;;   ;; 	(popper-close-latest)
;;   ;;     (popper-open-dedicated-term)))

;;   ;; (defun cory/remove-buried-popup-buffer ()
;;   ;;   ""
;;   ;;   (dolist (p1 popper-buried-popup-alist)
;;   ;;     (dolist (p2 (cdr p1))
;;   ;; 	(when (string=
;;   ;; 	       "*popper-dedicated-term*"
;;   ;; 	       (buffer-name (cdr p2)))
;;   ;; 	  (delete p2 (cdr p1))))))

;;   ;; (defun cory/popper-display-in-posframe (buf _)
;;   ;;   (when (posframe-workable-p)
;;   ;;     (posframe-show buf
;;   ;;                    :position t
;;   ;;                    :poshandler #'posframe-poshandler-frame-center
;;   ;;                    :width 150
;;   ;;                    :height 40
;;   ;;                    :border-width 1
;;   ;;                    :border-color "#141404")))

;;   ;; (setq popper-display-function #'cory/popper-display-in-posframe)

;;   :bind
;;   (("C-`" . popper-toggle-latest)
;;    ("C-~" . popper-toggle-type)
;;    ("M-`" . popper-cycle)))

;; (use-package popper
;;   :bind
;;   (("C-`" . popper-toggle-latest)
;;    ("C-~" . popper-toggle-type)
;;    ("M-`" . popper-cycle))
;;   :custom
;;   (popper-reference-buffers '(eshell-mode))
;;   (popper-window-height 40)
;;   :config
;;   ;; Override `popper-open-latest'
;;   (defun popper-open-latest (&optional group)
;;     "Open the last closed popup.

;; Optional argument GROUP is called with no arguments to select
;; a popup buffer to open."
;;     (unless popper-mode (user-error "Popper-mode not active!"))
;;     (let* ((identifier (when popper-group-function group))
;;            (no-popup-msg (format "No buried popups for group %s"
;;                                  (if (symbolp identifier)
;;                                      (symbol-name identifier)
;;                                    identifier))))
;;       (if (null (alist-get identifier popper-buried-popup-alist
;;                           nil 'remove 'equal))
;;           (progn
;; 	    (eshell)
;; 	    (setq aweshell-dedicated-buffer (current-buffer))
;; 	    (previous-buffer)
;; 	    (display-buffer aweshell-dedicated-buffer)
;; 	    (with-current-buffer aweshell-dedicated-buffer
;; 	      (run-hooks 'popper-open-popup-hook))
;; 	    (push (cons (selected-window) aweshell-dedicated-buffer) popper-open-popup-alist))
;; 	(if-let* ((new-popup (pop (alist-get identifier popper-buried-popup-alist
;;                                              nil 'remove 'equal)))
;;                   (buf (cdr new-popup)))
;;             (if (not (buffer-live-p buf))
;; 		(popper-open-latest)
;; 	      (display-buffer buf)
;; 	      (with-current-buffer buf
;; 		(run-hooks 'popper-open-popup-hook)))
;;           (message no-popup-msg)))))

;;   (defun cory/popper-display-in-posframe (buf _)
;;     (when (posframe-workable-p)
;;       (posframe-show buf
;;                      :position t
;;                      :poshandler #'posframe-poshandler-frame-center
;;                      :width 150
;;                      :height 40
;;                      :border-width 1
;;                      :border-color "#141404")))

;;   (setq popper-display-function #'cory/popper-display-in-posframe)
;;   (popper-mode))

;; Workspaces
(use-package eyebrowse
  :diminish eyebrowse-mode
  :config (progn
            (define-key eyebrowse-mode-map (kbd "M-1") 'eyebrowse-switch-to-window-config-1)
            (define-key eyebrowse-mode-map (kbd "M-2") 'eyebrowse-switch-to-window-config-2)
            (define-key eyebrowse-mode-map (kbd "M-3") 'eyebrowse-switch-to-window-config-3)
            (define-key eyebrowse-mode-map (kbd "M-4") 'eyebrowse-switch-to-window-config-4)
            (eyebrowse-mode t)
            (setq eyebrowse-new-workspace t)))

;; ;; Sidebar (Project Explorer)
;; (use-package dired-sidebar :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
;;   :ensure t
;;   :commands (dired-sidebar-toggle-sidebar)
;;   :init
;;   (add-hook 'dired-sidebar-mode-hook
;;             (lambda ()
;;               (unless (file-remote-p default-directory)
;;                 (auto-revert-mode))))
;;   :custom
;;   (dired-sidebar-subtree-line-prefix "   ")
;;   (dired-sidebar-theme 'nerd)
;;   (dired-sidebar-use-term-integration t)
;;   (dired-sidebar-use-custom-font t)
;;   :config
;;   (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
;;   (push 'rotate-windows dired-sidebar-toggle-hidden-commands)
;;   (set-face-attribute 'dired-sidebar-face nil :inherit 'variable-pitch))
#+end_src

** aside

#+begin_src emacs-lisp :tangle yes
;;; aside.el --- Toggle-able side windows -*- lexical-binding: t -*-

;; Copyright 2021 Matt Beshara

;; Author: Matt Beshara <m@mfa.pw>
;; URL: https://git.sr.ht/~mfa/aside
;; Version: 2.6.8
;; Package-Requires: ((emacs "27.1") (dash "2.19.1"))
;; Keywords: convenience

;; This file is NOT part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
;; more details.
;;
;; You should have received a copy of the GNU General Public License along
;; with this program.  If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; The code in this package makes it straightforward to configure side windows
;; which display specific buffers, and commands which can toggle the
;; visibility of those windows.  The function of most interest here is
;; probably ‘aside-window-toggle-dwim’.  This function returns a closure which
;; can be used to toggle the visibility of specific buffers in a specific
;; window, as well as to jump directly to that window if it is already
;; visible.  There are two uses for this code in particular which I find
;; indispensable.  One is the Context configuration, defined in
;; ‘aside-configurations.el’.  The other is the Vterm configuration, which is
;; too complex to be defined entirely by the ‘aside-define-configuration’
;; macro alone.  That configuration is defined in ‘aside-vterm.el’.

;; Here is some more information on how ‘aside-window-toggle-dwim’ works which
;; was too large to put into its docstring:

;; After a matcher closure has been derived from BUFFER-MATCHER, the matcher
;; is used to try to find a matching buffer from ‘buffer-list’, and a window
;; from ‘window-list’ which is currently displaying a matching buffer.

;; When neither a matching buffer or window are found, BUFFER-CREATOR is
;; called, if a value for that argument was supplied.  If a matching buffer
;; was found, but there is no window displaying it, then that buffer will be
;; displayed, and its window selected (unless the command was given a prefix
;; argument).  If the matching buffer is the current buffer (i.e. the buffer
;; visible in the selected window) then the window is deleted.  Otherwise, the
;; matching window , which must already be displaying the buffer, is selected
;; (or deleted, if the command was given a prefix argument).

;; Note that even if both a matching buffer and matching window are found, the
;; buffer displayed in the window might not be the same as the buffer found
;; from searching ‘buffer-list’.  That these values are allowed to be
;; different is a good thing for consistent behaviour.  Specifically, this
;; means that if the function is called while the side window is selected, it
;; will always cause the side window to close, even if the side window could
;; have any one of multiple different buffers visible.  If the logic was
;; modified such that the buffer displayed in the side window had to be the
;; same buffer as the buffer found when searching ‘buffer-list’, then whether
;; the side window was hidden or not when this function was called would
;; depend not only on if the side window was selected, but also which buffer
;; the side window was displaying.  In my experience, this was even more
;; confusing than this attempt at an explanation makes it sound.


;;; Code:

(require 'dash)

;; Symbol builders

(defun aside--condition-var-name (sym)
  "Use SYM to generate a variable name ending with CONDITION."
  (intern (format "aside-%s-condition" sym)))

(defun aside--action-alist-var-name (sym)
  "Use SYM to generate a variable name ending with ACTION-ALIST."
  (intern (format "aside-%s-action-alist" sym)))

(defun aside--display-buffer-function-name (sym)
  "Use SYM to generate a variable name ending with DISPLAY-BUFFER."
  (intern (format "aside--%s-display-buffer" sym)))

(defun aside--hook-var-name (sym)
  "Use SYM to generate a variable name ending with HOOK."
  (intern (format "aside-%s-hook" sym)))

(defun aside--hook-run-var-name (sym)
  "Use SYM to generate a variable name ending with HOOK-RUN."
  (intern (format "aside--%s-hook-run" sym)))

(defun aside--configuration-id-from-var-name (sym)
  "Use SYM to generate a symbol from first word after hyphen."
  (intern (elt (split-string (symbol-name sym) "-") 1)))

(defun aside--group-var-name (sym)
  "Use SYM to generate a variable name for a Customize group."
  (intern (format "aside-%s" sym)))

(defun aside--dwim-func-name (sym)
  "Use SYM to generate a function name ending with ‘-dwim’."
  (intern (format "aside-%s-dwim" sym)))


;; Buffer and window matching

(defun aside--buffer-name-matcher (regexp)
  "Return closure that matches REGEXP against BUFFER name."
  (lambda (buffer)
    (string-match regexp (buffer-name buffer))))

(defun aside--matcher (thing)
  "Return closure for matching buffers, derived from THING.
If THING is a function, that function is returned.  If THING is a
string, it is assumed to be a regexp, and a closure which uses
that regexp to match the names of buffers is returned.  If THING
is a symbol, an attempt is made to generate a variable name from
it and its value is used in a recursive call."
  (cond ((symbolp thing)
         ;; Check if it’s a symbol first, before checking it’s a function,
         ;; because ‘functionp’ will return t when passed a symbol which a
         ;; function is bound to.
         (if-let ((var-name (aside--condition-var-name thing))
                  (value (ignore-errors (symbol-value var-name))))
             (aside--matcher value)
           (error "No value for symbol ‘%s’" var-name)))
        ((functionp thing)
         thing)
        ((stringp thing)
         (aside--buffer-name-matcher thing))
        (t
         (error "Unhandled THING type ‘%s’" thing))))

(defun aside--find-buffer-matching (matcher)
  "Return some buffer MATCHER returns non-nil for."
  (seq-some (lambda (buffer)
              (and (funcall matcher buffer)
                   buffer))
            (buffer-list)))

(defun aside--find-window-with-buffer-matching (matcher)
  "Return window displaying buffer MATCHER returns non-nil for."
  (seq-some (lambda (win)
              (and (funcall matcher (window-buffer win))
                 win))
            (window-list)))


;;; Configuration definition

(defun aside--configuration-display-buffer-alist (id)
  "Return ‘display-buffer-alist’ display options for ID."
  (when-let ((condition-var (aside--condition-var-name id))
             (condition (ignore-errors (symbol-value condition-var)))
             (action-alist-var (aside--action-alist-var-name id))
             (action-alist (ignore-errors (symbol-value action-alist-var)))
             (display-buffer (aside--display-buffer-function-name id)))
    `(,condition (,display-buffer) ,@action-alist)))

(defun aside--define-buffer-display-function (id)
  "Define a buffer display function for ID.

The function first defines a couple of variables, one to act as a
hook for a specific configuration, the other to track which
buffers the hook has been run in.  Then, it defines a function
which calls ‘display-buffer-in-side-window’) and then runs the
appropriate configuration’s hook if necessary."
  (let ((hook-var-name (aside--hook-var-name id))
        (hook-run-var-name (aside--hook-run-var-name id))
        (display-buffer-func-name (aside--display-buffer-function-name id)))
    (set hook-run-var-name nil)
    (make-local-variable hook-run-var-name)
    (fset display-buffer-func-name
          (lambda (buffer alist)
            (display-buffer-in-side-window buffer alist)
            (with-current-buffer buffer
              (unless (symbol-value hook-run-var-name)
                ;; This formerly used ‘set-local’
                (eval `(setq-local ,hook-run-var-name t))
                (run-hooks hook-var-name)))))))

(defun aside-enable-configuration (id)
  "Enable a configuration specified by ID.
If an ‘equal’ list is not already present in
‘display-buffer-alist’, this function pushes a list composed of
‘aside-<id>-condition’ and ‘aside-<id>-action-alist’ to it.  It
also calls ‘aside--define-buffer-display-function’ to define a
buffer display function which runs a hook specific to the
configuration specified by ID when the buffer is displayed."
  (aside--define-buffer-display-function id)
  (add-to-list 'display-buffer-alist
               (aside--configuration-display-buffer-alist id)))

(defun aside-configuration-enabled-p (id)
  "Return non-nil if a configuration with ID is enabled.
If non-nil, the return value will be the result of calling
‘aside--configuration-display-buffer-alist’ with ID."
  (member (aside--configuration-display-buffer-alist id)
          display-buffer-alist))

(defun aside-disable-configuration (id)
  "Disable a configuration specified by ID if one is enabled.
If a configuration with the given ID is not enabled, nil is
returned, otherwise the return value is the list removed from
‘display-buffer-alist’, composed of ‘aside-<id>-condition’ and
‘aside-<id>-action-alist’."
  (when (aside-configuration-enabled-p id)
    (setq display-buffer-alist
          (delete (aside--configuration-display-buffer-alist id)
                  display-buffer-alist))))

(defun aside-configuration-setter-function (name value)
  "Set customizable option NAME to VALUE.
This function first checks if there is already an enabled
configuration corresponding to NAME, and if there is, it will
disable the old configuration before setting the new value, and
then enabling a new configuration which uses the new value.  If a
matching configuration is not already enabled, all that happens is
that the variable NAME is ‘set’ to VALUE."
  (let ((configuration-id (aside--configuration-id-from-var-name name)))
    (if (aside-disable-configuration configuration-id)
        (progn
          (set name value)
          (aside-enable-configuration configuration-id))
      (set name value))))


;; Hook functions

(defun aside-hook-enable-truncate-lines ()
  "Enables line truncation, without displaying a message about it."
  (let ((inhibit-message t))
    (toggle-truncate-lines 1)))

(defun aside-hook-disable-display-line-numbers-mode ()
  "Call command ‘display-line-numbers-mode’ to disable line numbers."
  (when (fboundp 'display-line-numbers-mode)
    (display-line-numbers-mode -1)))

(defun aside-hook-change-default-face-pitch ()
  "Make the default face inherit from ‘variable-pitch’."
  (face-remap-add-relative 'default :inherit 'variable-pitch))

(defgroup aside ()
  "Options for Aside side windows."
  :group 'convenience)

(defcustom aside-face-height 120
  "The default face height to use in buffers in a side window.
Used in ‘aside-hook-change-default-face-height’."
  :group 'aside
  :type 'integer)

(defun aside-hook-change-default-face-height ()
  "Change the height of the default face in the current buffer."
  (face-remap-add-relative 'default :height aside-face-height))

(defcustom aside-ace-window-push t
  "When non-nil, enable support for ‘aw-flip-window’.
This is done by calling ‘aw--push-window’ before switching to a
different window."
  :group 'aside
  :type 'boolean)


;; Avoiding Aside-managed buffers in non-Aside-managed windows

(defun aside--display-buffer-alist-elements ()
  "Return alist elements which use Aside display functions."
  (seq-filter (lambda (element)
                (string-match "^aside--"
                              (symbol-name (caadr element))))
              display-buffer-alist))

(defun aside--window-p (window)
  "Return a non-nil value if WINDOW is managed by Aside."
  (let* ((params (window-parameters window))
         (side (alist-get 'window-side params))
         (slot (alist-get 'window-slot params)))
    (seq-find 'identity
              (mapcar
               (lambda (alist)
                 (and (equal side (alist-get 'side alist))
                      (equal slot (or (alist-get 'slot alist) 0))))
               (mapcar 'cddr
                       (aside--display-buffer-alist-elements))))))

(defun aside--buffer-p (buffer)
  "Return a non-nil value if BUFFER is managed by Aside.
Presence of a buffer-local var beginning with ‘aside--’
is used to determine this."
  (with-current-buffer buffer
    (seq-filter (lambda (binding)
                  (string-match "^aside--" (symbol-name (if (listp binding)
                                                            (car binding)
                                                          binding))))
                (buffer-local-variables))))

(defun aside--switch-to-prev-buffer-skip-p-advice-around (oldfun &rest args)
  "Return non-nil when Aside buffers should not be displayed."
  (or (and (not (aside--window-p (cadr args)))
        (aside--buffer-p (caddr args)))
     (and (aside--window-p (cadr args))
        (not (aside--buffer-p (caddr args))))
     (apply oldfun args)))


;; Preventing Aside windows from being resized

(defun aside--set-window-size-fixed (window value)
  "Set the buffer-local ‘window-size-fixed’ variable of the buffer
in WINDOW to VALUE."
  (with-current-buffer (window-buffer window)
    (setq-local window-size-fixed value)))

(defun aside--balance-windows-before (&rest _)
  "Fix the size of all Aside windows on selected frame."
  (-map (-rpartial #'aside--set-window-size-fixed t)
        (-filter #'aside--window-p (window-list))))

(defun aside--balance-windows-after (&rest _)
  "Un-fix the size of all Aside windows on selected frame."
  (-map (-rpartial #'aside--set-window-size-fixed nil)
        (-filter #'aside--window-p (window-list))))

(defun aside--tab-bar-new-tab-to-advice-before (&rest _)
  "Try to select a non-side window."
  (when (aside--window-p (selected-window))
    (select-window (--first (not (aside--window-p it)) (window-list)))))


;; Public interface

(defun aside-work-around-new-tab-bug-enable ()
  "Work around a bug when creating a new tab in some cases.
Specifically, with ‘tab-bar-new-tab-choice’ set to T and with an
Aside-managed window selected, calling ‘tab-bar-new-tab’ fails
and causes things to break."
  (advice-add #'tab-bar-new-tab-to
              :before #'aside--tab-bar-new-tab-to-advice-before))

(defun aside-work-around-new-tab-bug-disable ()
  "Disable work around in ‘aside-work-around-new-tab-bug-enable’."
  (advice-remove #'tab-bar-new-tab-to
                 #'aside--tab-bar-new-tab-to-advice-before))

(defun aside-avoid-buffers-in-regular-windows-enable ()
  "Avoid displaying Aside-managed buffers in non-Aside-managed windows."
  (advice-add 'switch-to-prev-buffer-skip-p
              :around 'aside--switch-to-prev-buffer-skip-p-advice-around))

(defun aside-avoid-buffers-in-regular-windows-disable ()
  "Undo ‘aside-avoid-buffers-in-regular-windows-enable’."
  (advice-remove 'switch-to-prev-buffer-skip-p
                 'aside--switch-to-prev-buffer-skip-p-advice-around))

(defun aside-avoid-resizing-windows-enable ()
  "Avoid resizing Aside-managed windows."
  (advice-add 'balance-windows
              :before #'aside--balance-windows-before)
  (advice-add 'balance-windows
              :after #'aside--balance-windows-after)
  (advice-add 'balance-windows-area
              :before #'aside--balance-windows-before)
  (advice-add 'balance-windows-area
              :after #'aside--balance-windows-after))

(defun aside-avoid-resizing-windows-disable ()
  "Undo ‘aside-avoid-resizing-windows-enable’."
  (advice-remove 'balance-windows
                 #'aside--balance-windows-before)
  (advice-remove 'balance-windows
                 #'aside--balance-windows-after)
  (advice-remove 'balance-windows-area
                 #'aside--balance-windows-before)
  (advice-remove 'balance-windows-area
                 #'aside--balance-windows-after))

(defun aside--preserving-selected-window (fn)
  "Save selected window, call FN, restore selected window."
  (let ((selected-window (selected-window)))
    (funcall fn)
    (select-window selected-window)))

(defun aside--maybe-push-current-window ()
  "Maybe call ‘aw--push-window’."
  (when (and aside-ace-window-push (fboundp 'aw--push-window))
    (aw--push-window (selected-window))))

(defun aside-window-toggle-dwim (buffer-matcher &optional buffer-creator)
  "Return a window toggling closure.
BUFFER-MATCHER is passed to ‘aside--matcher’, and may be a symbol,
string, or function.  Refer to that function’s docstring for more
information.  BUFFER-CREATOR is called if no matching buffer
exists.

For more detailed information about this function, see the
Commentary section of ‘aside.el’.  The overall effect of this
function is to allow creating a single ‘do what I mean’ key
binding which can: create a new buffer and display it in a
specific window; switch directly to that window from any other
window; hide the buffer by deleting the window; and re-open the
buffer if no visible window is currently displaying it."
  (lambda (&optional arg)
    (interactive "P")
    (let* ((matcher (aside--matcher buffer-matcher))
           (buffer (aside--find-buffer-matching matcher))
           (window (aside--find-window-with-buffer-matching matcher)))
      (cond ((and (null window) (null buffer))
             (when buffer-creator
               (if arg
                   (aside--preserving-selected-window buffer-creator)
                 (aside--maybe-push-current-window)
                 (funcall buffer-creator))))
            ((and (null window) buffer)
             (if arg
                 (aside--preserving-selected-window
                  (lambda () (display-buffer buffer)))
               (aside--maybe-push-current-window)
               (select-window (display-buffer buffer))))
            ((funcall matcher (current-buffer))
             (delete-window window))
            (t
             (if arg
                 (delete-window window)
               (aside--maybe-push-current-window)
               (select-window window)))))))

(defmacro aside-define-configuration
    (id condition action hook &optional buffer-matcher buffer-creator)
  "A macro for concisely defining Aside configurations.
This macro defines the following: A customization group named
‘aside-<ID>’; three customizable variables, named
‘aside-<ID>-condition’, ‘aside-<ID>-action-alist’, and
‘aside-<ID>-hook’; and a function named ‘aside-<ID>-dwim’.

ID is the identifier for the configuration, necessary to enable
it later.  CONDITION is used by ‘display-buffer-alist’ to match
buffers.  ACTION corresponds to the ACTION parameter of
‘display-buffer’.  HOOK specifies a normal hook run for buffers
in this configuration’s window.  BUFFER-MATCHER and
BUFFER-CREATOR are passed to ‘aside-window-toggle-dwim’.  If
BUFFER-MATCHER is nil, ID is used.

If a configuration has already been defined and is already enabled,
the configuration will be automatically disabled and re-enabled by
this macro to make it simpler to redefine existing configurations,
e.g. when adding or removing buffer names to match against."
  (declare (indent defun))
  (let ((title (format "Aside-%s" (capitalize (symbol-name id))))
        (group (aside--group-var-name id))
        (condition-name (aside--condition-var-name id))
        (action-name (aside--action-alist-var-name id))
        (hook-name (aside--hook-var-name id))
        (dwim-name (aside--dwim-func-name id)))
    `(let ((already-enabled (aside--configuration-display-buffer-alist ',id)))
       (when already-enabled
         (aside-disable-configuration ',id))
       (defgroup ,group ()
         ,(format "Options for the %s window." title)
         :group 'aside)
       (makunbound ',condition-name)
       (defcustom ,condition-name
         ,condition
         ,(format "Used as a CONDITION in ‘display-buffer-alist’.
Matches the names of buffers that should be displayed in the
%s window." title)
         :group ',group
         :type '(choice regexp function)
         :set 'aside-configuration-setter-function)
       (makunbound ',action-name)
       (defcustom ,action-name
         ,action
         ,(format "Alist used as the ACTION argument to ‘display-buffer’.
Applied to windows containing buffers matched by
‘%s’." condition-name)
         :group ',group
         :type 'sexp
         :set 'aside-configuration-setter-function)
       (makunbound ',hook-name)
       (defcustom ,hook-name
         ,hook
         ,(format "Normal hook run for buffers in the %s window." title)
         :group ',group
         :type 'hook
         :options '(aside-hook-enable-truncate-lines
                    aside-hook-disable-display-line-numbers-mode
                    aside-hook-change-default-face-pitch
                    aside-hook-change-default-face-height))
       (fmakunbound ',dwim-name)
       (defalias ',dwim-name
         (aside-window-toggle-dwim (or ,buffer-matcher ',id) ,buffer-creator)
         ,(format "DWIM command for the %s window." title))
       (when already-enabled
         (aside-enable-configuration ',id)))))

;; (provide 'aside)

;;; aside.el ends here
#+end_src

** aside-vterm

#+begin_src emacs-lisp :tangle yes
;;; aside-vterm.el --- A shared global Vterm buffer -*- lexical-binding: t -*-

;; Copyright 2021 Matt Beshara

;; Author: Matt Beshara <m@mfa.pw>
;; URL: https://git.sr.ht/~mfa/aside
;; Version: 2.6.8
;; Package-Requires: ((emacs "27.1") (dash "2.19.1"))
;; Keywords: convenience

;; This file is NOT part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
;; more details.

;; You should have received a copy of the GNU General Public License along
;; with this program.  If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; It’s not a new idea – a terminal you can toggle the visibility of by
;; pressing a simple key binding.  Only a single, shared, global Vterm
;; instance is used.  This configuration is a bit more complex than most
;; others, due to the fact that it needs a custom function to create the Vterm
;; buffer the first time it is opened.

;; Many of the variables in this file defined with ‘defcustom’ use a custom
;; setter.  If you change the value of those variable outside of Customize and
;; do not use ‘customize-set-variable’ to do so, you may want to call
;; ‘aside-disable-configuration’ before changing the value, and
;; ‘aside-enable-configuration’ after the new value has been set.

;; To activate the Vterm configuration, do something like the following:
;; (require 'aside-vterm)
;; (aside-enable-configuration 'vterm)
;; (define-key global-map (kbd "C-`") 'aside-vterm-dwim)


;;; Code:

(require 'rx)
(when (require 'vterm-module nil t)
  (require 'vterm))

(defcustom aside-vterm-buffer-name
  "*Aside-Vterm*"
  "The name for the single, shared, global Aside-Vterm buffer."
  :group 'aside-vterm
  :type 'string
  :set 'aside-configuration-setter-function)

(defun aside--vterm ()
  "Create an Aside-Vterm buffer if necessary, and display it."
  (let ((buffer (get-buffer-create aside-vterm-buffer-name)))
    (with-current-buffer buffer
      (unless (derived-mode-p 'vterm-mode)
        (setq default-directory (expand-file-name "~"))
        (vterm-mode))
      (select-window (display-buffer buffer)))))

(aside-define-configuration vterm
			    (rx (literal aside-vterm-buffer-name))
			    '((side . bottom)
			      (slot . -10)
			      (window-height . 10))
			    '(aside-hook-change-default-face-height
			      aside-hook-enable-truncate-lines
			      aside-hook-disable-display-line-numbers-mode)
			    nil
			    #'aside--vterm)

;; (provide 'aside-vterm)

;;; aside-vterm.el ends here
#+end_src

** aside-eshell

#+begin_src emacs-lisp :tangle yes
;;; aside-eshell.el --- A shared global Eshell buffer -*- lexical-binding: t -*-

;;; Commentary:
;;; Code:

(require 'rx)
(require 'eshell)

(defcustom aside-eshell-buffer-name
  "*Aside-Eshell*"
  "The name for the single, shared, global Aside-Eshell buffer."
  :group 'aside-eshell
  :type 'string
  :set 'aside-configuration-setter-function)

(defun aside--eshell ()
  "Create an Aside-Eshel buffer if necessary, and display it."
  (let ((buffer (get-buffer-create aside-eshell-buffer-name)))
    (with-current-buffer buffer
      (unless (derived-mode-p 'eshell-mode)
        (setq default-directory (expand-file-name "~"))
        (eshell-mode))
      (select-window (display-buffer buffer)))))

(aside-define-configuration eshell
  (rx (literal aside-eshell-buffer-name))
  '((side . bottom)
    (slot . -40)
    (window-height . 40))
  '(aside-hook-enable-truncate-lines
    aside-hook-disable-display-line-numbers-mode)
  nil
  #'aside--eshell)

(aside-enable-configuration 'eshell)
(define-key global-map (kbd "C-`") 'aside-eshell-dwim)

;; (provide 'aside-eshell)

;;; aside-eshell.el ends here
#+end_src

** aside-configurations

#+begin_src emacs-lisp :tangle yes
;;; aside-configurations.el -*- lexical-binding: t -*-

;; Copyright 2021 Matt Beshara

;; Author: Matt Beshara <m@mfa.pw>
;; URL: https://git.sr.ht/~mfa/aside
;; Version: 2.6.8
;; Package-Requires: ((emacs "27.1") (dash "2.19.1"))
;; Keywords: convenience

;; This file is NOT part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
;; more details.

;; You should have received a copy of the GNU General Public License along
;; with this program.  If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; This file contains Aside configurations simple enough to be defined by the
;; ‘aside-define-configuration’ macro alone.

;; These configurations can be activated by doing something along these lines:
;; (require 'aside-configurations)
;; (aside-enable-configuration 'messages)
;; (define-key global-map (kbd "C-S-x") 'aside-messages-dwim)
;; (aside-enable-configuration 'context)
;; (define-key global-map (kbd "C-S-z") 'aside-context-dwim)


;;; Code:

(require 'rx)

;; This configuration displays *Messages*, compile logs, and
;; other related information in a side window displayed at the
;; bottom of a frame.  It’s also convenient to use for displaying
;; search results, as the right sidebasr is too thin to display
;; lines which are very long.  This window will appear to the
;; right of the Aside-Vterm window when both are visible.
(aside-define-configuration messages
  (rx (or
       ;; Messages
       "*Async-native-compile-log*"
       "*Async Shell Command*"
       "*Backtrace*"
       "*Compile-Log*"
       "*Geiser Debug*"
       "*Messages*"
       "*Native-compile-Log*"
       "*sly-compilation*"
       "*sly-error"
       "*Warnings*"
       ;; Search results
       (seq "*Embark Export" (one-or-more nonl) "grep")
       (seq "*Occur" (one-or-more nonl))
       "*grep*"
       "*PDF-Occur*"
       (seq "*rg" (one-or-more nonl))
       "*trace-output*"))
  '((side . bottom)
    (slot . 5)
    (window-height . 10))
  '())

;; The Context configuration causes a side window on the right of the frame
;; to be used for buffers which provide contextual information that I only
;; want visible for a short amount of time, such as Help, Apropos, Occur, etc.
;; Having one of these buffers appear or disappear should not cause me to lose
;; my place in any other buffer, but the window they appear in should be big
;; enough to let me see the information I need with a minimum of scrolling.
(aside-define-configuration context
  (lambda (buffer-or-name &optional _)
    (let ((buffer (get-buffer buffer-or-name)))
      (and (not (string-match-p
             (rx (seq "*Embark Export" (one-or-more nonl) "grep"))
             (buffer-name buffer)))
         (string-match-p
          (rx (or "*Apropos*"
                 (seq "*cider-inspect" (one-or-more nonl))
                 "*Currency*"
                 (seq "*Dictionary" (one-or-more nonl))
                 (seq "*eldoc" (one-or-more nonl))
                 "*Embark Actions*"
                 (seq "*Embark Collect" (one-or-more nonl))
                 (seq "*Embark Export" (one-or-more nonl))
                 "*Geiser documentation*"
                 "*Chicken Documentation*"
                 (seq bol (seq "*Help" (one-or-more nonl)))
                 "*lingva*"
                 "*Metahelp*"
                 (seq "*Shortdoc " (one-or-more nonl))
                 (seq "*sly-apropos" (one-or-more nonl))
                 "*sly-db"
                 "*sly-description*"
                 (seq "*sly-inspector" (one-or-more nonl))
                 (seq "*sly-xref" (one-or-more nonl))
                 "*Synonyms List*"
                 "*wclock*"
                 "*WordNut*"
                 "*xref*"))
          (buffer-name buffer)))))
  '((side . right)
    (window-width . 80))
  '(aside-hook-disable-display-line-numbers-mode))

;; A dumb ‘sticky note’ buffer displayed below the Context window.  Useful for
;; comparing two Help buffers, because you can easily keep a copy of the
;; content of one Help buffer visible while using the Context window for
;; browsing another Help buffer.
(aside-define-configuration sticky
  "\\*Aside-Sticky\\*"
  '((side . right)
    (slot . 5)
    (window-width . 80))
  '(aside-hook-disable-display-line-numbers-mode)
  nil
  #'aside--sticky)

(defun aside--sticky ()
  "Create the *Aside-Sticky* buffer."
  (interactive)
  (select-window (display-buffer (get-buffer-create "*Aside-Sticky*")))
  (text-mode)
  (display-line-numbers-mode -1))

(aside-enable-configuration 'messages)
(define-key global-map (kbd "C-S-x") 'aside-messages-dwim)
(aside-enable-configuration 'context)
(define-key global-map (kbd "C-S-z") 'aside-context-dwim)

;; (provide 'aside-configurations)

;;; aside-configurations.el ends here
#+end_src

* Keybinds

** keybinds

#+begin_src emacs-lisp :tangle yes
;;
;; --- KEYBINDING FIX ---
;;
(define-key input-decode-map [?\C-m] [C-m])
(define-key input-decode-map [?\C-i] [C-i])
(add-hook 'server-after-make-frame-hook
	  (lambda ()
	    (define-key input-decode-map [?\C-m] [C-m])
	    (define-key input-decode-map [?\C-i] [C-i])))

;; Now:
;; (equal (kbd "TAB") (kbd "C-i"))   ; -> t
;; (equal (kbd "TAB") (kbd "<C-i>")) ; -> nil
;; (equal (kbd "RET") (kbd "C-m"))   ; -> t
;; (equal (kbd "RET") (kbd "<C-m>")) ; -> nil

(define-key function-key-map
  [(control shift iso-lefttab)] [(control shift tab)])
(define-key function-key-map
  [(meta shift iso-lefttab)] [(meta shift tab)])
(define-key function-key-map
  [(meta control shift iso-lefttab)] [(meta control shift tab)])

;; Visual Keybinding Info
(use-package which-key
  :disabled t
  :init
  (which-key-mode)
  :diminish which-key-mode
  :custom
  ;; (which-key-idle-delay 0.00000001)
  (which-key-idle-delay 1.0))

;; Better help information
(use-package helpful
  :ensure
  :bind
  ([remap describe-command]  . helpful-command)
  ([remap describe-key]      . helpful-key)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-function] . helpful-callable))

(use-package eldoc
  :ensure nil
  :config
  (setq eldoc-echo-area-prefer-doc-buffer nil))

;; Hydras
(use-package hydra)

(defhydra hydra-text-scale (:timeout 4)
  "Scales text."
  ("n" text-scale-increase "in")
  ("p" text-scale-decrease "out")
  ("q" nil "finished" :exit t))

(defhydra hydra-window-resize (:timeout 4)
  "Resizes window."
  ("p" shrink-window 5 "shrink vertically")
  ("n" enlarge-window 5 "enlarge vertically")
  ("b" shrink-window-horizontally 5 "shrink horizontally")
  ("f" enlarge-window-horizontally 5 "enlarge horizontally")
  ("q" nil "finished" :exit t))

;;
;; --- GENERAL KEYBINDS ---
;;

;;; Scroll functions

(defun cory/scroll-down-half-page ()
  "Scroll down half a page while keeping the cursor centered."
  (interactive)
  (let ((ln (line-number-at-pos (point)))
	(lmax (line-number-at-pos (point-max))))
    (cond ((= ln 1) (move-to-window-line nil))
	  ((= ln lmax) (recenter (window-end)))
	  (t (progn
               (move-to-window-line -1)
               (recenter))))))

(defun cory/scroll-up-half-page ()
  "Scroll up half a page while keeping the cursor centered."
  (interactive)
  (previous-line)
  (let ((ln (line-number-at-pos (point)))
	(lmax (line-number-at-pos (point-max))))
    (cond ((= ln 1) nil)
	  ((= ln lmax) (move-to-window-line nil))
	  (t (progn
               (move-to-window-line 0)
               (recenter))))))

(put 'cory/scroll-down-half-page 'scroll-command t)
(put 'cory/scroll-up-half-page 'scroll-command t)

;;; Selection functions

(defmacro cory/def-bounds-of-thing (name thing)
  `(defun ,name ()
     (interactive)
     (let ((bounds (bounds-of-thing-at-point ,thing)))
       (when bounds
	 (goto-char (car bounds))
	 (set-mark-command nil)
	 (goto-char (cdr bounds))))))

(defmacro cory/def-beginning-of-thing (name thing)
  `(defun ,name ()
     (interactive)
     (let ((bounds (bounds-of-thing-at-point ,thing)))
       (when bounds
	 (goto-char (car bounds))))))

(defmacro cory/def-end-of-thing (name thing)
  `(defun ,name ()
     (interactive)
     (let ((bounds (bounds-of-thing-at-point ,thing)))
       (when bounds
	 (goto-char (cdr bounds))))))

(cory/def-bounds-of-thing cory/mark-word 'word)
(cory/def-bounds-of-thing cory/mark-list 'list)
(cory/def-bounds-of-thing cory/mark-symbol 'symbol)
(cory/def-bounds-of-thing cory/mark-sexp 'sexp)
(cory/def-bounds-of-thing cory/mark-number 'number)
(cory/def-bounds-of-thing cory/mark-sentence 'sentence)
(cory/def-bounds-of-thing cory/mark-url 'url)
(cory/def-bounds-of-thing cory/mark-email 'email)
(cory/def-bounds-of-thing cory/mark-line 'line)

(cory/def-beginning-of-thing cory/beginning-of-word 'word)
(cory/def-beginning-of-thing cory/beginning-of-list 'list)
(cory/def-beginning-of-thing cory/beginning-of-symbol 'symbol)
(cory/def-beginning-of-thing cory/beginning-of-sexp 'sexp)
(cory/def-beginning-of-thing cory/beginning-of-number 'number)
(cory/def-beginning-of-thing cory/beginning-of-sentence 'sentence)
(cory/def-beginning-of-thing cory/beginning-of-url 'url)
(cory/def-beginning-of-thing cory/beginning-of-email 'email)
(cory/def-beginning-of-thing cory/beginning-of-line 'line)

(cory/def-end-of-thing cory/end-of-word 'word)
(cory/def-end-of-thing cory/end-of-list 'list)
(cory/def-end-of-thing cory/end-of-symbol 'symbol)
(cory/def-end-of-thing cory/end-of-sexp 'sexp)
(cory/def-end-of-thing cory/end-of-number 'number)
(cory/def-end-of-thing cory/end-of-sentence 'sentence)
(cory/def-end-of-thing cory/end-of-url 'url)
(cory/def-end-of-thing cory/end-of-email 'email)
(cory/def-end-of-thing cory/end-of-line 'line)

(defun cory/beginning-of-workspace ()
  "If a secondary selection is active, goto the beginning of it.
Else, goto the beginning of the buffer."
  (interactive)
  (if (and
      (secondary-selection-exist-p)
      (< (overlay-start mouse-secondary-overlay)
	 (overlay-end mouse-secondary-overlay))
      (<= (overlay-start mouse-secondary-overlay)
	 (point)
	 (overlay-end mouse-secondary-overlay)))
      (goto-char (overlay-start mouse-secondary-overlay))
    (goto-char (point-min))))

(defun cory/end-of-workspace ()
  "If a secondary selection is active, goto the end of it.
Else, goto the end of the buffer."
  (interactive)
  (if (and
      (secondary-selection-exist-p)
      (< (overlay-start mouse-secondary-overlay)
	 (overlay-end mouse-secondary-overlay))
      (<= (overlay-start mouse-secondary-overlay)
	 (point)
	 (overlay-end mouse-secondary-overlay)))
      (goto-char (- (overlay-end mouse-secondary-overlay) 1))
    (goto-char (point-max))))

;;; Grab functions

(defun cory/second-sel-set-string (string)
  (cond
   ((cory/second-sel-buffer)
    (with-current-buffer (overlay-buffer mouse-secondary-overlay)
      (goto-char (overlay-start mouse-secondary-overlay))
      (delete-region (overlay-start mouse-secondary-overlay) (overlay-end mouse-secondary-overlay))
      (insert string)))
   ((markerp mouse-secondary-start)
    (with-current-buffer (marker-buffer mouse-secondary-start)
      (goto-char (marker-position mouse-secondary-start))
      (insert string)))))

(defun cory/second-sel-get-string ()
  (when (cory/second-sel-buffer)
    (with-current-buffer (overlay-buffer mouse-secondary-overlay)
      (buffer-substring-no-properties
       (overlay-start mouse-secondary-overlay)
       (overlay-end mouse-secondary-overlay)))))

(defun cory/second-sel-buffer ()
  (and (overlayp mouse-secondary-overlay)
     (overlay-buffer mouse-secondary-overlay)))

(defun cory/grab ()
  "Create secondary selection or a marker if no region available."
  (interactive)
  (if (region-active-p)
      (secondary-selection-from-region)
    (progn
      (delete-overlay mouse-secondary-overlay)
      (setq mouse-secondary-start (make-marker))
      (move-marker mouse-secondary-start (point))))
  (deactivate-mark t))

(defun cory/swap-grab ()
  "Swap region and secondary selection."
  (interactive)
  (let* ((rbeg (region-beginning))
         (rend (region-end))
         (region-str (when (region-active-p) (buffer-substring-no-properties rbeg rend)))
         (sel-str (cory/second-sel-get-string))
         (next-marker (make-marker)))
    (when region-str (delete-region rbeg rend))
    (when sel-str (insert sel-str))
    (move-marker next-marker (point))
    (cory/second-sel-set-string (or region-str ""))
    (when (overlayp mouse-secondary-overlay)
      (delete-overlay mouse-secondary-overlay))
    (setq mouse-secondary-start next-marker)
    (deactivate-mark t)))

(defun cory/sync-grab ()
  "Sync secondary selection with current region."
  (interactive)
  (when (region-active-p)
    (let* ((rbeg (region-beginning))
           (rend (region-end))
           (region-str (buffer-substring-no-properties rbeg rend))
           (next-marker (make-marker)))
      (move-marker next-marker (point))
      (cory/second-sel-set-string region-str)
      (when (overlayp mouse-secondary-overlay)
	(delete-overlay mouse-secondary-overlay))
      (setq mouse-secondary-start next-marker)
      (deactivate-mark t))))

;;; Misc functions

(defun cory/create-tmp-file ()
  (interactive)
  (find-file (concat temporary-file-directory (read-string "New tmp file:"))))

(defun cory/insert-space ()
  "Insert a space."
  (interactive)
  (self-insert-command 1 ? )
  (backward-char))

;;; Basic Keybinds

;; Swap "C-h" and "C-x", so it's easier to type on Dvorak layout
;; (keyboard-translate (kbd "C-h") (kbd "C-x"))
;; (keyboard-translate (kbd "C-x") (kbd "C-h"))

(defmacro cory/define-keys (map &rest l)
  ""
  `(dolist (pair ',l)
     (define-key ,map (kbd (car pair)) (cdr pair))))

(cory/define-keys
 global-map
 ("C-x k" . kill-this-buffer)
 ("C-x K" . kill-buffer)
 ("C-c w" . woman)
 ;; ("C-x u"   . undo-only)
 ;; ("C-/"     . undo-only)
 ;; ("C-x C-u" . undo-redo)
 ;; ("C-?"     . undo-redo)
 ("C-'"   . repeat)
 ("C-s"   . cory/search-forward-dwim)
 ("C-r"   . cory/search-backward-dwim)
 ("C-M-s" . cory/isearch-forward-resume)
 ("C-M-r" . cory/isearch-backward-resume)
 ("C-v"   . cory/scroll-down-half-page)
 ("M-v"   . cory/scroll-up-half-page)
 ("C-c F" . cory/create-tmp-file)
 ("C-c e" . eww)
 ("S-SPC" . cory/insert-space)
 ("C-c q" . quit-window)
 ("C-j"   . join-line)
 ("C-c x" . xref-find-references-and-replace)
 ("M-<"   . cory/beginning-of-workspace)
 ("M->"   . cory/end-of-workspace)
 ("C-c s" . cory/connect-ssh)
 ("C-c S" . cory/disconnect-ssh)
 ("C-c p" . palette))

;;; Selection Keybinds

(define-prefix-command 'bounds-of-thing-map)
(global-set-key (kbd "C-.") 'bounds-of-thing-map)
(cory/define-keys
 bounds-of-thing-map
 ("w" . cory/mark-word)
 ("l" . cory/mark-list)
 ("s" . cory/mark-symbol)
 ("e" . cory/mark-sexp)
 ("f" . mark-defun)
 ("n" . cory/mark-number)
 ("." . cory/mark-sentence)
 ("u" . cory/mark-url)
 ("m" . cory/mark-email)
 ("r" . cory/mark-line)
 ("b" . mark-whole-buffer)
 ("p" . mark-paragraph))

(define-prefix-command 'beginning-of-thing-map)
(global-set-key (kbd "C-<") 'beginning-of-thing-map)
(cory/define-keys
 beginning-of-thing-map
 ("w" . cory/beginning-of-word)
 ("l" . cory/beginning-of-list)
 ("s" . cory/beginning-of-symbol)
 ("e" . cory/beginning-of-sexp)
 ("f" . beginning-of-defun)
 ("n" . cory/beginning-of-number)
 ("." . cory/beginning-of-sentence)
 ("u" . cory/beginning-of-url)
 ("m" . cory/beginning-of-email)
 ("r" . beginning-of-line)
 ("b" . beginning-of-buffer)
 ("p" . backward-paragraph))

(define-prefix-command 'end-of-thing-map)
(global-set-key (kbd "C->") 'end-of-thing-map)
(cory/define-keys
 end-of-thing-map
 ("w" . cory/end-of-word)
 ("l" . cory/end-of-list)
 ("s" . cory/end-of-symbol)
 ("e" . cory/end-of-sexp)
 ("f" . end-of-defun)
 ("n" . cory/end-of-number)
 ("." . cory/end-of-sentence)
 ("u" . cory/end-of-url)
 ("m" . cory/end-of-email)
 ("r" . end-of-line)
 ("b" . end-of-buffer)
 ("p" . forward-paragraph))

;;; Grab Keybinds

(global-set-key (kbd "C-c SPC") #'cory/grab)
(global-set-key (kbd "C-c C-SPC") #'cory/swap-grab)
(global-set-key (kbd "C-c M-SPC") #'cory/sync-grab)

;;; Lisp Keybinds

;; FIXME
(dolist (map (list emacs-lisp-mode-map
		   lisp-mode-map lisp-data-mode-map
		   clojure-mode-map ;; cider-repl-mode-map
		   ;; racket-mode-map racket-repl-mode-map
		   ;; scheme-mode-map geiser-repl-mode-map
		   ))
  (define-key map (kbd "M-a") 'backward-list)
  (define-key map (kbd "M-e") 'forward-list)
  (define-key map (kbd "M-h") 'cory/mark-list))

;;; Repeat Maps

(defun repeaters-define-maps (rlist)
  "Define an arbitrary number of repeater maps.
Maps are defined based on the lists passed through RLIST, a
quoted list containing ‘repeat-map’ definitions.  Each definition
is itself a list containing the following items:
NAME is a string designating the unique portion of the
repeat-map’s name (to be constructed into the form
‘repeaters-NAME-rep-map’ as the name of the symbol for the map).
One or more command ENTRIES made up of the following:
    The COMMAND’s symbol;
    One or more string representations of KEY-SEQUENCES which
    may be used to invoke the command when the ‘repeat-map’ is
    active;
    Optionally, the KEYWORD ‘:exitonly’ may follow the key sequences.
A single map definition may include any number of these command
entry constructs.
If a command construct ends with the ‘:exitonly’ keyword, the map
can invoke the command, but the command will *not* invoke that
map.
However, if the keyword is omitted, the command will bring up the
‘repeat-map’ whenever it is called using one of the keysequences
given in the ‘repeat-map’.  A given command may only store a
single map within its ‘repeat-map’ property, although a command
can be called from multiple repeat-maps.
Taking advantage of this fact, one may chain related repeat-maps
together in sequence."
  (while rlist
    (let* ((block (pop rlist))
           (mapname (concat "repeaters-" (pop block) "-rep-map")))
      (set (intern mapname)
           (let ((map (make-sparse-keymap))
                 (thing (pop block)))
             (while block
               (let ((thingnext (pop block)))
                 (while (stringp thingnext)
                   (define-key map (kbd thingnext) thing)
                   (setq thingnext (pop block)))
                 (if (eq thingnext :exitonly)
                     (setq thing (pop block))
                   (progn (put thing 'repeat-map (intern mapname))
                          (setq thing thingnext)))))
             map)))))

(defvar repeaters-maps
  '(("buffer-switch"
     previous-buffer                   "C-x C-<left>" "C-x <left>" "C-<left>" "<left>" "p"
     next-buffer                       "C-x C-<right>" "C-x <right>" "C-<right>" "<right>" "n")

    ("calendar-nav"
     calendar-forward-day              "C-f" "f"
     calendar-backward-day             "C-b" "b"
     calendar-forward-week             "C-n" "n"
     calendar-backward-week            "C-p" "p"
     calendar-forward-month            "M-}" "}" "]"
     calendar-backward-month           "M-{" "{" "["
     calendar-forward-year             "C-x ]"
     calendar-backward-year            "C-x [")

    ("char-line-nav"
     backward-char                     "C-b" "b"
     forward-char                      "C-f" "f"
     next-line                         "C-n" "n"
     previous-line                     "C-p" "p")

    ("defun-nav"
     beginning-of-defun                "C-M-a" "M-a" "a" "ESC M-a"
     end-of-defun                      "C-M-e" "M-e" "e" "ESC M-e")

    ("del-char"
     delete-char                       "C-d" "d")

    ("sexp-nav"
     backward-sexp                     "C-M-b" "b" "ESC M-b"
     forward-sexp                      "C-M-f" "f" "ESC M-f")

    ("paragraph-nav"
     backward-paragraph                "C-<up>" "<up>" "M-{" "M-[" "{" "["
     forward-paragraph                 "C-<down>" "<down>" "M-}" "M-]" "}" "]")

    ("sentence-nav"
     backward-sentence                 "M-a" "a"
     forward-sentence                  "M-e" "e"
     back-to-indentation               "M-m" "m"                     :exitonly)

    ("in-line-nav"
     move-end-of-line                  "C-a" "a"
     move-end-of-line                  "C-e" "e")

    ("page-nav"
     backward-page                     "C-x [" "["
     forward-page                      "C-x ]" "]")

    ("list-nav"
     backward-list                     "C-M-p" "p" "ESC M-p"
     forward-list                      "C-M-n" "n" "ESC M-n"
     backward-up-list                  "C-M-<up>" "C-M-u" "<up>" "u" "ESC M-u"
     down-list                         "C-M-<down>" "C-M-d" "<down>" "d" "ESC M-d")

    ("error-nav"
     next-error                        "C-x `" "`" "M-g M-n" "M-g n" "n"
     previous-error                    "M-g M-p" "M-p" "p")

    ("mid-top-bottom-move"
     recenter-top-bottom               "C-l" "l"
     move-to-window-line-top-bottom    "M-r" "r"
     back-to-indentation               "M-m" "m"                     :exitonly)

    ("fix-case"
     upcase-word                       "M-u" "u"

     ;; Easy way to manually set title case
     downcase-word                     "M-l" "l" "d"
     capitalize-word                   "M-c" "c")

    ("kill-word"
     kill-word                         "M-d" "M-<delete>" "d")

    ("kill-line"
     kill-line                         "C-k" "k")

    ("kill-sentence"
     kill-sentence                     "M-k" "k"
     backward-kill-sentence            "C-x DEL" "DEL")

    ("kill-sexp"
     kill-sexp                         "C-M-k" "k" "ESC M-k")

    ;; Yank same text repeatedly with “C-y y y y”...
    ("yank-only"
     yank                              "C-y" "y"
     yank-pop                          "M-y" "n"                     :exitonly)

    ;; Cycle through the kill-ring with “C-y n n n”...
    ;; You can reverse direction too “C-y n n C-- n n”
    ("yank-popping"
     yank-pop                          "M-y" "y" "n")

    ("kmacro-cycle"
     kmacro-cycle-ring-next            "C-x C-k C-n" "C-n" "n"
     kmacro-cycle-ring-previous        "C-x C-k C-p" "C-p" "p")

    ("tab-bar-nav"
     tab-next                          "C-x t o" "o" "n"
     tab-previous                      "C-x t O" "O" "p")

    ("transpose-chars"
     transpose-chars                    "C-t" "t")

    ("transpose-words"
     transpose-words                   "M-t" "t")

    ("transpose-sexps"
     transpose-sexps                   "C-M-t" "t" "ESC M-t")

    ("transpose-lines"
     transpose-lines                   "C-x C-t" "t")

    ;; M-< for beginning-of-buffer brings up this map, since you can
    ;; only scroll a buffer up when at its beginning.
    ("scroll-up"
     scroll-up-command                 "C-v" "v"
     beginning-of-buffer               "M-<" "<"
     end-of-buffer                     "M->" ">"                     :exitonly
     scroll-down-command               "M-v"                         :exitonly)

    ;; M-> for end-of buffer brings up this map, since you can only
    ;; scroll a buffer down when at its end.
    ("scroll-down"
     scroll-down-command               "M-v" "v"
     end-of-buffer                     "M->" ">"
     beginning-of-buffer               "M-<" "<"                     :exitonly
     scroll-up-command                 "C-v"                         :exitonly)

    ("scroll-otherwin"
     scroll-other-window               "C-M-v" "v" "ESC M-v"
     beginning-of-buffer-other-window  "M-<home>" "<"
     end-of-buffer-other-window        "M-<end>" ">"                 :exitonly
     scroll-other-window-down          "C-M-S-v" "M-v" "ESC M-V" "V" :exitonly)

    ("scroll-otherwin-down"
     scroll-other-window-down          "C-M-S-v" "M-v" "v" "ESC M-V" "V"
     end-of-buffer-other-window        "M-<end>" ">"
     beginning-of-buffer-other-window  "M-<home>" "<"                :exitonly
     scroll-other-window               "C-M-v" "C-v" "ESC M-v"       :exitonly)

    ("scroll-sideways"
     scroll-left                       "C-x <" "<"
     scroll-right                      "C-x >" ">")

    ("hippie-exp"
     ;; For navigating through expansion candidates. You can revert
     ;; to the original string by prefixing the next hippie-expand
     ;; invocation with universal-argument (“C-u /”).
     hippie-expand                     "M-/" "/")

    ("search-nav"
     isearch-repeat-forward            "C-s" "s" "C-M-s" "ESC M-s"
     isearch-repeat-backward           "C-r" "r" "C-M-r" "ESC M-r"
     isearch-exit                      "<enter>" "<return>" "RET"    :exitonly)

    ("undo-only-redo"
     undo-only                         "C-x u" "C-_" "_" "C-/" "/"
     undo-redo                         "C-?" "?" "r")

    ;; Repeat Maps for Org-Mode
    ("org-nav"
     org-backward-heading-same-level   "C-c C-b" "C-b" "b"
     org-forward-heading-same-level    "C-c C-f" "C-f" "f"
     org-previous-visible-heading      "C-c C-p" "C-p" "p"
     org-next-visible-heading          "C-c C-n" "C-n" "n"
     outline-up-heading                "C-c C-u" "C-u" "u")

    ("org-editing"
     org-metadown                      "M-<down>" "<down>"
     org-metaup                        "M-<up>" "<up>"
     org-demote-subtree                "C->" ">"
     org-promote-subtree               "C-<" "<")

    ("org-task"
     org-todo                          "C-c C-t" "C-t" "t"
     org-priority                      "C-c ," ","
     org-time-stamp                    "C-c ." "."
     org-schedule                      "C-c C-s" "C-s" "s"
     org-deadline                      "C-c C-d" "C-d" "d")

    ("word-nav"
     backward-word                     "M-b" "b"
     forward-word                      "M-f" "f")

    ("set-mark"
     smart-region                      "C-SPC" "SPC"))

  "List of lists containing repeater-map definitions.
This must be in the form required by the
‘repeaters-define-maps’ function.")

(repeaters-define-maps repeaters-maps)
(setq repeat-exit-key "g"
      repeat-exit-timeout 30)
(repeat-mode)

;;; Misc useful functions

(defun describe-all-keymaps ()
  "Describe all keymaps in currently-defined variables."
  (interactive)
  (with-output-to-temp-buffer "*keymaps*"
    (let (symbs seen)
      (mapatoms (lambda (s)
                  (when (and (boundp s) (keymapp (symbol-value s)))
                    (push (indirect-variable s) symbs))))
      (dolist (keymap symbs)
        (unless (memq keymap seen)
          (princ (format "* %s\n\n" keymap))
          (princ (substitute-command-keys (format "\\{%s}" keymap)))
          (princ (format "\f\n%s\n\n" (make-string (min 80 (window-width)) ?-)))
          (push keymap seen))))
    (with-current-buffer standard-output ;; temp buffer
      (setq help-xref-stack-item (list #'describe-all-keymaps)))))

(defun delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(defun rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(global-set-key (kbd "C-x x k") 'delete-current-buffer-file)
(global-set-key (kbd "C-x x r") 'rename-current-buffer-file)
#+end_src

# * Informal Packages

# ** eshell-undistract-me

# #+begin_src emacs-lisp :tangle yes
# ;;; ehsell-undistract-me.el --- Notifies you when a long running command is complete. -*- lexical-binding: t -*-

# ;; Author: Cory Tertel <ctertel@comcast.net>
# ;; Maintainer: Cory Tertel <ctertel@comcast.net>
# ;; URL: https://github.com/corytertel/eshell-undistract-me
# ;; Version: 0.1
# ;; Package-Requires: ((emacs "25.1"))
# ;; Keywords: eshell

# ;; This file is an eshell port of the bash undistract-me.

# ;; The original bash undistract-me is Copyright (c) 2008-2012 by the
# ;; orignal undistract-me developers. See the LICENSE in the original
# ;; undistract-me repo for more details. Like the original undistract-me,
# ;; this file is under the Expat License.

# ;; Permission is hereby granted, free of charge, to any person obtaining a copy
# ;; of this software and associated documentation files (the "Software"), to deal
# ;; in the Software without restriction, including without limitation the rights
# ;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# ;; copies of the Software, and to permit persons to whom the Software is
# ;; furnished to do so, subject to the following conditions:

# ;; The above copyright notice and this permission notice shall be included in
# ;; all copies or substantial portions of the Software.

# ;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# ;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# ;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# ;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# ;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# ;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# ;; SOFTWARE.

# ;;; Commentary:

# ;; Generates a notification for any command that takes longer than a given
# ;; ammount of seconds to return to the shell.
# ;; e.g. if LONG_RUNNING_COMMAND_TIMEOUT=10, then 'sleep 11' will always
# ;; generate a notification.

# ;; Relies on eshell-pre-command-hook and eshell-before-prompt-hook.

# ;; Hook eshell-undistract-me-pre-command into eshell-pre-command-hook
# ;; and eshell-undistract-me-before-prompt into ehsell-before-prompt-hook.

# ;; Requires libnotify to be installed.  By default uses pulseaudio's
# ;; `paplay'.  Any command can be used to play audio by changing
# ;; `eshell-undistract-me-sound-command'.

# ;;; Customization

# ;;; Code:

# ;; (require 'eshell)
# ;; (require 'esh-mode)
# ;; (require 'term)

# (defgroup eshell-undistract-me nil
#   "Eshell undistract-me."
#   :group 'eshell)

# (defcustom eshell-undistract-me-long-running-command-timeout 10
#   "The minimum required duration (seconds) for a notification to send."
#   :group 'eshell-undistract-me
#   :type 'integer)

# (defcustom eshell-undistract-me-play-sound nil
#   "Whether or to play a sound with notifications.  Non-nil plays a sound."
#   :group 'eshell-undistract-me
#   :type 'boolean)

# (defcustom eshell-undistract-me-sound-command "paplay"
#   "Command to run to play the notification sound."
#   :group 'eshell-undistract-me
#   :type 'string)

# (defcustom eshell-undistract-me-sound-path
#   "/usr/share/sounds/freedesktop/stereo/complete.oga"
#   "Path to the sound to play for notifications."
#   :group 'eshell-undistract-me
#   :type 'string)

# (defvar eshell-undistract-me-last-command-started nil
#   "When the last command was started in unix seconds.")

# (defvar eshell-undistract-me-last-command nil
#   "The last command run by eshell.")

# (defvar eshell-undistract-me-last-window nil
#   "The id of the active window.")

# (defun eshell-undistract-me-get-now ()
#   "Return the current time since 1970-01-01 in seconds."
#   (time-convert nil 'integer))

# (defun eshell-undistract-me-active-x-window-id ()
#   "Return the Id of the currently focused X window."
#   (if (and (eq (window-system) 'x) (getenv "DISPLAY"))
#       (x-window-property "_NET_ACTIVE_WINDOW" nil "WINDOW" 0 nil t)
#     "nowindowid"))

# (eshell-undistract-me-active-x-window-id)

# ;; From https://gist.github.com/codecoll/66b40f524111f0dff75921784a4b2095
# (defun eshell-undistract-me-sec-to-human (secs)
#   "Convert `SECS' to human readable time format of HH:MM:SS."
#   (let ((hours (/ secs 3600))
# 	(minutes (/ (% secs 3600) 60))
# 	(seconds (% secs 60)))
#     (format "%s%s%s"
#             (if (> hours 0)
# 		(format "%sh " hours)
#               "")
#             (if (> minutes 0)
# 		(format "%sm " minutes)
#               "")
#             (if (> seconds 0)
# 		(format "%ss" seconds)
#               ""))))

# ;;;###autoload
# (defun eshell-undistract-me-before-prompt ()
#   "Hook this command into `eshell-before-prompt-hook'."
#   (if eshell-undistract-me-last-command-started
#       (let ((now (eshell-undistract-me-get-now))
# 	    (current-window (eshell-undistract-me-active-x-window-id)))
# 	(if (or (not (eq current-window eshell-undistract-me-last-window))
# 	       (getenv "IGNORE WINDOW CHECK")
# 	       (eq current-window "nowindowid"))
# 	    (let ((time-taken (- now eshell-undistract-me-last-command-started))
# 		  (time-taken-human (eshell-undistract-me-sec-to-human (- now eshell-undistract-me-last-command-started))))
# 	      (if (and (> time-taken eshell-undistract-me-long-running-command-timeout)
# 		     (getenv "DISPLAY"))
# 		  (let ((icon "dialog-information")
# 			(urgency "low"))
# 		    (shell-command
# 		     (concat
# 		      "notify-send"
# 		      " -i " icon
# 		      " -u " urgency
# 		      " \"Command completed in " time-taken-human " " eshell-undistract-me-last-command "\""))
# 		    (if eshell-undistract-me-play-sound
# 			(shell-command
# 			 (concat
# 			  eshell-undistract-me-sound-command " " eshell-undistract-me-sound-path)))))))))
#   nil)

# ;;;###autoload
# (defun eshell-undistract-me-pre-command ()
#   "Hook this command into `eshell-pre-command-hook'."
#   (setq
#    eshell-undistract-me-last-command-started (eshell-undistract-me-get-now)
#    eshell-undistract-me-last-command (getenv "1")
#    eshell-undistract-me-last-window (eshell-undistract-me-active-x-window-id))
#   nil)

# ;; (provide 'eshell-undistract-me)

# ;;; eshell-undistract-me.el ends here
# #+end_src

# ** app-launcher

# #+begin_src emacs-lisp :tangle yes
# ;;; app-launcher.el --- Launch applications from Emacs -*- lexical-binding: t -*-

# ;; Author: Sebastien Waegeneire
# ;; Created: 2020
# ;; License: GPL-3.0-or-later
# ;; Version: 0.1
# ;; Package-Requires: ((emacs "27.1"))
# ;; Homepage: https://github.com/sebastienwae/app-launcher

# ;; This file is not part of GNU Emacs.

# ;; This program is free software: you can redistribute it and/or modify
# ;; it under the terms of the GNU General Public License as published by
# ;; the Free Software Foundation, either version 3 of the License, or
# ;; (at your option) any later version.

# ;; This program is distributed in the hope that it will be useful,
# ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
# ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# ;; GNU General Public License for more details.

# ;; You should have received a copy of the GNU General Public License
# ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

# ;;; Commentary:

# ;; app-launcher define the `app-launcher-run-app' command which uses
# ;; Emacs standard completion feature to select an application installed
# ;; on your machine and launch it.

# ;;; Acknowledgements:

# ;; This package uses code from the Counsel package by Oleh Krehel.
# ;; https://github.com/abo-abo/swiper

# (require 'xdg)
# (require 'cl-seq)

# (defcustom app-launcher-apps-directories
#   (mapcar (lambda (dir) (expand-file-name "applications" dir))
# 	  (cons (xdg-data-home)
# 		(xdg-data-dirs)))
#   "Directories in which to search for applications (.desktop files)."
#   :type '(repeat directory))

# (defcustom app-launcher--annotation-function #'app-launcher--annotation-function-default
#   "Define the function that genereate the annotation for each completion choices."
#   :type 'function)

# (defcustom app-launcher--action-function #'app-launcher--action-function-default
#   "Define the function that is used to run the selected application."
#   :type 'function)

# (defvar app-launcher--cache nil
#   "Cache of desktop files data.")

# (defvar app-launcher--cache-timestamp nil
#   "Time when we last updated the cached application list.")

# (defvar app-launcher--cached-files nil
#   "List of cached desktop files.")

# (defun app-launcher-list-desktop-files ()
#   "Return an alist of all Linux applications.
# Each list entry is a pair of (desktop-name . desktop-file).
# This function always returns its elements in a stable order."
#   (let ((hash (make-hash-table :test #'equal))
# 	result)
#     (dolist (dir app-launcher-apps-directories)
#       (when (file-exists-p dir)
# 	(let ((dir (file-name-as-directory dir)))
# 	  (dolist (file (directory-files-recursively dir ".*\\.desktop$"))
# 	    (let ((id (subst-char-in-string ?/ ?- (file-relative-name file dir))))
# 	      (when (and (not (gethash id hash)) (file-readable-p file))
# 		(push (cons id file) result)
# 		(puthash id file hash)))))))
#     result))

# (defun app-launcher-parse-files (files)
#   "Parse the .desktop files to return usable informations."
#   (let ((hash (make-hash-table :test #'equal)))
#     (dolist (entry files hash)
#       (let ((file (cdr entry)))
# 	(with-temp-buffer
# 	  (insert-file-contents file)
# 	  (goto-char (point-min))
# 	  (let ((start (re-search-forward "^\\[Desktop Entry\\] *$" nil t))
# 		(end (re-search-forward "^\\[" nil t))
# 		(visible t)
# 		name comment exec)
# 	    (catch 'break
# 	      (unless start
# 		(message "Warning: File %s has no [Desktop Entry] group" file)
# 		(throw 'break nil))

# 	      (goto-char start)
# 	      (when (re-search-forward "^\\(Hidden\\|NoDisplay\\) *= *\\(1\\|true\\) *$" end t)
# 		(setq visible nil))
# 	      (setq name (match-string 1))

# 	      (goto-char start)
# 	      (unless (re-search-forward "^Type *= *Application *$" end t)
# 		(throw 'break nil))
# 	      (setq name (match-string 1))

# 	      (goto-char start)
# 	      (unless (re-search-forward "^Name *= *\\(.+\\)$" end t)
# 		(push file counsel-linux-apps-faulty)
# 		(message "Warning: File %s has no Name" file)
# 		(throw 'break nil))
# 	      (setq name (match-string 1))

# 	      (goto-char start)
# 	      (when (re-search-forward "^Comment *= *\\(.+\\)$" end t)
# 		(setq comment (match-string 1)))

# 	      (goto-char start)
# 	      (unless (re-search-forward "^Exec *= *\\(.+\\)$" end t)
# 		;; Don't warn because this can technically be a valid desktop file.
# 		(throw 'break nil))
# 	      (setq exec (match-string 1))

# 	      (goto-char start)
# 	      (when (re-search-forward "^TryExec *= *\\(.+\\)$" end t)
# 		(let ((try-exec (match-string 1)))
# 		  (unless (locate-file try-exec exec-path nil #'file-executable-p)
# 		    (throw 'break nil))))

# 	      (puthash name
# 		       (list (cons 'file file)
# 			     (cons 'exec exec)
# 			     (cons 'comment comment)
# 			     (cons 'visible visible))
# 		       hash))))))))

# (defun app-launcher-list-apps ()
#   "Return list of all Linux .desktop applications."
#   (let* ((new-desktop-alist (app-launcher-list-desktop-files))
# 	 (new-files (mapcar 'cdr new-desktop-alist)))
#     (unless (and (equal new-files app-launcher--cached-files)
# 		 (null (cl-find-if
# 			(lambda (file)
# 			  (time-less-p
# 			   app-launcher--cache-timestamp
# 			   (nth 5 (file-attributes file))))
# 			new-files)))
#       (setq app-launcher--cache (app-launcher-parse-files new-desktop-alist))
#       (setq app-launcher--cache-timestamp (current-time))
#       (setq app-launcher--cached-files new-files)))
#   app-launcher--cache)

# (defun app-launcher--annotation-function-default (choice)
#   "Default function to annotate the completion choices."
#   (let ((str (cdr (assq 'comment (gethash choice app-launcher--cache)))))
#     (when str (concat " - " (propertize str 'face 'completions-annotations)))))

# (defun app-launcher--action-function-default (selected)
#   "Default function used to run the selected application."
#   (let* ((exec (cdr (assq 'exec (gethash selected app-launcher--cache))))
# 	 (command (let (result)
# 		    (dolist (chunk (split-string exec " ") result)
# 		      (unless (or (equal chunk "%U")
# 				  (equal chunk "%F")
# 				  (equal chunk "%u")
# 				  (equal chunk "%f"))
# 			(setq result (concat result chunk " ")))))))
#     (call-process-shell-command command nil 0 nil)))

# ;;;###autoload
# (defun app-launcher-run-app (&optional arg)
#   "Launch an application installed on your machine.
# When ARG is non-nil, ignore NoDisplay property in *.desktop files."
#   (interactive)
#   (let* ((candidates (app-launcher-list-apps))
# 	 (result (completing-read
# 		  "Run app: "
# 		  (lambda (str pred flag)
# 		    (if (eq flag 'metadata)
# 			'(metadata
# 			  (annotation-function . (lambda (choice)
# 						   (funcall
# 						    app-launcher--annotation-function
# 						    choice))))
# 		      (complete-with-action flag candidates str pred)))
# 		  (lambda (x y)
# 		    (if arg
# 			t
# 		      (cdr (assq 'visible y))))
# 		  t nil 'app-launcher nil nil)))
#     (funcall app-launcher--action-function result)))

# ;; Provide the app-launcher feature
# ;; (provide 'app-launcher)
# #+end_src
