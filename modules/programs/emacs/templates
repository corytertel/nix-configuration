;; -*- mode: lisp -*-

fundamental-mode ;; Available everywhere

(today (format-time-string "%Y-%m-%d"))


prog-mode

(fixme (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "FIXME ")
(todo (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "TODO ")
(bug (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "BUG ")
(hack (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start) "HACK ")


scheme-mode

(lambda "lambda (" p ")" n> r>)
(define "define " p "\n  " p)
(let "let (" p ")" n> r> "")
(cond "cond"n>
      "("(p "(predicate)")" "(p "return")")"n>
      "(t"                   (p "default")")")


c-mode c++-mode

(if "if ("  (p "true") ") {" n> r> (p "true") n "}")
(print "printf(" (p "\"The value of ___ is\"" text) (r ", ")")")
(for "for (" "int " (p "i" var) "=" (p "0") "; "
     (s var) "< " (p "max" max) "; "
     (s var) "++" "){"
     n> (p "/* your code here*/")
     n "}")
(main "int main(int argc, char* argv[])"n"{" n> (r "/*Your Code Here*/") n"}")

(struct "struct "(p "Name")" {" n> (p "/* fields */") n "};")

c-mode c++-mode :when (re-search-backward "^\\S-*$" (line-beginning-position) 'noerror)

(include "#include <" (p (concat (file-name-base (or (buffer-file-name) (buffer-name))) ".h")) ">")
(include "#include \"" (p (concat (file-name-base (or (buffer-file-name) (buffer-name))) ".h")) "\"")

c++-mode

(for "for (" (p "range-declaration") " : " (p "range-expression") ") {"
     n> (p "/* your code here*/")
     n "}")

(print
 "std::cout << " (p "hello, world!\n") ";")
(test
 "TEST_CASE(" (p  "\"Check \"" test-name)", ["(p "suite")"]) {"n>
 (p "// TODO")n>
 "}")

(test-generator
 "GENERATE(" (p "range()" test-name) ")")

(test-range
 "range ("(p  "FROM") "," (p "TO")")")

(stdlib
 "#include <iostream>")

;; STL Collections
(array
 "std::array<" (p "Type") ", "(p "Length")"> "(p "Name")";")
(vector
 "std::vector<"(p "Type")"> "(p "Name")";")

(deque
 "std::deque<" (p "Type") "> " (p "Name") ";")

(flist
 "std::forward_list<"(p "Type")"> "(p "Name"));

(list
 "std::list<"(p "Type")"> "(p "Name")";")

(set
 "std::set<"(p "Type")"> "(p "Name")";")

(map
 "std::map<"(p "KeyType")", "(p "ValueType")"> "(p "Name")";")

;; ## STL smart pointers
;; # std::shared_ptr
;; snippet msp
;; 	std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
;; snippet amsp
;; 	auto ${1} = std::make_shared<${2:T}>(${3});
;; # std::unique_ptr
;; snippet mup
;; 	std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});
;; snippet amup
;; 	auto ${1} = std::make_unique<${2:T}>(${3});

(class
 "/*! \\class " (p "ClassName" name)n>
 "*  \\brief " (p "Short Description Of Class")n>
 "*"n>
 "*  " (p "Detailed Description")n>
 "*/"n>
 "class " (or name (buffer-name)) " {" n>
 "private:"n n>

 (p "Type" ptype)" " (p "Name" pname)n n>

 "public:"n>
 (s name)"("(s ptype)" "(s pname)");"n>
 "virtual ~"(s name)"();"n
 "};")

;; # member function implementation
;; snippet mfun
;; 	${4:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3}) {
;; 		${0}
;; 	}

;; ##
;; ## Input/Output
;; # std::cout
;; snippet cout
;; 	std::cout << ${1} << std::endl;
;; # std::cin
;; snippet cin
;; 	std::cin >> ${1};


;; # foreach
;; snippet fore
;; 	for (${1:auto} ${2:i} : ${3:container}) {
;; 		${4}
;; 	}

;; ## Lambdas
;; # lamda (one line)
;; snippet ld
;; 	[${1}](${2}){${3}};

cmake-mode

(init
 "cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_EXPORT_COMPILE_COMMANDS true)
set(CMAKE_VERBOSE_MAKEFILE true)
set(CMAKE_EXPORT_COMPILE_COMMANDS true)"n
 "option(ENABLE_EXTRA_CHECKS \"Enabel Additional Warnings and Sanitizer Checks\" false)
if (ENABLE_EXTRA_CHECKS)
  message(\"extra checks are on\")
  set(CMAKE_BUILD_TYPE Debug)
  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Werror -Wall -Wextra\")
  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=address\")
  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=undefined\")
endif()"
 "project("(p "ProjectName" projname)"  LANGUAGES CXX )"n n

 "add_executable("(s projname) " " (p "path/to/main")")")

(src
 "add_subdirectory("(p "src")")"n)

(lib
 "add_library(" (p "libname") " " (p "path/to/sources")")")

python-mode

(for "for " (p "needle") " in " (p "heystack") ":"n>
     (p "# code goes here"))
(if "if " (p "condition" var) ":"n>
    (p "# code goes here"))

latex-mode

(begin "\\begin{" (s env) "}" > n> r> "\\end{" (s env) "}")
(frac "\\frac{" p "}{" p "}")
(enumerate "\\begin{enumerate}\n\\item " r> n> "\\end{enumerate}")
(itemize "\\begin{itemize}\n\\item " r> n> "\\end{itemize}")

emacs-lisp-mode

(autoload ";;;###autoload")
(lambda "lambda (" p ")" n> r>)
(defvar "defvar " p "\n  \"" p "\"")
(defvar-local "defvar-local " p "\n  \"" p "\"")
(defconst "defconst " p "\n  \"" p "\"")
(defcustom "defcustom " p "\n  \"" p "\"" n> ":type '" p)
(defface "defface " p " '((t :inherit " p "))\n  \"" p "\"")
(defgroup "defgroup " p " nil\n  \"" p "\"" n> ":group '" p n> ":prefix \"" p "-\"")
(defmacro "defmacro " p " (" p ")\n  \"" p "\"" n> r>)
(defalias "defalias '" p " '" p)
(defun "defun " p " (" p ")\n  \"" p "\"" n> r>)
(if-let "if-let (" p ")" n> r>)
(when-let "when-let (" p ")" n> r>)
(if-let* "if-let* (" p ")" n> r>)
(when-let* "when-let* (" p ")" n> r>)
(and-let* "and-let* (" p ")" n> r>)
(cond "cond"n>
      "("(p "(predicate)")" "(p "return")")"n>
      "(t"                   (p "default")")")
(pcase "pcase " (p "scrutinee") n "(" q ")" >)
(let "let (" p ")" n> r>)
(let* "let* (" p ")" n> r>)
(letrec "letrec (" p ")" n> r>)
(dotimes "dotimes (" p ")" n> r>)
(dolist "dolist (" (p "needle") " " (p "hay-stack") " " (p "optional-returned-variable")")"n>
        (r "(message needle)"))
(cl-loop "cl-loop for " p " in " p " do" n> r>)
(command "defun " p " (" p ")\n  \"" p "\"" n> "(interactive" p ")" n> r>)
(advice "defun " (p "adv" name) " (&rest app)" n> p n> "(apply app))" n>
        "(advice-add #'" (p "fun") " " (p ":around") " #'" (s name))
(provide "(provide '" (file-name-base (or (buffer-file-name) (buffer-name))) ")" n
         ";;; " (file-name-nondirectory (or (buffer-file-name) (buffer-name))) " ends here" n)

lisp-mode sly-mrepl-mode

(lambda "lambda (" p ")" n> r>)
(defmacro "defmacro " p " (" p ")\n  \"" p "\"" n> r>)
(defvar "defvar *" p "*\n  \"" p "\"")
(defparameter "defparameter *" p "*\n  \"" p "\"")
(defconst "defparameter +" p "+\n  \"" p "\"")
(dolist "dolist (" (p "needle") " " (p "hay-stack") " " (p "optional-returned-variable")")"n>
        (r "(message needle)"))
(let "let (" p ")" n> r>)

(defun "declaim (ftype (function (" (p "arg-type-1 arg-type-2 ..." )") "
       (p "return-type") ") "
       (p "function-name" func-name)"))"n>
       "(defun " (s func-name) " (" p ")\n  \"" p "\"" n> r>)

(ftype "declaim (ftype (function (" (p "arg-type-1 arg-type-2 ..." )") "
       (p "return-type") ") "
       (p "function-name" func-name)")")

(the "the "(p "type") " " (r "variable"))

(deftype "deftype " (p "Name Of Type") " ()"n>
  "`(satisfies " (p "Predicate To Check Type") ")")

(typecase "typecase " (r "variable")n>
          "(" (p "type")" "(p "(do this)")")"n>
          "(t "           (p "default")")")

(defclass "defclass " (p "classname " classname) " ()"
  "((" (p "slotname" slot) ;; " :reader " (format "%s-%s" classname slot)
  n>
  ;; ":initarg " (concat ":" slot)n>
  ":type " (p "string")n>
  ":initform " (p "default")n>
  ":documentation \"" (p "Slot Description.")"\"))"n>
  "(:documentation \"" (p "A general HTTP request.") "\")")

(defstruct "defstruct "(p "Name") n> "("(p "slot")" " (p "default-value") " :type" (p "type") ")")

(in-package "(defpackage " (p "my-package" package) n>
            "(:use :cl " (p ":alexandria")"))"n>
            "(in-package :" (s package) ")")

(defpackage "defpackage " (p "my-package")n>
  "(:use :cl)"n>
  "(:import-from :" (p "alexandria")n>
  (p ":with-gensyms :curry")")")

(doc
 "Syntax:"n n
 (p "function-name") "(" (p "args" arg)")"" => " (p "return-value" ret)n n
 "Arguments and Values:"n n
 (s arg) "--a " (p "type-of-arg") n
 (s ret) "-- " (p "return-value-type")
 "

Description:

"
 (p "description of function")
 )

java-mode

(class "public class "
       (p (file-name-base (or (buffer-file-name) (buffer-name))))
       " {" n> r> n "}")
(print "System.out.println(" (r "What to print" print) ");")
(debug "System.out.println(""\"The value of "
       (p "var") " is \" + "
       (r "var" print) ");")

org-mode

(title "#+title: " p n "#+author: Cory Tertel" n "#+language: en" n n)
(quote "#+begin_quote" n> r> n> "#+end_quote")
(example "#+begin_example" n> r> n> "#+end_example")
(center "#+begin_center" n> r> n> "#+end_center")
(comment "#+begin_comment" n> r> n> "#+end_comment")
(verse "#+begin_verse" n> r> n> "#+end_verse")

(src "#+begin_src " p n> r> n> "#+end_src")
(lisp "#+begin_src lisp" n> r> n "#+end_src"
      :post (progn (unless sly-port
                     (sly))
                   (tempel-done) (org-edit-src-code)))

(readmeorg
 "#+TITLE: " (p "Project title: ") n
 (p "A short, one-line description of the project: ") n
 n
 "* Overview" n
 p "# A longer description of the project" n
 n
 "** Features" n
 "** History" n
 "** Motivation" n
 "* Usage" n
 p "# Examples of usage" n
 n
 "* Documentation" n
 "* License" n
 "Copyright (c) " (format-time-string "%Y") " " (p "Authors: ") n
 "Licensed under the " p "GPL3 License." n
 n
 "* COMMENT Local Variables" n
 "# Local Variables:" n
 "# eval: (add-hook 'after-save-hook #'org-md-export-to-markdown nil t)" p n
 "# End:")

sh-mode

(is-installed "command -v " (r "program") " > /dev/null")
(env "#!/bin/env sh")
(for "for " (p "needle") " in " (p "haystack")"; do" n>
     (p "#code")n
     "done")
(if "if [ " (p "condition")" ]; then"n> (r "#code")n "fi")
(case (sh-case))
(readfile "while IFS= read -r line || [ -n "(p "\"$line\"")" ]; do"n>
          (p "printf '%s\\n' \"$line\"")n
          "done < \"file\"")

(while "while [ "(p "\"$start\"") " -le " (p "\"$end\"")" ]; do"n>
       (p "#code")n
       "done")

haskell-mode

(main "main :: IO ()"n
      "main = do print " (p "hello world"))

html-mode web-mode

(html (html-html5-template))

javascript-mode typescript-mode

(print "console.log(" (r "What to print")")")
(log   "console.log(" (r "What to print")")")
(json  "JSON.stringify(" (r "Your JSON HERE" )")")
(test  "test(" (r "'Name Of Test'" ) ", async () => {" n> r> n "}"")")

typescript-mode

(interface "interface " (p "intrefaceName") " {"n>
           (p "item")": " (p "any") ";"n
           "}")

rust-mode

(main "pub fn main() {"n>
      "// your code here"n
      "}")

(test "#[test]"n
      "fn " (p "function_name") "_test() {"n>
      "assert!( 1==1 )"n
      "}")

(match "match " (p "var") " {"n>
       (p "pattern x") " => " (p "1 + x")n
       "}")
(derive "#[derive(" (p "Debug") ")]")
(enum "pub enum " (p "NameOfSumType") " {" n>
      (p "Constructor1") "(" (p "")")," n
      "}")
(struct "struct " (p "Foo") " {" n> (p "bar") ": " (p "i32")"," n "}")
