{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PatternGuards         #-}
{-# LANGUAGE CPP                   #-}
{-# OPTIONS_GHC -Wunused-imports #-}

import XMonad hiding ((|||))

import Data.Monoid (mappend)
import Data.Map (fromList, lookup)
import Data.Maybe (fromJust, isJust)
import Data.Ratio ((%)) -- for video

import Control.Monad
import Foreign.C.Types(CInt)

import Graphics.X11.ExtraTypes.XF86

import System.Exit

import XMonad.Util.SpawnOnce
import XMonad.Util.Run
import XMonad.Util.EZConfig
import XMonad.Util.Image
import XMonad.Util.PositionStore
import XMonad.Util.XUtils

import XMonad.Layout.Spacing
import XMonad.Layout.ThreeColumns
import XMonad.Layout.MultiToggle
import XMonad.Layout.NoBorders
import XMonad.Layout.ResizableTile
import XMonad.Layout.IfMax
-- import XMonad.Layout.NoFrillsDecoration
import XMonad.Layout.BorderResize
-- import XMonad.Layout.Tabbed
-- import XMonad.Layout.Decoration
-- import XMonad.Layout.DecorationAddons
import XMonad.Layout.PerWorkspace (onWorkspace)
import XMonad.Layout.Minimize
import XMonad.Layout.Maximize
import XMonad.Layout.Reflect (reflectHoriz)
import XMonad.Layout.LayoutCombinators
import XMonad.Layout.BinarySpacePartition
import XMonad.Layout.DraggingVisualizer
import XMonad.Layout.SubLayouts
import XMonad.Layout.StateFull
import XMonad.Layout.Renamed (Rename (Replace), renamed)
import XMonad.Layout.WindowArranger
import XMonad.Layout.LayoutModifier

import XMonad.Hooks.InsertPosition
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.DynamicLog
import XMonad.Hooks.EwmhDesktops (ewmh, ewmhFullscreen)
import XMonad.Hooks.ManageHelpers
  (isFullscreen, isDialog,  doFullFloat, doCenterFloat, doRectFloat, composeOne, isInProperty)
import XMonad.Hooks.SetWMName (setWMName)
import XMonad.Hooks.Minimize

import XMonad.Actions.Navigation2D (switchLayer)
import XMonad.Actions.FloatKeys
import XMonad.Actions.FloatSnap
import XMonad.Actions.Search
import XMonad.Actions.WindowMenu
import XMonad.Actions.Minimize
import XMonad.Actions.CycleWS
import XMonad.Actions.WindowGo (runOrRaise)
import XMonad.Actions.WithAll (killAll)
import XMonad.Actions.CycleWindows

-- import XMonad.Prompt
-- import XMonad.Prompt.Shell (shellPrompt)
-- import XMonad.Prompt.Input
-- import XMonad.Prompt.FuzzyMatch
-- import XMonad.Prompt.Window
-- import XMonad.Prompt.XMonad

import qualified XMonad.StackSet as W
import qualified XMonad.Core as C
import qualified Data.Map as M
import qualified XMonad.Layout.WindowNavigation as WN
import qualified XMonad.Layout.BoringWindows as BW
import qualified XMonad.Prelude as P
import qualified XMonad.Util.ExtensibleState as XS

import XMonad.Hooks.UrgencyHook
import XMonad.Util.NamedWindows (getName)
import XMonad.Util.Invisible
import XMonad.Util.Font
import qualified Data.Set as S

myTerminal = "urxvtc"

myFocusFollowsMouse :: Bool
myFocusFollowsMouse = False

myClickJustFocuses :: Bool
myClickJustFocuses = False

myBorderWidth = 4

myNormalBorderColor  = "#eeeeee"
myFocusedBorderColor = "#e8e8e8"

barWidth = 80

myModMask       = mod4Mask

myWorkspaces = [ "Ⅰ", "Ⅱ", "Ⅲ", "Ⅳ", "Ⅴ" ]

myKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList $ []

myAdditionalKeys :: [(String, X ())]
myAdditionalKeys =
    -- Resize prompt
    -- [ ("M-r", resizePrompt)
    -- , ("M-S-r", resizePrompt)
    -- Float prompt
    -- , ("M-f", floatPrompt)
    -- , ("M-S-f", floatPrompt)
    -- Audio Controls
    [ ("<XF86AudioLowerVolume>", spawn "amixer -q set Master unmute 2%-")
    , ("<XF86AudioRaiseVolume>", spawn "amixer -q set Master unmute 2%+")
    , ("<XF86AudioMute>", spawn "amixer -q set Master toggle")
    , ("<XF86AudioNext>", spawn "audacious --fwd")
    , ("<XF86AudioPrev>", spawn "audacious --rew")
    , ("<XF86AudioPlay>", spawn "audacious --play-pause")
    , ("<XF86AudioStop>", spawn "audacious --stop")
    , ("<F5>", spawn "amixer -q set Master unmute 2%-")
    , ("<F6>", spawn "amixer -q set Master unmute 2%+")
    , ("<F7>", spawn "amixer -q set Master toggle")
    , ("<F10>", spawn "audacious --fwd")
    , ("<F9>", spawn "audacious --rew")
    , ("<F8>", spawn "audacious --play-pause")
    -- Screenshots
    , ("<Print>", spawn "flameshot full -p ~/Screenshots/")
    -- Keyboard Layout
    , ("S-C-<Space>", spawn "/home/cory/manual_installs/layout_switch.sh")
    , ("S-M-<Space>", spawn "setxkbmap us")

    ----------------------------------------------------------------------
    --                            Audio                                 --
    ----------------------------------------------------------------------
    , ("C-. a a", runOrRaise "audacious" (className =? "Audacious"))
    , ("C-. a n", spawn "audacious --fwd")
    , ("C-. a p", spawn "audacious --rew")
    , ("C-. a t", spawn "audacious --play-pause")
    , ("C-. a s", spawn "audacious --stop")

    ----------------------------------------------------------------------
    --                            Launch                                --
    ----------------------------------------------------------------------
    , ("C-. <Space>", spawn "rofi -show drun -modi drun,run --icon-theme \"Tango\" show-icons")
    , ("C-. d", runOrRaise "discord" (className =? "discord"))
    , ("C-. e", spawn "emacsclient -c")
    , ("C-. C-e", spawn "emacs")
    , ("C-. w", spawn "firefox")
    , ("C-. C-w", spawn "pcmanfm-qt --new-window")
    , ("C-. C-g", runOrRaise "steam" (className =? "Steam"))
    , ("C-. t", spawn $ myTerminal)

    ----------------------------------------------------------------------
    --                           Commands                               --
    ----------------------------------------------------------------------
    , ("C-. s", spawn "flameshot full -p ~/Screenshots/")
    , ("C-. C-s", spawn "flameshot gui")
    , ("C-. C-m", sendMessage ToggleStruts)
    , ("C-. u", withFocused (sendMessage . maximizeRestore))
    , ("C-. i", withFocused minimizeWindow)
    , ("C-. C-i", withLastMinimized maximizeWindowAndFocus)
    , ("C-. M-r", spawn "xmonad --recompile; xmonad --restart")

    ----------------------------------------------------------------------
    --                     Basic Window Management                      --
    ----------------------------------------------------------------------
    , ("C-. b", sendMessage $ WN.Go WN.L)
    , ("C-. n", sendMessage $ WN.Go WN.D)
    , ("C-. p", sendMessage $ WN.Go WN.U)
    , ("C-. f", sendMessage $ WN.Go WN.R)
    , ("C-. C-b", sendMessage $ WN.Swap WN.L)
    , ("C-. C-n", sendMessage $ WN.Swap WN.D)
    , ("C-. C-p", sendMessage $ WN.Swap WN.U)
    , ("C-. C-f", sendMessage $ WN.Swap WN.R)

    ----------------------------------------------------------------------
    --                       Buffers (Windows)                          --
    ----------------------------------------------------------------------
    -- , ("C-. M-b", windowPrompt windowXPConfig Goto allWindows)  -- Goto buffers
    -- , ("C-. M-b", windowPrompt windowXPConfig Bring allWindows) -- Bring buffer
    , ("C-. k", kill)                                     -- Kill buffer
    -- , ("bD", killAll)                                      -- Kill every buffer
    , ("C-. C-g C-n", onGroup W.focusDown')               -- Next buffer
    , ("C-. C-g C-p", onGroup W.focusUp')                 -- Prev buffer
    , ("C-. C-g n", windows W.focusDown)                  -- Next buffer alt
    , ("C-. C-g p", windows W.focusUp)                    -- Prev buffer alt
    -- , ("bsn", onGroup swapDown')                          -- Swap next buffer
    -- , ("bsp", onGroup swapUp')                            -- Swap prev buffer
    -- , ("bsN", windows W.swapDown)                         -- Swap next buffer alt
    -- , ("bsP", windows W.swapUp)                           -- Swap prev buffer alt
    , ("C-. C-g C-s", sendMessage Swap)                   -- Swap groups
    , ("C-. C-m C-b", sendMessage $ pullGroup L)              -- Merge left
    , ("C-. C-m C-n", sendMessage $ pullGroup D)              -- Merge down
    , ("C-. C-m C-p", sendMessage $ pullGroup U)              -- Merge up
    , ("C-. C-m C-f", sendMessage $ pullGroup R)              -- Merge right

    ----------------------------------------------------------------------
    --                           Workspaces                             --
    ----------------------------------------------------------------------
    -- , ("wb", sendMessage Balance)
    -- , ("wB", sendMessage Equalize)
    -- , ("wn", moveTo Next NonEmptyWS)
    -- , ("wp", moveTo Prev NonEmptyWS)
    -- , ("wN", nextWS)
    -- , ("wP", prevWS)
    , ("C-. o !", withFocused (sendMessage . MergeAll)) -- Window focus
    -- , ("C-. C-f", floatPrompt) -- Window float
    -- , ("C-. r", resizePrompt) -- Window resize
    , ("C-. C-r", sendMessage Rotate) -- Window rotate
    , ("C-. o #", withFocused (sendMessage . UnMerge)) -- Window split
    , ("C-. o @", withFocused (sendMessage . UnMerge) >>
                  sendMessage Rotate) -- Window split
    , ("C-. C-l", sendMessage NextLayout)
    -- , ("M-S-C-j",  sendMessage $ SplitShift Prev)
    -- , ("M-S-C-k",  sendMessage $ SplitShift Next)
    ]
    ++
    -- Workspace switching and buffer move to workspace
    -- Must use special chars to account for custom keyboard layout
    [ (otherModMasks ++ [key], action tag)
    | (tag, key)  <- zip myWorkspaces "!@#$%"
    , (otherModMasks, action) <-
        [ ("C-. ", windows . W.greedyView) , ("C-. M1-", windows . W.shift)]
    ]
    ++
    [ (otherModMasks ++ [key], action tag)
    | (tag, key)  <- zip myWorkspaces "12345"
    , (otherModMasks, action) <-
        [ ("C-. ", windows . W.greedyView) , ("C-. M1-", windows . W.shift)]
    ]


------------------------------------------------------------------------

myMouseBindings (XConfig {XMonad.modMask = modm}) = M.fromList $ []

------------------------------------------------------------------------

-- buttons have 2px offset on the top to account for
-- the 4px border on the bottom of the decoration

convertToBool' :: [Int] -> [Bool]
convertToBool' = map (== 1)

convertToBool :: [[Int]] -> [[Bool]]
convertToBool = map convertToBool'

menuButton' :: [[Int]]
menuButton' = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]

menuButton :: [[Bool]]
menuButton = convertToBool menuButton'

miniButton' :: [[Int]]
miniButton' = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
               [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
               [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
               [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
               [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
               [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
               [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]]

miniButton :: [[Bool]]
miniButton = convertToBool miniButton'

maxiButton' :: [[Int]]
maxiButton' = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
               [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
               [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
               [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
               [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0],
               [1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
               [0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
               [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
               [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
               [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
               [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
               [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]]

maxiButton :: [[Bool]]
maxiButton = convertToBool maxiButton'

closeButton' :: [[Int]]
closeButton' = [[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]]

closeButton :: [[Bool]]
closeButton = convertToBool closeButton'

buttonSize :: Int
buttonSize = 27

menuButtonOffset :: Int
menuButtonOffset = 20

maximizeButtonOffset :: Int
maximizeButtonOffset = 65

minimizeButtonOffset :: Int
minimizeButtonOffset = 110

closeButtonOffset :: Int
closeButtonOffset = 20

imageTitleBarButtonHandler :: Window -> Int -> Int -> X Bool
imageTitleBarButtonHandler mainw distFromLeft distFromRight = do
    let action
          | fi distFromRight >= closeButtonOffset &&
            fi distFromRight <= closeButtonOffset + buttonSize = focus mainw >> kill >> return True
          | fi distFromRight >= maximizeButtonOffset &&
            fi distFromRight <= maximizeButtonOffset + buttonSize = focus mainw >> sendMessage (maximizeRestore mainw) >> return True
          | fi distFromRight >= minimizeButtonOffset &&
            fi distFromRight <= minimizeButtonOffset + buttonSize = focus mainw >> minimizeWindow mainw >> return True
          | otherwise = return False
    action

defaultThemeWithImageButtons :: Theme
defaultThemeWithImageButtons =
  def { fontName = "xft:NotoSans Nerd Font:style=Bold:size=11"
      , inactiveBorderColor = "#eeeeee"
      , inactiveColor = "#eeeeee"
      , inactiveTextColor = "#999999"
      , inactiveBorderWidth = 0
      , activeBorderColor = "#e8e8e8"
      , activeColor = "#e8e8e8"
      , activeTextColor = "#141404"
      , activeBorderWidth = 0
      , urgentBorderColor = "#e8e8e8"
      , urgentColor = "#e8e8e8"
      , urgentTextColor = "#e60909"
      , urgentBorderWidth = 0
      , decoHeight = 50 - myBorderWidth
      , windowTitleIcons = [ (menuButton, CenterLeft 20),
                             (closeButton, CenterRight 20),
                             (maxiButton, CenterRight 65),
                             (miniButton, CenterRight 110) ]
      }

imageButtonDeco :: (Eq a, Shrinker s) => s -> Theme
                   -> l a -> ModifiedLayout (Decoration ImageButtonDecoration s) l a
imageButtonDeco s c = decoration s c $ NFD True

newtype ImageButtonDecoration a = NFD Bool deriving (Show, Read)

instance Eq a => DecorationStyle ImageButtonDecoration a where
    describeDeco _ = "ImageButtonDeco"
    decorationCatchClicksHook _ mainw dFL dFR = imageTitleBarButtonHandler mainw dFL dFR
    decorationWhileDraggingHook _ ex ey (mainw, r) x y = handleDraggingInProgress ex ey (mainw, r) x y
    decorationAfterDraggingHook _ (mainw, _) decoWin = focus mainw >> handleScreenCrossing mainw decoWin >> return ()

windowSwitcherDecorationWithImageButtons :: (Eq a, Shrinker s) => s -> Theme
  -> l a -> ModifiedLayout (Decoration ImageWindowSwitcherDecoration s) l a
windowSwitcherDecorationWithImageButtons s c = decoration s c $ IWSD True

data ImageWindowSwitcherDecoration a = IWSD Bool deriving (Show, Read)

instance Eq a => DecorationStyle ImageWindowSwitcherDecoration a where
    describeDeco _ = "ImageWindowSwitcherDeco"

    decorationCatchClicksHook (IWSD withButtons) mainw dFL dFR = if withButtons
      then imageTitleBarButtonHandler mainw dFL dFR
      else return False
    decorationWhileDraggingHook _ ex ey (mainw, r) x y = handleTiledDraggingInProgress ex ey (mainw, r) x y
    decorationAfterDraggingHook _ (mainw, _) decoWin =
      do focus mainw
         hasCrossed <- handleScreenCrossing mainw decoWin
         unless hasCrossed $
           do sendMessage $ DraggingStopped
              performWindowSwitching mainw

handleTiledDraggingInProgress ex ey (mainw, r) x y = do
    let rect = Rectangle (x - (fi ex - rect_x r))
                         (y - (fi ey - rect_y r))
                         (rect_width  r)
                         (rect_height r)
    sendMessage $ DraggingWindow mainw rect

performWindowSwitching :: Window -> X ()
performWindowSwitching win =
    withDisplay $ \d -> do
       root <- asks theRoot
       (_, _, selWin, _, _, _, _, _) <- io $ queryPointer d root
       ws <- gets windowset
       let allWindows = W.index ws
       -- do a little double check to be sure
       if (win `elem` allWindows) && (selWin `elem` allWindows)
            then do
                let allWindowsSwitched = map (switchEntries win selWin) allWindows
                let (ls, t:rs) = break (win ==) allWindowsSwitched
                let newStack = W.Stack t (reverse ls) rs
                windows $ W.modify' $ \_ -> newStack
            else return ()
    where
        switchEntries a b x
            | x == a    = b
            | x == b    = a
            | otherwise = x

------------------------------------------------------------------------

-- $usage
-- This module is intended for layout developers, who want to decorate
-- their layouts. End users will not find here very much for them.
--
-- For examples of 'DecorationStyle' instances you can have a look at
-- "XMonad.Layout.SimpleDecoration", "XMonad.Layout.Tabbed",
-- "XMonad.Layout.DwmStyle", or "XMonad.Layout.TabBarDecoration".

-- | A layout modifier that, with a 'Shrinker', a 'Theme', a
-- 'DecorationStyle', and a layout, will decorate this layout
-- according to the decoration style provided.
--
-- For some usage examples see "XMonad.Layout.DecorationMadness".
decoration :: (DecorationStyle ds a, Shrinker s) => s -> Theme -> ds a
           -> l a -> ModifiedLayout (Decoration ds s) l a
decoration s t ds = ModifiedLayout (Decoration (I Nothing) s t ds)

-- | A 'Theme' is a record of colors, font etc., to customize a
-- 'DecorationStyle'.
--
-- For a collection of 'Theme's see "XMonad.Util.Themes"
data Theme =
    Theme { activeColor         :: String                  -- ^ Color of the active window
          , inactiveColor       :: String                  -- ^ Color of the inactive window
          , urgentColor         :: String                  -- ^ Color of the urgent window
          , activeBorderColor   :: String                  -- ^ Color of the border of the active window
          , inactiveBorderColor :: String                  -- ^ Color of the border of the inactive window
          , urgentBorderColor   :: String                  -- ^ Color of the border of the urgent window
          , activeBorderWidth   :: Dimension               -- ^ Width of the border of the active window
          , inactiveBorderWidth :: Dimension               -- ^ Width of the border of the inactive window
          , urgentBorderWidth   :: Dimension               -- ^ Width of the border of the urgent window
          , activeTextColor     :: String                  -- ^ Color of the text of the active window
          , inactiveTextColor   :: String                  -- ^ Color of the text of the inactive window
          , urgentTextColor     :: String                  -- ^ Color of the text of the urgent window
          , fontName            :: String                  -- ^ Font name
          , decoWidth           :: Dimension               -- ^ Maximum width of the decorations (if supported by the 'DecorationStyle')
          , decoHeight          :: Dimension               -- ^ Height of the decorations
          , windowTitleAddons   :: [(String, Align)]       -- ^ Extra text to appear in a window's title bar.
                                                           --    Refer to for a use "XMonad.Layout.ImageButtonDecoration"
          , windowTitleIcons    :: [([[Bool]], Placement)] -- ^ Extra icons to appear in a window's title bar.
                                                           --    Inner @[Bool]@ is a row in a icon bitmap.
          } deriving (Show, Read)

-- | The default xmonad 'Theme'.
instance Default Theme where
  def =
    Theme { activeColor         = "#999999"
          , inactiveColor       = "#666666"
          , urgentColor         = "#FFFF00"
          , activeBorderColor   = "#FFFFFF"
          , inactiveBorderColor = "#BBBBBB"
          , urgentBorderColor   = "##00FF00"
          , activeBorderWidth   = 2
          , inactiveBorderWidth = 2
          , urgentBorderWidth   = 2
          , activeTextColor     = "#FFFFFF"
          , inactiveTextColor   = "#BFBFBF"
          , urgentTextColor     = "#FF0000"
#ifdef XFT
          , fontName            = "xft:monospace"
#else
          , fontName            = "-misc-fixed-*-*-*-*-10-*-*-*-*-*-*-*"
#endif
          , decoWidth           = 400
          , decoHeight          = 40
          , windowTitleAddons   = []
          , windowTitleIcons    = []
          }

-- | A 'Decoration' layout modifier will handle 'SetTheme', a message
-- to dynamically change the decoration 'Theme'.
newtype DecorationMsg = SetTheme Theme
instance Message DecorationMsg

-- | The 'Decoration' state component, where the list of decorated
-- window's is zipped with a list of decoration. A list of decoration
-- is a list of tuples, a 'Maybe' 'Window' and a 'Maybe Rectangle'.
-- The 'Window' will be displayed only if the rectangle is of type
-- 'Just'.
data DecorationState =
    DS { decos :: [(OrigWin,DecoWin)]
       , font  :: XMonadFont
       }
type DecoWin = (Maybe Window, Maybe Rectangle)
type OrigWin = (Window,Rectangle)

-- | The 'Decoration' 'LayoutModifier'. This data type is an instance
-- of the 'LayoutModifier' class. This data type will be passed,
-- together with a layout, to the 'ModifiedLayout' type constructor
-- to modify the layout by adding decorations according to a
-- 'DecorationStyle'.
data Decoration ds s a =
    Decoration (Invisible Maybe DecorationState) s Theme (ds a)
    deriving (Show, Read)

-- | The 'DecorationStyle' class, defines methods used in the
-- implementation of the 'Decoration' 'LayoutModifier' instance. A
-- type instance of this class is passed to the 'Decoration' type in
-- order to decorate a layout, by using these methods.
class (Read (ds a), Show (ds a), Eq a) => DecorationStyle ds a where

    -- | The description that the 'Decoration' modifier will display.
    describeDeco :: ds a -> String
    describeDeco ds = show ds

    -- | Shrink the window's rectangle when applying a decoration.
    shrink :: ds a -> Rectangle -> Rectangle -> Rectangle
    shrink _ (Rectangle _ _ dw _) (Rectangle x y w h) = Rectangle x y (w - dw) h

    -- | The decoration event hook
    decorationEventHook :: ds a -> DecorationState -> Event -> X ()
    decorationEventHook ds s e = handleMouseFocusDrag ds s e

    -- | A hook that can be used to catch the cases when the user
    -- clicks on the decoration. If you return True here, the click event
    -- will be considered as dealt with and no further processing will take place.
    decorationCatchClicksHook :: ds a
                              -> Window
                              -> Int    -- ^ distance from the left where the click happened on the decoration
                              -> Int    -- ^ distance from the right where the click happened on the decoration
                              -> X Bool
    decorationCatchClicksHook _ _ _ _ = return False

    -- | This hook is called while a window is dragged using the decoration.
    -- The hook can be overwritten if a different way of handling the dragging
    -- is required.
    decorationWhileDraggingHook :: ds a -> CInt -> CInt -> (Window, Rectangle) -> XMonad.Position -> XMonad.Position -> X ()
    decorationWhileDraggingHook _ ex ey (mainw, r) x y = handleDraggingInProgress ex ey (mainw, r) x y

    -- | This hoook is called after a window has been dragged using the decoration.
    decorationAfterDraggingHook :: ds a -> (Window, Rectangle) -> Window -> X ()
    decorationAfterDraggingHook _ds (mainw, _r) _decoWin = focus mainw

    -- | The pure version of the main method, 'decorate'.
    pureDecoration :: ds a -> Dimension -> Dimension -> Rectangle
                   -> W.Stack a -> [(a,Rectangle)] -> (a,Rectangle) -> Maybe Rectangle
    pureDecoration _ _ ht _ s _ (w,Rectangle x y wh ht') = if isInStack s w && (ht < ht')
                                                             then Just $ Rectangle x y wh ht
                                                             else Nothing

    -- | Given the theme's decoration width and height, the screen
    -- rectangle, the windows stack, the list of windows and
    -- rectangles returned by the underlying layout and window to be
    -- decorated, tupled with its rectangle, produce a 'Just'
    -- 'Rectangle' or 'Nothing' if the window is not to be decorated.
    decorate :: ds a -> Dimension -> Dimension -> Rectangle
             -> W.Stack a -> [(a,Rectangle)] -> (a,Rectangle) -> X (Maybe Rectangle)
    decorate ds w h r s wrs wr = return $ pureDecoration ds w h r s wrs wr

-- | The default 'DecorationStyle', with just the default methods'
-- implementations.
data DefaultDecoration a = DefaultDecoration deriving ( Read, Show )
instance Eq a => DecorationStyle DefaultDecoration a

-- | The long 'LayoutModifier' instance for the 'Decoration' type.
--
-- In 'redoLayout' we check the state: if there is no state we
-- initialize it.
--
-- The state is 'diff'ed against the list of windows produced by the
-- underlying layout: removed windows get deleted and new ones
-- decorated by 'createDecos', which will call 'decorate' to decide if
-- a window must be given a 'Rectangle', in which case a decoration
-- window will be created.
--
-- After that we resync the updated state with the windows' list and
-- then we process the resynced stated (as we do with a new state).
--
-- First we map the decoration windows, we update each decoration to
-- reflect any decorated window's change, and we insert, in the list
-- of windows and rectangles returned by the underlying layout, the
-- decoration for each window. This way xmonad will restack the
-- decorations and their windows accordingly. At the end we remove
-- invisible\/stacked windows.
--
-- Message handling is quite simple: when needed we release the state
-- component of the 'Decoration' 'LayoutModifier'. Otherwise we call
-- 'handleEvent', which will call the appropriate 'DecorationStyle'
-- methods to perform its tasks.
instance (DecorationStyle ds Window, Shrinker s) => LayoutModifier (Decoration ds s) Window where
    redoLayout (Decoration (I (Just s)) sh t ds) _ Nothing _ = do
        releaseResources s
        return ([], Just $ Decoration (I Nothing) sh t ds)
    redoLayout _                                 _ Nothing _  = return ([], Nothing)

    redoLayout (Decoration st sh t ds) sc (Just stack) wrs
        | I Nothing  <- st = initState t ds sc stack wrs >>= processState
        | I (Just s) <- st = do let dwrs  = decos s
                                    (d,a) = curry diff (get_ws dwrs) ws
                                    toDel = todel d dwrs
                                    toAdd = toadd a wrs
                                deleteDecos (map snd toDel)
                                let ndwrs = zip toAdd $ repeat (Nothing,Nothing)
                                ndecos <- resync (ndwrs ++ del_dwrs d dwrs) wrs
                                processState (s {decos = ndecos })

        where
          ws        = map fst wrs
          get_w     = fst . fst
          get_ws    = map get_w
          del_dwrs  = listFromList get_w notElem
          find_dw i = fst . snd . flip (!!) i
          todel   d = filter (flip elem d . get_w)
          toadd   a = filter (flip elem a . fst  )

          check_dwr dwr = case dwr of
                            (Nothing, Just dr) -> do dw <- createDecoWindow t dr
                                                     return (Just dw, Just dr)
                            _                 -> return dwr

          resync _         [] = return []
          resync d ((w,r):xs) = case  w `P.elemIndex` get_ws d of
                                  Just i  -> do dr   <- decorate ds (decoWidth t) (decoHeight t) sc stack wrs (w,r)
                                                dwr  <- check_dwr (find_dw i d, dr)
                                                dwrs <- resync d xs
                                                return $ ((w,r),dwr) : dwrs
                                  Nothing -> resync d xs

          -- We drop any windows that are *precisely* stacked underneath
          -- another window: these must be intended to be tabbed!
          remove_stacked rs ((w,r):xs)
              | r `elem` rs   = remove_stacked rs xs
              | otherwise     = (w,r) : remove_stacked (r:rs) xs
          remove_stacked _ [] = []

          insert_dwr ((w,r),(Just dw,Just dr)) xs = (dw,dr):(w, shrink ds dr r):xs
          insert_dwr (x    ,(     _ ,     _ )) xs = x:xs

          dwrs_to_wrs    = remove_stacked [] . foldr insert_dwr []

          processState s = do let ndwrs = decos s
                              showDecos (map snd ndwrs)
                              updateDecos sh t (font s) ndwrs
                              return (dwrs_to_wrs ndwrs, Just (Decoration (I (Just (s {decos = ndwrs}))) sh t ds))

    handleMess (Decoration (I (Just s@DS{decos = dwrs})) sh t ds) m
        | Just e <- fromMessage m                = do decorationEventHook ds s e
                                                      handleEvent sh t s e
                                                      return Nothing
        | Just Hide             <- fromMessage m = do hideDecos (map snd dwrs)
                                                      return Nothing
        | Just (SetTheme nt)    <- fromMessage m = do releaseResources s
                                                      return $ Just $ Decoration (I Nothing) sh nt ds
        | Just ReleaseResources <- fromMessage m = do releaseResources s
                                                      return $ Just $ Decoration (I Nothing) sh t  ds
    handleMess _ _ = return Nothing

    modifierDescription (Decoration _ _ _ ds) = describeDeco ds

-- | By default 'Decoration' handles 'PropertyEvent' and 'ExposeEvent'
-- only.
handleEvent :: Shrinker s => s -> Theme -> DecorationState -> Event -> X ()
handleEvent sh t (DS dwrs fs) e
    | PropertyEvent {ev_window = w} <- e
    , Just i <- w `P.elemIndex` map (fst . fst) dwrs      = updateDeco sh t fs (dwrs !! i)
    | ExposeEvent   {ev_window = w} <- e
    , Just i <- w `P.elemIndex` P.mapMaybe (fst . snd) dwrs = updateDeco sh t fs (dwrs !! i)
handleEvent _ _ _ _ = return ()

-- | Mouse focus and mouse drag are handled by the same function, this
-- way we can start dragging unfocused windows too.
handleMouseFocusDrag :: (DecorationStyle ds a) => ds a -> DecorationState -> Event -> X ()
handleMouseFocusDrag ds (DS dwrs _) ButtonEvent { ev_window     = ew
                                                , ev_event_type = et
                                                , ev_x_root     = ex
                                                , ev_y_root     = ey }
    | et == buttonPress
    , Just ((mainw,r), (_, decoRectM)) <- lookFor ew dwrs = do
        let Just (Rectangle dx _ dwh _) = decoRectM
            distFromLeft = ex - fi dx
            distFromRight = fi dwh - (ex - fi dx)
        dealtWith <- decorationCatchClicksHook ds mainw (fi distFromLeft) (fi distFromRight)
        unless dealtWith $
            mouseDrag (\x y -> focus mainw >> decorationWhileDraggingHook ds ex ey (mainw, r) x y)
                        (decorationAfterDraggingHook ds (mainw, r) ew)
handleMouseFocusDrag _ _ _ = return ()

handleDraggingInProgress :: CInt -> CInt -> (Window, Rectangle)
  -> XMonad.Position -> XMonad.Position -> X ()
handleDraggingInProgress ex ey (_, r) x y = withDisplay $ \dpy ->
    let dw = displayWidth  dpy (defaultScreen dpy)
        dh = displayHeight dpy (defaultScreen dpy)
        wx = x - (fi ex - rect_x r)
        wy = y - (fi ey - rect_y r)
        regionWidth = 5
        rect =
          if y <= regionWidth
          then
            Rectangle 0 0 ((fi dw) - barWidth) (fi dh)
          else if x <= regionWidth
               then
                 Rectangle 0 0 (((fi dw) - barWidth) `div` 2) (fi dh)
          else if x >= (((fi dw) - 1) - regionWidth - (fi barWidth))
               then
                 Rectangle (fi (((fi dw) - barWidth) `div` 2)) 0 (((fi dw) - barWidth) `div` 2) (fi dh)
          else
            Rectangle wx wy (rect_width  r) (rect_height r)
    in sendMessage $ SetGeometry rect

-- | Given a window and the state, if a matching decoration is in the
-- state return it with its ('Maybe') 'Rectangle'.
lookFor :: Window -> [(OrigWin,DecoWin)] -> Maybe (OrigWin,(Window,Maybe Rectangle))
lookFor w ((wr,(Just dw,dr)):dwrs) | w == dw = Just (wr,(dw,dr))
                                   | otherwise = lookFor w dwrs
lookFor w ((_, (Nothing, _)):dwrs) = lookFor w dwrs
lookFor _ [] = Nothing

findWindowByDecoration :: Window -> DecorationState -> Maybe (OrigWin,(Window,Maybe Rectangle))
findWindowByDecoration w ds = lookFor w (decos ds)

-- | Initialize the 'DecorationState' by initializing the font
-- structure and by creating the needed decorations.
initState :: DecorationStyle ds Window => Theme -> ds Window -> Rectangle
          -> W.Stack Window -> [(Window,Rectangle)] -> X DecorationState
initState t ds sc s wrs = do
  fs   <- initXMF (fontName t)
  dwrs <- createDecos t ds sc s wrs wrs
  return $ DS dwrs fs

-- | Delete windows stored in the state and release the font structure.
releaseResources :: DecorationState -> X ()
releaseResources s = do
  deleteDecos (map snd $ decos s)
  releaseXMF  (font s)

-- | Create the decoration windows of a list of windows and their
-- rectangles, by calling the 'decorate' method of the
-- 'DecorationStyle' received.
createDecos :: DecorationStyle ds Window => Theme -> ds Window -> Rectangle -> W.Stack Window
            -> [(Window,Rectangle)] -> [(Window,Rectangle)] -> X [(OrigWin,DecoWin)]
createDecos t ds sc s wrs ((w,r):xs) = do
  deco <- decorate ds (decoWidth t) (decoHeight t) sc s wrs (w,r)
  case deco of
    Just dr -> do dw   <- createDecoWindow t dr
                  dwrs <- createDecos t ds sc s wrs xs
                  return $ ((w,r), (Just dw, Just dr)) : dwrs
    Nothing -> do dwrs <- createDecos t ds sc s wrs xs
                  return $ ((w,r), (Nothing, Nothing)) : dwrs
createDecos _ _ _ _ _ [] = return []

createDecoWindow :: Theme -> Rectangle -> X Window
createDecoWindow t r = do
  let mask = Just (exposureMask .|. buttonPressMask)
  w <- createNewWindow r mask (inactiveColor t) True
  d <- asks display
  io $ setClassHint d w (ClassHint "xmonad-decoration" "xmonad")
  pure w

showDecos :: [DecoWin] -> X ()
showDecos = showWindows . P.mapMaybe fst . filter (isJust . snd)

hideDecos :: [DecoWin] -> X ()
hideDecos = hideWindows . P.mapMaybe fst

deleteDecos :: [DecoWin] -> X ()
deleteDecos = deleteWindows . P.mapMaybe fst

updateDecos :: Shrinker s => s -> Theme -> XMonadFont -> [(OrigWin,DecoWin)] -> X ()
updateDecos s t f = mapM_ $ updateDeco s t f

-- | Update a decoration window given a shrinker, a theme, the font
-- structure and the needed 'Rectangle's
updateDeco :: Shrinker s => s -> Theme -> XMonadFont -> (OrigWin,DecoWin) -> X ()
updateDeco sh t fs ((w,_),(Just dw,Just (Rectangle _ _ wh ht))) = do
  nw  <- getName w
  ur  <- readUrgents
  dpy <- asks display
  let focusColor win ic ac uc = maybe ic (\focusw -> case () of
                                                      _ | focusw == win -> ac
                                                        | win `elem` ur -> uc
                                                        | otherwise     -> ic) . W.peek
                                <$> gets windowset
  (bc,borderc,borderw,tc) <-
    focusColor w (inactiveColor t, inactiveBorderColor t, inactiveBorderWidth t, inactiveTextColor t)
                 (activeColor   t, activeBorderColor   t, activeBorderWidth   t, activeTextColor   t)
                 (urgentColor   t, urgentBorderColor   t, urgentBorderWidth   t, urgentTextColor   t)
  let s = shrinkIt sh
  name <- shrinkWhile s (\n -> do size <- io $ textWidthXMF dpy fs n
                                  return $ size > fromIntegral wh - fromIntegral (ht `div` 2)) (show nw)
  let als = AlignCenter : map snd (windowTitleAddons t)
      strs = name : map fst (windowTitleAddons t)
      i_als = map snd (windowTitleIcons t)
      icons = map fst (windowTitleIcons t)
  paintTextAndIcons dw fs wh ht borderw bc borderc tc bc als strs i_als icons
updateDeco _ _ _ (_,(Just w,Nothing)) = hideWindow w
updateDeco _ _ _ _ = return ()

-- | True if the window is in the 'Stack'. The 'Window' comes second
-- to facilitate list processing, even though @w \`isInStack\` s@ won't
-- work...;)
isInStack :: Eq a => W.Stack a -> a -> Bool
isInStack s = flip elem (W.integrate s)

-- | Given a 'Rectangle' and a list of 'Rectangle's is True if the
-- 'Rectangle' is not completely contained by any 'Rectangle' of the
-- list.
isVisible :: Rectangle -> [Rectangle] -> Bool
isVisible r = and . foldr f []
    where f x xs = if r `isWithin` x then False : xs else True : xs

-- | The contrary of 'isVisible'.
isInvisible :: Rectangle -> [Rectangle] -> Bool
isInvisible r = not . isVisible r

-- | True is the first 'Rectangle' is totally within the second
-- 'Rectangle'.
isWithin :: Rectangle -> Rectangle -> Bool
isWithin (Rectangle x y w h) (Rectangle rx ry rw rh)
    | x >= rx, x <= rx + fi rw
    , y >= ry, y <= ry + fi rh
    , x + fi w <= rx + fi rw
    , y + fi h <= ry + fi rh = True
    | otherwise              = False

shrinkWhile :: (String -> [String]) -> (String -> X Bool) -> String -> X String
shrinkWhile sh p x = sw $ sh x
    where sw [n] = return n
          sw [] = return ""
          sw (n:ns) = do
                        cond <- p n
                        if cond
                          then sw ns
                          else return n

data CustomShrink = CustomShrink
instance Show CustomShrink where show _ = ""
instance Read CustomShrink where readsPrec _ s = [(CustomShrink,s)]

class (Read s, Show s) => Shrinker s where
    shrinkIt :: s -> String -> [String]

data DefaultShrinker = DefaultShrinker
instance Show DefaultShrinker where show _ = ""
instance Read DefaultShrinker where readsPrec _ s = [(DefaultShrinker,s)]
instance Shrinker DefaultShrinker where
    shrinkIt _ "" = [""]
    shrinkIt s cs = cs : shrinkIt s (init cs)

shrinkText :: DefaultShrinker
shrinkText = DefaultShrinker

------------------------------------------------------------------------
-- DecorationAddon reimplementation

-- | A function intended to be plugged into the 'decorationAfterDraggingHook' of a decoration.
-- It will check if the window has been dragged onto another screen and shift it there.
-- The PositionStore is also updated accordingly, as this is designed to be used together
-- with "XMonad.Layout.PositionStoreFloat".
handleScreenCrossing :: Window -> Window -> X Bool
handleScreenCrossing w decoWin = withDisplay $ \d -> do
    root <- asks theRoot
    (_, _, _, px, py, _, _, _) <- io $ queryPointer d root
    ws <- gets windowset
    sc <- P.fromMaybe (W.current ws) <$> pointScreen (fi px) (fi py)
    maybeWksp <- screenWorkspace $ W.screen sc
    let targetWksp = maybeWksp >>= \wksp ->
                        W.findTag w ws >>= \currentWksp ->
                        if currentWksp /= wksp
                            then Just wksp
                            else Nothing
    case targetWksp of
        Just wksp -> do
                        -- find out window under cursor on target workspace
                        -- apparently we have to switch to the workspace first
                        -- to make this work, which unforunately introduces some flicker
                        windows $ \ws' -> W.view wksp ws'
                        (_, _, selWin, _, _, _, _, _) <- io $ queryPointer d root

                        -- adjust PositionStore
                        let oldScreenRect = screenRect . W.screenDetail $ W.current ws
                            newScreenRect = screenRect . W.screenDetail $ sc
                        {-- somewhat ugly hack to get proper ScreenRect,
                            creates unwanted inter-dependencies
                            TODO: get ScreenRects in a proper way --}
                        oldScreenRect' <- fmap ($ oldScreenRect) (calcGap $ S.fromList [minBound .. maxBound])
                        newScreenRect' <- fmap ($ newScreenRect) (calcGap $ S.fromList [minBound .. maxBound])
                        wa <- io $ getWindowAttributes d decoWin
                        modifyPosStore (\ps ->
                            posStoreMove ps w (fi $ wa_x wa) (fi $ wa_y wa)
                                oldScreenRect' newScreenRect')

                        -- set focus correctly so the window will be inserted
                        -- at the correct position on the target workspace
                        -- and then shift the window
                        windows $ \ws' -> W.shiftWin wksp w . W.focusWindow selWin $ ws'

                        -- return True to signal that screen crossing has taken place
                        return True
        Nothing -> return False

------------------------------------------------------------------------

newtype SimpleFloat a = SF Dimension deriving (Show, Read)
instance LayoutClass SimpleFloat Window where
    description _ = "Float"
    doLayout (SF i) sc (W.Stack w l r) = do
        wrs <- mapM (getSize i sc) (w : reverse l ++ r)
        return (wrs, Nothing)

-- argurment is vertical offset for bar
getSize :: Dimension -> Rectangle -> Window -> X (Window,Rectangle)
getSize i (Rectangle rx ry _ _) w = do
  d  <- asks display
  bw <- asks (borderWidth . config)
  wa <- io $ getWindowAttributes d w
  withDisplay $ \dpy ->
    let deco = 50 - myBorderWidth
        dw = fi (displayWidth  dpy (defaultScreen dpy))
        dh = fi (displayHeight dpy (defaultScreen dpy))
        wh = fi (wa_width  wa) + (bw * 2)
        -- ht = fi (wa_height wa) + (bw * 2)
        ht = fi (wa_height wa) + (bw * 2) + deco
        nx = if rx == 0 then ((dw - (fi i)) - (fi wh)) `div` 2 else rx
        -- ny = if ry == 0 then (dh - (fi ht)) `div` 2 else ry
        ny = if ry == 0 then (dh - (fi ht)) `div` 2 else ry
        x  =  max nx $ fi $ wa_x wa
        y  =  max ny $ fi $ wa_y wa
    in return (w, Rectangle x y wh ht)

------------------------------------------------------------------------

resizeWidth :: Dimension
resizeWidth = 32

-- TODO when mouse resize module is cleaned up, use these as local variables
-- Resize Width
rw :: Dimension
rw = resizeWidth
-- Offset Resize Width
orw :: XMonad.Position
orw = fi (rw `div` 2)

mouseResizeSE :: l a -> ModifiedLayout MouseResizeSE l a
mouseResizeSE = ModifiedLayout (MR_SE [])

newtype MouseResizeSE a = MR_SE [((a,Rectangle),Maybe a)]
instance Show (MouseResizeSE a) where show        _ = ""
instance Read (MouseResizeSE a) where readsPrec _ s = [(MR_SE [], s)]

instance LayoutModifier MouseResizeSE Window where
    redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
    redoLayout (MR_SE st) _ (Just s) wrs
        | [] <- st  = initState    >>= \nst -> return (wrs, Just $ MR_SE nst)
        | otherwise = processState >>= \nst -> return (wrs, Just $ MR_SE nst)
        where
          wrs'         = wrs_to_state [] . filter (isInStack s . fst) $ wrs
          initState    = mapM createInputWindowSE wrs'
          processState = mapM_ (deleteInputWin . snd) st >> mapM createInputWindowSE wrs'

          inputRectangle (Rectangle x y wh ht) = Rectangle (x + fi wh - orw) (y + fi ht - orw) rw rw

          wrs_to_state rs ((w,r):xs)
              | ir `isVisible` rs = ((w,r),Just ir) : wrs_to_state (r:ir:rs) xs
              | otherwise         = ((w,r),Nothing) : wrs_to_state (r:   rs) xs
              where ir = inputRectangle r
          wrs_to_state _ [] = []

    handleMess (MR_SE s) m
        | Just e <- fromMessage m :: Maybe Event = handleResizeSE s e >> return Nothing
        | Just Hide             <- fromMessage m = releaseResources >> return (Just $ MR_SE [])
        | Just ReleaseResources <- fromMessage m = releaseResources >> return (Just $ MR_SE [])
        where releaseResources = mapM_ (deleteInputWin . snd) s
    handleMess _ _ = return Nothing

mouseResizeSW :: l a -> ModifiedLayout MouseResizeSW l a
mouseResizeSW = ModifiedLayout (MR_SW [])

newtype MouseResizeSW a = MR_SW [((a,Rectangle),Maybe a)]
instance Show (MouseResizeSW a) where show        _ = ""
instance Read (MouseResizeSW a) where readsPrec _ s = [(MR_SW [], s)]

instance LayoutModifier MouseResizeSW Window where
    redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
    redoLayout (MR_SW st) _ (Just s) wrs
        | [] <- st  = initState    >>= \nst -> return (wrs, Just $ MR_SW nst)
        | otherwise = processState >>= \nst -> return (wrs, Just $ MR_SW nst)
        where
          wrs'         = wrs_to_state [] . filter (isInStack s . fst) $ wrs
          initState    = mapM createInputWindowSW wrs'
          processState = mapM_ (deleteInputWin . snd) st >> mapM createInputWindowSW wrs'

          inputRectangle (Rectangle x y wh ht) = Rectangle (x - orw) (y + fi ht - orw) rw rw

          wrs_to_state rs ((w,r):xs)
              | ir `isVisible` rs = ((w,r),Just ir) : wrs_to_state (r:ir:rs) xs
              | otherwise         = ((w,r),Nothing) : wrs_to_state (r:   rs) xs
              where ir = inputRectangle r
          wrs_to_state _ [] = []

    handleMess (MR_SW s) m
        | Just e <- fromMessage m :: Maybe Event = handleResizeSW s e >> return Nothing
        | Just Hide             <- fromMessage m = releaseResources >> return (Just $ MR_SW [])
        | Just ReleaseResources <- fromMessage m = releaseResources >> return (Just $ MR_SW [])
        where releaseResources = mapM_ (deleteInputWin . snd) s
    handleMess _ _ = return Nothing

mouseResizeNW :: l a -> ModifiedLayout MouseResizeNW l a
mouseResizeNW = ModifiedLayout (MR_NW [])

newtype MouseResizeNW a = MR_NW [((a,Rectangle),Maybe a)]
instance Show (MouseResizeNW a) where show        _ = ""
instance Read (MouseResizeNW a) where readsPrec _ s = [(MR_NW [], s)]

instance LayoutModifier MouseResizeNW Window where
    redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
    redoLayout (MR_NW st) _ (Just s) wrs
        | [] <- st  = initState    >>= \nst -> return (wrs, Just $ MR_NW nst)
        | otherwise = processState >>= \nst -> return (wrs, Just $ MR_NW nst)
        where
          wrs'         = wrs_to_state [] . filter (isInStack s . fst) $ wrs
          initState    = mapM createInputWindowNW wrs'
          processState = mapM_ (deleteInputWin . snd) st >> mapM createInputWindowNW wrs'

          inputRectangle (Rectangle x y wh ht) = Rectangle (x - orw) (y - orw) rw rw

          wrs_to_state rs ((w,r):xs)
              | ir `isVisible` rs = ((w,r),Just ir) : wrs_to_state (r:ir:rs) xs
              | otherwise         = ((w,r),Nothing) : wrs_to_state (r:   rs) xs
              where ir = inputRectangle r
          wrs_to_state _ [] = []

    handleMess (MR_NW s) m
        | Just e <- fromMessage m :: Maybe Event = handleResizeNW s e >> return Nothing
        | Just Hide             <- fromMessage m = releaseResources >> return (Just $ MR_NW [])
        | Just ReleaseResources <- fromMessage m = releaseResources >> return (Just $ MR_NW [])
        where releaseResources = mapM_ (deleteInputWin . snd) s
    handleMess _ _ = return Nothing

mouseResizeNE :: l a -> ModifiedLayout MouseResizeNE l a
mouseResizeNE = ModifiedLayout (MR_NE [])

newtype MouseResizeNE a = MR_NE [((a,Rectangle),Maybe a)]
instance Show (MouseResizeNE a) where show        _ = ""
instance Read (MouseResizeNE a) where readsPrec _ s = [(MR_NE [], s)]

instance LayoutModifier MouseResizeNE Window where
    redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
    redoLayout (MR_NE st) _ (Just s) wrs
        | [] <- st  = initState    >>= \nst -> return (wrs, Just $ MR_NE nst)
        | otherwise = processState >>= \nst -> return (wrs, Just $ MR_NE nst)
        where
          wrs'         = wrs_to_state [] . filter (isInStack s . fst) $ wrs
          initState    = mapM createInputWindowNE wrs'
          processState = mapM_ (deleteInputWin . snd) st >> mapM createInputWindowNE wrs'

          inputRectangle (Rectangle x y wh ht) = Rectangle (x + fi wh - orw) (y - orw) rw rw

          wrs_to_state rs ((w,r):xs)
              | ir `isVisible` rs = ((w,r),Just ir) : wrs_to_state (r:ir:rs) xs
              | otherwise         = ((w,r),Nothing) : wrs_to_state (r:   rs) xs
              where ir = inputRectangle r
          wrs_to_state _ [] = []

    handleMess (MR_NE s) m
        | Just e <- fromMessage m :: Maybe Event = handleResizeNE s e >> return Nothing
        | Just Hide             <- fromMessage m = releaseResources >> return (Just $ MR_NE [])
        | Just ReleaseResources <- fromMessage m = releaseResources >> return (Just $ MR_NE [])
        where releaseResources = mapM_ (deleteInputWin . snd) s
    handleMess _ _ = return Nothing

mouseResizeS :: l a -> ModifiedLayout MouseResizeS l a
mouseResizeS = ModifiedLayout (MR_S [])

newtype MouseResizeS a = MR_S [((a,Rectangle),Maybe a)]
instance Show (MouseResizeS a) where show        _ = ""
instance Read (MouseResizeS a) where readsPrec _ s = [(MR_S [], s)]

instance LayoutModifier MouseResizeS Window where
    redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
    redoLayout (MR_S st) _ (Just s) wrs
        | [] <- st  = initState    >>= \nst -> return (wrs, Just $ MR_S nst)
        | otherwise = processState >>= \nst -> return (wrs, Just $ MR_S nst)
        where
          wrs'         = wrs_to_state [] . filter (isInStack s . fst) $ wrs
          initState    = mapM createInputWindowS wrs'
          processState = mapM_ (deleteInputWin . snd) st >> mapM createInputWindowS wrs'

          inputRectangle (Rectangle x y wh ht) = Rectangle (x + orw) (y + fi ht - orw) (fi wh - rw) rw

          wrs_to_state rs ((w,r):xs)
              | ir `isVisible` rs = ((w,r),Just ir) : wrs_to_state (r:ir:rs) xs
              | otherwise         = ((w,r),Nothing) : wrs_to_state (r:   rs) xs
              where ir = inputRectangle r
          wrs_to_state _ [] = []

    handleMess (MR_S s) m
        | Just e <- fromMessage m :: Maybe Event = handleResizeS s e >> return Nothing
        | Just Hide             <- fromMessage m = releaseResources >> return (Just $ MR_S [])
        | Just ReleaseResources <- fromMessage m = releaseResources >> return (Just $ MR_S [])
        where releaseResources = mapM_ (deleteInputWin . snd) s
    handleMess _ _ = return Nothing

mouseResizeN :: l a -> ModifiedLayout MouseResizeN l a
mouseResizeN = ModifiedLayout (MR_N [])

newtype MouseResizeN a = MR_N [((a,Rectangle),Maybe a)]
instance Show (MouseResizeN a) where show        _ = ""
instance Read (MouseResizeN a) where readsPrec _ s = [(MR_N [], s)]

instance LayoutModifier MouseResizeN Window where
    redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
    redoLayout (MR_N st) _ (Just s) wrs
        | [] <- st  = initState    >>= \nst -> return (wrs, Just $ MR_N nst)
        | otherwise = processState >>= \nst -> return (wrs, Just $ MR_N nst)
        where
          wrs'         = wrs_to_state [] . filter (isInStack s . fst) $ wrs
          initState    = mapM createInputWindowN wrs'
          processState = mapM_ (deleteInputWin . snd) st >> mapM createInputWindowN wrs'

          inputRectangle (Rectangle x y wh ht) = Rectangle (x + orw) (y - orw) (fi wh - rw) rw

          wrs_to_state rs ((w,r):xs)
              | ir `isVisible` rs = ((w,r),Just ir) : wrs_to_state (r:ir:rs) xs
              | otherwise         = ((w,r),Nothing) : wrs_to_state (r:   rs) xs
              where ir = inputRectangle r
          wrs_to_state _ [] = []

    handleMess (MR_N s) m
        | Just e <- fromMessage m :: Maybe Event = handleResizeN s e >> return Nothing
        | Just Hide             <- fromMessage m = releaseResources >> return (Just $ MR_N [])
        | Just ReleaseResources <- fromMessage m = releaseResources >> return (Just $ MR_N [])
        where releaseResources = mapM_ (deleteInputWin . snd) s
    handleMess _ _ = return Nothing

mouseResizeE :: l a -> ModifiedLayout MouseResizeE l a
mouseResizeE = ModifiedLayout (MR_E [])

newtype MouseResizeE a = MR_E [((a,Rectangle),Maybe a)]
instance Show (MouseResizeE a) where show        _ = ""
instance Read (MouseResizeE a) where readsPrec _ s = [(MR_E [], s)]

instance LayoutModifier MouseResizeE Window where
    redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
    redoLayout (MR_E st) _ (Just s) wrs
        | [] <- st  = initState    >>= \nst -> return (wrs, Just $ MR_E nst)
        | otherwise = processState >>= \nst -> return (wrs, Just $ MR_E nst)
        where
          wrs'         = wrs_to_state [] . filter (isInStack s . fst) $ wrs
          initState    = mapM createInputWindowE wrs'
          processState = mapM_ (deleteInputWin . snd) st >> mapM createInputWindowE wrs'

          inputRectangle (Rectangle x y wh ht) = Rectangle (x + fi wh - orw) (y + orw) rw (fi ht - rw)

          wrs_to_state rs ((w,r):xs)
              | ir `isVisible` rs = ((w,r),Just ir) : wrs_to_state (r:ir:rs) xs
              | otherwise         = ((w,r),Nothing) : wrs_to_state (r:   rs) xs
              where ir = inputRectangle r
          wrs_to_state _ [] = []

    handleMess (MR_E s) m
        | Just e <- fromMessage m :: Maybe Event = handleResizeE s e >> return Nothing
        | Just Hide             <- fromMessage m = releaseResources >> return (Just $ MR_E [])
        | Just ReleaseResources <- fromMessage m = releaseResources >> return (Just $ MR_E [])
        where releaseResources = mapM_ (deleteInputWin . snd) s
    handleMess _ _ = return Nothing

mouseResizeW :: l a -> ModifiedLayout MouseResizeW l a
mouseResizeW = ModifiedLayout (MR_W [])

newtype MouseResizeW a = MR_W [((a,Rectangle),Maybe a)]
instance Show (MouseResizeW a) where show        _ = ""
instance Read (MouseResizeW a) where readsPrec _ s = [(MR_W [], s)]

instance LayoutModifier MouseResizeW Window where
    redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
    redoLayout (MR_W st) _ (Just s) wrs
        | [] <- st  = initState    >>= \nst -> return (wrs, Just $ MR_W nst)
        | otherwise = processState >>= \nst -> return (wrs, Just $ MR_W nst)
        where
          wrs'         = wrs_to_state [] . filter (isInStack s . fst) $ wrs
          initState    = mapM createInputWindowW wrs'
          processState = mapM_ (deleteInputWin . snd) st >> mapM createInputWindowW wrs'

          inputRectangle (Rectangle x y wh ht) = Rectangle (x - orw) (y + orw) rw (fi ht - rw)

          wrs_to_state rs ((w,r):xs)
              | ir `isVisible` rs = ((w,r),Just ir) : wrs_to_state (r:ir:rs) xs
              | otherwise         = ((w,r),Nothing) : wrs_to_state (r:   rs) xs
              where ir = inputRectangle r
          wrs_to_state _ [] = []

    handleMess (MR_W s) m
        | Just e <- fromMessage m :: Maybe Event = handleResizeW s e >> return Nothing
        | Just Hide             <- fromMessage m = releaseResources >> return (Just $ MR_W [])
        | Just ReleaseResources <- fromMessage m = releaseResources >> return (Just $ MR_W [])
        where releaseResources = mapM_ (deleteInputWin . snd) s
    handleMess _ _ = return Nothing

handleResizeSE :: [((Window,Rectangle),Maybe Window)] -> Event -> X ()
handleResizeSE st ButtonEvent { ev_window = ew, ev_event_type = et }
    | et == buttonPress
    , Just (w,Rectangle wx wy _ _) <- getWin ew st = do
        focus w
        mouseDrag (\x y ->
                     do
                       let rect = Rectangle wx wy
                                  (max 1 . fi $ x - wx)
                                  (max 1 . fi $ y - wy)
                       sendMessage (SetGeometry rect)) (return ())

      where
        getWin w (((win,r),tw):xs)
            | Just w' <- tw
            , w == w'   = Just (win,r)
            | otherwise = getWin w xs
        getWin _ []     = Nothing
handleResizeSE _ _ = return ()

handleResizeSW :: [((Window,Rectangle),Maybe Window)] -> Event -> X ()
handleResizeSW st ButtonEvent { ev_window = ew, ev_event_type = et }
    | et == buttonPress
    , Just (w,Rectangle wx wy wwh _) <- getWin ew st = do
        focus w
        mouseDrag (\x y ->
                     do
                       let rect = Rectangle (max 0 $ min (wx + fi wwh) x) wy
                                  (max 1 $ wwh + fi (wx - x))
                                  (max 1 . fi $ y - wy)
                       sendMessage (SetGeometry rect)) (return ())

      where
        getWin w (((win,r),tw):xs)
            | Just w' <- tw
            , w == w'   = Just (win,r)
            | otherwise = getWin w xs
        getWin _ []     = Nothing
handleResizeSW _ _ = return ()

handleResizeNW :: [((Window,Rectangle),Maybe Window)] -> Event -> X ()
handleResizeNW st ButtonEvent { ev_window = ew, ev_event_type = et }
    | et == buttonPress
    , Just (w,Rectangle wx wy wwh wht) <- getWin ew st = do
        focus w
        mouseDrag (\x y ->
                     do
                       let rect = Rectangle (max 0 $ min (wx + fi wwh) x)
                                  (max 0 $ min (wy + fi wht) y)
                                  (max 1 $ wwh + fi (wx - x))
                                  (max 1 $ wht + fi (wy - y))
                       sendMessage (SetGeometry rect)) (return ())

      where
        getWin w (((win,r),tw):xs)
            | Just w' <- tw
            , w == w'   = Just (win,r)
            | otherwise = getWin w xs
        getWin _ []     = Nothing
handleResizeNW _ _ = return ()

handleResizeNE :: [((Window,Rectangle),Maybe Window)] -> Event -> X ()
handleResizeNE st ButtonEvent { ev_window = ew, ev_event_type = et }
    | et == buttonPress
    , Just (w,Rectangle wx wy wwh wht) <- getWin ew st = do
        focus w
        mouseDrag (\x y ->
                     do
                       let rect = Rectangle wx (max 0 $ min (wy + fi wht) y)
                                  (max 1 . fi $ x - wx)
                                  (max 1 $ wht + fi (wy - y))
                       sendMessage (SetGeometry rect)) (return ())

      where
        getWin w (((win,r),tw):xs)
            | Just w' <- tw
            , w == w'   = Just (win,r)
            | otherwise = getWin w xs
        getWin _ []     = Nothing
handleResizeNE _ _ = return ()

handleResizeS :: [((Window,Rectangle),Maybe Window)] -> Event -> X ()
handleResizeS st ButtonEvent { ev_window = ew, ev_event_type = et }
    | et == buttonPress
    , Just (w,Rectangle wx wy wwh _) <- getWin ew st = do
        focus w
        mouseDrag (\x y ->
                     do
                       let rect = Rectangle wx wy wwh (max 1 . fi $ y - wy)
                       sendMessage (SetGeometry rect)) (return ())

      where
        getWin w (((win,r),tw):xs)
            | Just w' <- tw
            , w == w'   = Just (win,r)
            | otherwise = getWin w xs
        getWin _ []     = Nothing
handleResizeS _ _ = return ()

handleResizeN :: [((Window,Rectangle),Maybe Window)] -> Event -> X ()
handleResizeN st ButtonEvent { ev_window = ew, ev_event_type = et }
    | et == buttonPress
    , Just (w,Rectangle wx wy wwh wht) <- getWin ew st = do
        focus w
        mouseDrag (\x y ->
                     do
                       let rect = Rectangle wx (max 0 $ min (wy + fi wht) y) wwh (max 1 $ wht + fi (wy - y))
                       sendMessage (SetGeometry rect)) (return ())

      where
        getWin w (((win,r),tw):xs)
            | Just w' <- tw
            , w == w'   = Just (win,r)
            | otherwise = getWin w xs
        getWin _ []     = Nothing
handleResizeN _ _ = return ()

handleResizeE :: [((Window,Rectangle),Maybe Window)] -> Event -> X ()
handleResizeE st ButtonEvent { ev_window = ew, ev_event_type = et }
    | et == buttonPress
    , Just (w,Rectangle wx wy _ wht) <- getWin ew st = do
        focus w
        mouseDrag (\x y ->
                     do
                       let rect = Rectangle wx wy (max 1 . fi $ x - wx) wht
                       sendMessage (SetGeometry rect)) (return ())

      where
        getWin w (((win,r),tw):xs)
            | Just w' <- tw
            , w == w'   = Just (win,r)
            | otherwise = getWin w xs
        getWin _ []     = Nothing
handleResizeE _ _ = return ()

handleResizeW :: [((Window,Rectangle),Maybe Window)] -> Event -> X ()
handleResizeW st ButtonEvent { ev_window = ew, ev_event_type = et }
    | et == buttonPress
    , Just (w,Rectangle wx wy wwh wht) <- getWin ew st = do
        focus w
        mouseDrag (\x y ->
                     do
                       let rect = Rectangle (max 0 $ min (wx + fi wwh) x) wy (max 1 $ wwh + fi (wx - x)) wht
                       sendMessage (SetGeometry rect)) (return ())

      where
        getWin w (((win,r),tw):xs)
            | Just w' <- tw
            , w == w'   = Just (win,r)
            | otherwise = getWin w xs
        getWin _ []     = Nothing
handleResizeW _ _ = return ()

createInputWindowSE :: ((Window,Rectangle), Maybe Rectangle) -> X ((Window,Rectangle),Maybe Window)
createInputWindowSE ((w,r),mr) =
  case mr of
    Just tr  -> withDisplay $ \d -> do
                  tw <- mkInputWindow d tr
                  io $ selectInput d tw (exposureMask .|. buttonPressMask)

                  cursor <- io $ createFontCursor d xC_bottom_right_corner
                  io $ defineCursor d tw cursor
                  io $ freeCursor d cursor

                  showWindow tw
                  return ((w,r), Just tw)
    Nothing ->    return ((w,r), Nothing)

createInputWindowSW :: ((Window,Rectangle), Maybe Rectangle) -> X ((Window,Rectangle),Maybe Window)
createInputWindowSW ((w,r),mr) =
  case mr of
    Just tr  -> withDisplay $ \d -> do
                  tw <- mkInputWindow d tr
                  io $ selectInput d tw (exposureMask .|. buttonPressMask)

                  cursor <- io $ createFontCursor d xC_bottom_left_corner
                  io $ defineCursor d tw cursor
                  io $ freeCursor d cursor

                  showWindow tw
                  return ((w,r), Just tw)
    Nothing ->    return ((w,r), Nothing)

createInputWindowNW :: ((Window,Rectangle), Maybe Rectangle) -> X ((Window,Rectangle),Maybe Window)
createInputWindowNW ((w,r),mr) =
  case mr of
    Just tr  -> withDisplay $ \d -> do
                  tw <- mkInputWindow d tr
                  io $ selectInput d tw (exposureMask .|. buttonPressMask)

                  cursor <- io $ createFontCursor d xC_top_left_corner
                  io $ defineCursor d tw cursor
                  io $ freeCursor d cursor

                  showWindow tw
                  return ((w,r), Just tw)
    Nothing ->    return ((w,r), Nothing)

createInputWindowNE :: ((Window,Rectangle), Maybe Rectangle) -> X ((Window,Rectangle),Maybe Window)
createInputWindowNE ((w,r),mr) =
  case mr of
    Just tr  -> withDisplay $ \d -> do
                  tw <- mkInputWindow d tr
                  io $ selectInput d tw (exposureMask .|. buttonPressMask)

                  cursor <- io $ createFontCursor d xC_top_right_corner
                  io $ defineCursor d tw cursor
                  io $ freeCursor d cursor

                  showWindow tw
                  return ((w,r), Just tw)
    Nothing ->    return ((w,r), Nothing)

createInputWindowS :: ((Window,Rectangle), Maybe Rectangle) -> X ((Window,Rectangle),Maybe Window)
createInputWindowS ((w,r),mr) =
  case mr of
    Just tr  -> withDisplay $ \d -> do
                  tw <- mkInputWindow d tr
                  io $ selectInput d tw (exposureMask .|. buttonPressMask)

                  cursor <- io $ createFontCursor d xC_bottom_side
                  io $ defineCursor d tw cursor
                  io $ freeCursor d cursor

                  showWindow tw
                  return ((w,r), Just tw)
    Nothing ->    return ((w,r), Nothing)

createInputWindowN :: ((Window,Rectangle), Maybe Rectangle) -> X ((Window,Rectangle),Maybe Window)
createInputWindowN ((w,r),mr) =
  case mr of
    Just tr  -> withDisplay $ \d -> do
                  tw <- mkInputWindow d tr
                  io $ selectInput d tw (exposureMask .|. buttonPressMask)

                  cursor <- io $ createFontCursor d xC_top_side
                  io $ defineCursor d tw cursor
                  io $ freeCursor d cursor

                  showWindow tw
                  return ((w,r), Just tw)
    Nothing ->    return ((w,r), Nothing)

createInputWindowE :: ((Window,Rectangle), Maybe Rectangle) -> X ((Window,Rectangle),Maybe Window)
createInputWindowE ((w,r),mr) =
  case mr of
    Just tr  -> withDisplay $ \d -> do
                  tw <- mkInputWindow d tr
                  io $ selectInput d tw (exposureMask .|. buttonPressMask)

                  cursor <- io $ createFontCursor d xC_right_side
                  io $ defineCursor d tw cursor
                  io $ freeCursor d cursor

                  showWindow tw
                  return ((w,r), Just tw)
    Nothing ->    return ((w,r), Nothing)

createInputWindowW :: ((Window,Rectangle), Maybe Rectangle) -> X ((Window,Rectangle),Maybe Window)
createInputWindowW ((w,r),mr) =
  case mr of
    Just tr  -> withDisplay $ \d -> do
                  tw <- mkInputWindow d tr
                  io $ selectInput d tw (exposureMask .|. buttonPressMask)

                  cursor <- io $ createFontCursor d xC_left_side
                  io $ defineCursor d tw cursor
                  io $ freeCursor d cursor

                  showWindow tw
                  return ((w,r), Just tw)
    Nothing ->    return ((w,r), Nothing)

deleteInputWin :: Maybe Window -> X ()
deleteInputWin = maybe (return ()) deleteWindow

mkInputWindow :: Display -> Rectangle -> X Window
mkInputWindow d (Rectangle x y w h) = do
  rw <- asks theRoot
  let screen   = defaultScreenOfDisplay d
      visual   = defaultVisualOfScreen screen
      attrmask = cWOverrideRedirect
  io $ allocaSetWindowAttributes $
         \attributes -> do
           set_override_redirect attributes True
           createWindow d rw x y w h 0 0 inputOnly visual attrmask attributes

------------------------------------------------------------------------

-- for the future: want to spawn window within currently selected group,
-- and then if you want it to be separate unmerge it from the group.
-- the new window will already be selected so it will be easy to umerge it

-- Spacing
-- top, bottom, right, left
bigGaps = spacingRaw False (Border 155 130 200 175)
  True (Border 0 25 0 25) True
threeGapsSingle = spacingRaw False (Border 155 155 1060 1060)
  True (Border 0 0 0 0) True
threeGapsDouble = spacingRaw False (Border 155 155 1060 200)
  True (Border 0 0 0 0) True
threeGaps = spacingRaw False (Border 155 155 200 200)
  True (Border 0 0 0 0) True

windowDeco = windowSwitcherDecorationWithImageButtons
             shrinkText defaultThemeWithImageButtons
floatingDeco = imageButtonDeco shrinkText defaultThemeWithImageButtons

emacs =
  renamed [Replace "bsp"] $
  (windowDeco . draggingVisualizer . (maximizeWithPadding 0)
   . subLayout [] StateFull . bigGaps $ emptyBSP)

threeCol =
  renamed [Replace "threeCol"] $
  (windowDeco . draggingVisualizer $ subLayout [] StateFull
   $ (ifMax 2 (ifMax 1
      (threeGapsSingle $ Full)
      (threeGapsDouble $ reflectHoriz $ (ThreeColMid 1 (3/100) (2/3))))
    (threeGaps $ ThreeColMid 1 (3/100) (1/2))))

floating =
  renamed [Replace "float"] $
  (floatingDeco . (maximizeWithPadding 0)
   . mouseResizeSE . mouseResizeSW . mouseResizeNW . mouseResizeNE
   -- . mouseResizeS . mouseResizeN . mouseResizeE . mouseResizeW
   . windowArrangeAll $ SF barWidth)

myLayout = avoidStruts
         . (WN.configurableNavigation WN.noNavigateBorders)
         . lessBorders OnlyScreenFloat
         . minimize
         . BW.boringWindows
         $ floating ||| emacs ||| threeCol

------------------------------------------------------------------------

infix 0 -!>

-- | @p -!> x@.  If @p@ returns 'False', execute the 'ManageHook'.
--
-- > (-!>) :: Monoid m => Query Bool -> Query m -> Query m -- a simpler type
(-!>) :: (Monad m, Monoid a) => m Bool -> m a -> m a
p -!> f = p >>= \b -> if b then return mempty else f

-- -- | @q =? x@. if the result of @q@ equals @x@, return 'False'.
-- (=!?) :: Eq a => C.Query a -> a -> C.Query Bool
-- q =!? x = fmap (/= x) q

-- myManageHook = composeAll
--     [ className =? "Firefox" <&&> resource =? "Toolkit"   --> myRectFloat
--     , stringProperty "WM_WINDOW_ROLE"
--       =? "GtkFileChooserDialog"                           --> myRectFloat
--     , title     =? "Save Image"                           --> myRectFloat
--     , title     =? "Save File"                            --> myRectFloat
--     , title     =? "Open"                                 --> myRectFloat
--     , title     =? "Open Files"                           --> myRectFloat
--     , resource  =? "desktop_window"                       --> doIgnore
--     , resource  =? "kdesktop"                             --> doIgnore
--     , isFullscreen --> doFullFloat
--     , fmap not willFloat --> insertPosition Below Newer
--     , fmap not willFloat -!> insertPosition Master Newer
--     ]
--   where
--     -- xpos, ypos, width, height
--     myRectFloat = doRectFloat (W.RationalRect (1 % 3) (3 % 10) (1 % 3) (2 % 5))
--     helpFloat = doRectFloat (W.RationalRect (7 % 8) (0 % 1) (1 % 8) (1 % 2))

myManageHook = composeAll
               [ isFullscreen --> doFullFloat
               --, fmap not willFloat -!> unfloat
               , isFullscreen -!> unfloat
               , insertPosition Below Newer
               ]
               where
                 unfloat = ask >>= doF . W.sink

willFloat :: C.Query Bool
willFloat =
  ask >>= \w -> liftX $
    withDisplay $ \d -> do
      sh <- io $ getWMNormalHints d w
      let isFixedSize = isJust (sh_min_size sh) && sh_min_size sh == sh_max_size sh
      isTransient <- isJust <$> io (getTransientForHint d w)
      return (isFixedSize || isTransient)

------------------------------------------------------------------------

myEventHook = minimizeEventHook

------------------------------------------------------------------------

myLogHook = return ()

------------------------------------------------------------------------

myStartupHook = do
  spawnOnce "emacs --daemon"
  spawnOnce "pcmanfm-qt --daemon-mode &"
  spawnOnce "pcmanfm-qt --desktop &"
  spawnOnce "urxvtd --quiet &"
  spawnOnce "sleep 2 && tint2 &"
  spawnOnce "amixer -q set Master unmute 28%"
  setWMName "LG3D"

------------------------------------------------------------------------

-- floatCommands :: [(String, X ())]
-- floatCommands =
--   -- Float keys
--   [ ("k", (withFocused (keysMoveWindow (0,-80))) >> spawn "xdotool key super+f")
--   , ("j", (withFocused (keysMoveWindow (0, 80))) >> spawn "xdotool key super+f")
--   , ("h", (withFocused (keysMoveWindow (-80,0))) >> spawn "xdotool key super+f")
--   , ("l", (withFocused (keysMoveWindow (80, 0))) >> spawn "xdotool key super+f")
--   -- Float Snapping Keys
--   , ("sh", (withFocused $ snapMove L Nothing) >> spawn "xdotool key super+f")
--   , ("sj", (withFocused $ snapMove D Nothing) >> spawn "xdotool key super+f")
--   , ("sk", (withFocused $ snapMove U Nothing) >> spawn "xdotool key super+f")
--   , ("sl", (withFocused $ snapMove R Nothing) >> spawn "xdotool key super+f")
--   , ("sH", (withFocused $ snapShrink R Nothing) >> spawn "xdotool key super+f")
--   , ("sJ", (withFocused $ snapGrow D Nothing) >> spawn "xdotool key super+f")
--   , ("sK", (withFocused $ snapShrink D Nothing) >> spawn "xdotool key super+f")
--   , ("sL", (withFocused $ snapGrow R Nothing) >> spawn "xdotool key super+f")
--   -- Push window back into tiling
--   , ("t", (withFocused $ windows . W.sink) >> spawn "xdotool key super+f")
--   -- Switch between layers
--   , ("L", (switchLayer) >> spawn "xdotool key super+f")
--   -- Center the window
--   , ("c", (withFocused (keysMoveWindowTo (1920,1080) (1%2, 1%2)))
--       >> spawn "xdotool key super+f")
--   , ("q", refresh)
--   ]

-- floatPrompt :: X ()
-- floatPrompt = xmonadPromptC floatCommands baseXPConfig
--               { fgHLight            = "#ed8f23"
--               , borderColor         = "#ed8f23"
--               }

------------------------------------------------------------------------

-- resizeCommands :: [(String, X ())]
-- resizeCommands =
--   [ ("h", (sendMessage $ ExpandTowards L) >> spawn "xdotool key super+r")
--   , ("j", (sendMessage $ ExpandTowards D) >> spawn "xdotool key super+r")
--   , ("k", (sendMessage $ ExpandTowards U) >> spawn "xdotool key super+r")
--   , ("l", (sendMessage $ ExpandTowards R) >> spawn "xdotool key super+r")
--   , ("H", (sendMessage $ ShrinkFrom L) >> spawn "xdotool key super+r")
--   , ("J", (sendMessage $ ShrinkFrom D) >> spawn "xdotool key super+r")
--   , ("K", (sendMessage $ ShrinkFrom U) >> spawn "xdotool key super+r")
--   , ("L", (sendMessage $ ShrinkFrom R) >> spawn "xdotool key super+r")
--   , ("q", refresh)
--   ]

-- resizePrompt :: X ()
-- resizePrompt = xmonadPromptC resizeCommands baseXPConfig
--                { fgHLight            = "#e01bd0"
--                , borderColor         = "#e01bd0"
--                }

------------------------------------------------------------------------

swapUp' :: W.Stack a -> W.Stack a
swapUp'  (W.Stack t (l:ls) rs) = W.Stack t ls (l:rs)
swapUp'  (W.Stack t []     rs) = W.Stack t (reverse rs) []

swapDown' :: W.Stack a -> W.Stack a
swapDown' = reverseStack . swapUp' . reverseStack

-- | reverse a stack: up becomes down and down becomes up.
reverseStack :: W.Stack a -> W.Stack a
reverseStack (W.Stack t ls rs) = W.Stack t rs ls

-- baseXPKeymap :: M.Map (KeyMask,KeySym) (XP ())
-- baseXPKeymap = M.fromList
--   [ ((controlMask, xK_g), quit)
--   , ((controlMask, xK_bracketleft), quit)
--   , ((0, xK_Escape), quit)
--   , ((0, xK_Return), setSuccess True >> setDone True)
--   , ((0, xK_KP_Enter), setSuccess True >> setDone True)
--   , ((0, xK_BackSpace), deleteString Prev)
--   , ((0, xK_Delete), deleteString Next)
--   , ((0, xK_space), setSuccess True >> setDone True
--       >> spawn "xdotool key super+x")
--   , ((controlMask, xK_h), setSuccess True >> setDone True
--       >> spawn "urxvtc -name xmomacs-help -e man xmonad")
--   , ((controlMask, xK_r), setSuccess True >> setDone True
--       >> spawn "xmonad --recompile; xmonad --restart")
--   , ((controlMask, xK_q), io (exitWith ExitSuccess))
--   ]

-- baseXPConfig = def
--   { font                = "xft:VictorMono Nerd Font:size=11"
--   , bgColor             = "#ffffff"
--   , fgColor             = "#141404"
--   , bgHLight            = "#cccccc"
--   , fgHLight            = "#1f8c35"
--   , borderColor         = "#1f8c35"
--   , promptBorderWidth = 2
--   , position = CenteredAt (103 % 108) (1 % 2)
--   , alwaysHighlight = False
--   , height = 60
--   , maxComplRows = Just 14
--   , historySize = 256
--   , historyFilter = id
--   , promptKeymap = baseXPKeymap
--   , defaultText = []
--   , autoComplete = Just 0
--   , showCompletionOnTab = False
--   , searchPredicate = isPrefixOf
--   }

-- windowXPKeymap :: M.Map (KeyMask,KeySym) (XP ())
-- windowXPKeymap = M.fromList
--   [ ((controlMask, xK_z), killBefore)
--   , ((controlMask, xK_k), killAfter)
--   , ((controlMask, xK_a), startOfLine)
--   , ((controlMask, xK_e), endOfLine)
--   , ((controlMask, xK_m), deleteString Next)
--   , ((controlMask, xK_b), moveCursor Prev)
--   , ((controlMask, xK_f), moveCursor Next)
--   , ((controlMask, xK_BackSpace), killWord Prev)
--   , ((controlMask, xK_y), pasteString)
--   , ((controlMask, xK_g), quit)
--   , ((controlMask, xK_bracketleft), quit)
--   , ((mod1Mask, xK_BackSpace), killWord Prev)
--   , ((mod1Mask, xK_f), moveWord Next)
--   , ((mod1Mask, xK_b), moveWord Prev)
--   , ((mod1Mask, xK_d), killWord Next)
--   , ((mod1Mask, xK_n), moveHistory W.focusUp')
--   , ((mod1Mask, xK_p), moveHistory W.focusDown')
--   , ((0, xK_Return), setSuccess True >> setDone True)
--   , ((0, xK_KP_Enter), setSuccess True >> setDone True)
--   , ((0, xK_BackSpace), deleteString Prev)
--   , ((0, xK_Delete), deleteString Next)
--   , ((0, xK_Left), moveCursor Prev)
--   , ((0, xK_Right), moveCursor Next)
--   , ((0, xK_Home), startOfLine)
--   , ((0, xK_End), endOfLine)
--   , ((0, xK_Down), moveHistory W.focusUp')
--   , ((0, xK_Up), moveHistory W.focusDown')
--   , ((0, xK_Escape), quit)
--   ]

-- windowXPConfig = baseXPConfig
--   { promptKeymap        = windowXPKeymap
--   , alwaysHighlight     = True
--   , autoComplete        = Nothing
--   , showCompletionOnTab = False
--   , searchPredicate     = fuzzyMatch
--   , sorter              = fuzzySort
--   }

------------------------------------------------------------------------

main = xmonad
       . ewmhFullscreen
       . ewmh
       . docks
       $ defaults

defaults = def {
      -- simple stuff
        terminal           = myTerminal,
        focusFollowsMouse  = myFocusFollowsMouse,
        clickJustFocuses   = myClickJustFocuses,
        borderWidth        = myBorderWidth,
        modMask            = myModMask,
        workspaces         = myWorkspaces,
        normalBorderColor  = myNormalBorderColor,
        focusedBorderColor = myFocusedBorderColor,

      -- key bindings
        keys               = myKeys,
        mouseBindings      = myMouseBindings,

      -- hooks, layouts
        layoutHook         = myLayout,
        manageHook         = myManageHook,
        handleEventHook    = myEventHook,
        logHook            = myLogHook,
        startupHook        = myStartupHook
    } `additionalKeysP` myAdditionalKeys
